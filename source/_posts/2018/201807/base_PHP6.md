---
title: PHP_基础 (6)
date: 2018-07-16
tags: 
    - PHP 
    - Interview
toc: true
---

### PHP面试点
    持续更新

<!-- more -->

#### PHP
    是一个基于服务端来创建动态网站的脚本语言

#### OOP[面向对象]
- 是程序的一种设计方式,它利于提高程序的重用性,使程序结构更加清晰.主要特征: 封装、继承、多态
- 易维护 质量高 效率高 易扩展

#### SESSION与COOKIE的区别
- 存储位置
    * session存储于服务器,cookie存储于浏览器
- 安全性
    * session安全性比cookie高
- session为‘会话服务’,在使用时需要开启服务,cookie不需要开启,可以直接用
- SESSION依赖于COOKIE进行传递. 禁用COOKIE后,session不能正常使用.
- SESSION的缺点
    * 保存在服务器端,每次读取都从服务器进行读取,对服务器有资源消耗.
- SESSION保存在服务器端的文件或数据库中,默认保存在文件中,文件路径由php配置文件的session.save_path指定

#### HTTP状态码
- 一 消息系列
- 二 成功系列
    * 200 请求成功
- 三 重定向系列
    * 302 临时移动
    * 304 未修改 
- 四 请求错误系列
    * 403 禁止访问
    * 404 文件未找到
- 五 服务器端错误系列
    * 500 服务器内部错误
    * 502 错误网关
    * 503 服务器超时

#### get与post表单提交方法
- get是把参数数据队列加到提交表单的ACTION属性所指的URL中,值和表单内各个字段一一对应,在URL中可以看到
- post是通过HTTP post机制,将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址
- get传值一般在2KB以内,post传值大小可以在php.ini中进行设置
- get安全性非低,post安全性较高,执行效率却比Post高

#### echo(),print(),print_r()的区别
- echo是PHP语句, print和print_r是函数,语句没有返回值,函数可以有返回值(即便没有用) 
- Print()只能打印出简单类型变量的值(如int,string) 
- print_r()可以打印出复杂类型变量的值(如数组,对象) 
- echo 输出一个或者多个字符串

#### 魔术方法
- __call()当调用不存在的方法时会自动调用的方法 
- __autoload()在实例化一个尚未被定义的类是会自动调用次方法来加载类文件 
- __set()当给未定义的变量赋值时会自动调用的方法 
- __get()当获取未定义变量的值时会自动调用的方法 
- __construct()构造方法,实例化类时自动调用的方法 
- __destroy()销毁对象时自动调用的方法 
- __unset()当对一个未定义变量调用unset()时自动调用的方法 
- __isset()当对一个未定义变量调用isset()方法时自动调用的方法 
- __clone()克隆一个对象 
- __tostring()当输出一个对象时自动调用的方法

#### XSS攻击
- GET或POST内容未过滤,可以提交JS以及HTML等恶意代码.
- 所有传递到后台的数据都要过滤HTML标签

#### CSRF跨站攻击
- 强迫受害者的浏览器向一个易受攻击的Web应用程序发送请求,最后达到攻击者所需要的操作行为
- 采用类似随即码或者令牌的形式,让用户操作唯一性(token)

#### sql注入安全问题
- 通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串,最终达到欺骗服务器执行恶意的SQL命令
- POST提交,过滤参数,PDO绑定

#### php.ini中magic_quotes_gpc, magic_quotes_runtime的作用
- magic_quotes_gpc的作用是在POST、GET、COOKIE数据上使用addslashes()自动转义
- magic_quotes_runtime参数的作用是设置状态,当状态为0时则关闭自动转义,设置为1则自动转义,将数据库中取出来的单引号、双引号、反斜线这些字符加上反斜杠转义.

#### 单引号双引号
- 单引号内部的变量不会执行, 双引号会执行
- 单引号解析速度比双引号快.
- 单引号只能解析部分特殊字符,双引号可以解析所有特殊字符

#### 修改session的生存时间
- 在php.ini 中设置 session.gc_maxlifetime = 1440 //默认时间
- session_set_cookie_params(24 * 3600)

#### private、protected、public
- private
    * 私有成员, 在类的内部才可以访问.
- protected
    * 保护成员,该类内部和继承类中可以访问.
- public
    * 公共成员,完全公开,没有访问限制

#### $this和self、parent
- $this 当前对象, 在当前类中使用,使用->调用属性和方法.
- self 当前类, 也在当前类中使用,不过需要使用::调用
- parent 当前类的父类, 在类中使用

#### Memcach的理解
- Memcache是一种缓存技术,在一定的时间内将动态网页经过解析之后保存到文件,下次访问时动态网页就直接调用这个文件,而不必在重新访问数据库.
- 使用memcache做缓存的好处是: 提高网站的访问速度,减轻高并发时服务器的压力. 
- Memcache的优点: 稳定、配置简单、多机分布式存储、速度快

#### include与require的区别
- 加载失败的处理方式不同
    * include在引入不存文件时产生一个警告且脚本还会继续执行
    * require则会导致一个致命性错误且脚本停止执行
- 文件引用方式
    * include有返回值,而require没有[require的速度比include快]
- require_once表示了只包含一次,避免了重复包含

#### PHP运行方式
    web server(比如说nginx)只是内容的分发者.
    如果请求/index.html,那么web server会去文件系统中找到这个文件,发送给浏览器,这里分发的是静态数据.
    如果现在请求的是/index.php,根据配置文件,nginx知道这个不是静态文件,需要去找PHP解析器来处理,那么他会把这个请求简单处理后交给PHP解析器
    CGI就是规定要传哪些数据、以什么样的格式传递给后方处理这个请求的协议.仔细想想,你在PHP代码中使用的用户从哪里来的.
    当web server收到/index.php这个请求后,会启动对应的CGI程序,这里就是PHP的解析器.接下来PHP解析器会解析php.ini文件,初始化执行环境,然后处理请求,再以规定CGI规定的格式返回处理后的结果,退出进程.web server再把结果返回给浏览器.

    标准的CGI对每个请求都会执行这些步骤,所以处理每个时间的时间会比较长.这明显不合理嘛！那么Fastcgi是怎么做的呢？首先,Fastcgi会先启一个master,解析配置文件,初始化执行环境,然后再启动多个worker.当请求过来时,master会传递给一个worker,然后立即可以接受下一个请求.这样就避免了重复的劳动,效率自然是高.而且当worker不够用时,master可以根据配置预先启动几个worker等着；当然空闲worker太多时,也会停掉一些,这样就提高了性能,也节约了资源.这就是fastcgi的对进程的管理.

    大家都知道,PHP的解释器是php-cgi.php-cgi只是个CGI程序,他自己本身只能解析请求,返回结果,不会进程管理所以就出现了一些能够调度php-cgi进程的程序,PHP-FPM就是这种程序
- CGI
    * 通用网关接口
    * 是一个可伸缩地、高速地在HTTP server和动态脚本语言间通信的接口
    * 把网页和Web服务器中的执行程序连接起来,它把HTML接收的指令传递给服务器的执行程序,再把服务器执行程序的结果返还给HTML页
- FastCGI
    * 激活后一直运行,像是一个常驻的CGI
    * PHP的FastCGI进程管理器是PHP-FPM
- CLI
    * 命令行运行
- Web模块模式
    * Apache等Web服务器运行的模式
    * 以mod_php5模块的形式集成
    * 接收Apache传递过来的PHP文件请求,并处理这些请求,然后将处理后的结果返回给Apache
- ISAPI
    * 是微软提供的一套面向Internet服务的API接口.一个ISAPI的DLL,可以在被用户请求激活后长驻内存,等待用户的另一个请求,还可以在一个DLL里设置多个用户请求处理函数,此外,ISAPI的DLL应用程序和WWW服务器处于同一个进程中,效率要显著高于CGI

#### 获取文件扩展名
    ```php
        function getExt1($filename)
        {
            $arr = explode('.',$filename);
            return array_pop($arr);;
        }

        function getExt2($filename)
        {
            $ext = strrchr($filename,'.');
            return $ext;
        }

        function getExt3($filename)
        {
            $pos = strrpos($filename, '.');
            $ext = substr($filename, $pos);
            return $ext;
        }

        function getExt4($filename)
        {
            $arr = pathinfo($filename);
            $ext = $arr['extension'];
            return $ext;
        }

        function getExt5($filename)
        {
            $str = strrev($filename);
            return strrev(strchr($str,'.',true));
        }
    ```

#### MVC优劣
- 优
    * 可以为一个模型在运行时同时建立和使用多个视图.变化-传播机制可以确保所有相关的视图及时得到模型数据变化,从而使所有关联的视图和控制器做到行为同步. 
    * 视图与控制器的可接插性,允许更换视图和控制器对象,而且可以根据需求动态的打开或关闭、甚至在运行期间进行对象替换. 
    * 模型的可移植性.因为模型是独立于视图的,所以可以把一个模型独立地移植到新的平台工作.需要做的只是在新平台上对视图和控制器进行新的修改. 
    * 潜在的框架结构.可以基于此模型建立应用程序框架,不仅仅是用在设计界面的设计中.
- 劣
    * 增加了系统结构和实现的复杂性.对于简单的界面,严格遵循MVC,使模型、视图与控制器分离,会增加结构的复杂性,并可能产生过多的更新操作,降低运行效率. 
    * 视图与控制器间的过于紧密的连接.视图与控制器是相互分离,但确实联系紧密的部件,视图没有控制器的存在,其应用是很有限的,反之亦然,这样就妨碍了他们的独立重用. 
    * 视图对模型数据的低效率访问.依据模型操作接口的不同,视图可能需要多次调用才能获得足够的显示数据.对未变化数据的不必要的频繁访问,也将损害操作性能. 
    * 目前,一般高级的界面工具或构造器不支持MVC架构.改造这些工具以适应MVC需要和建立分离的部件的代价是很高的,从而造成使用MVC的困难

#### 面向对象和面向过程
- 面向对象
    * 把构成问题事务分解成各个对象,描叙某个事物在整个解决问题的步骤中的行为
    * 优
        * 结构清晰
        * 封装性
        * 容易扩展
        * 实现简单
    * 劣
        * 和代码底层的直接交互非常少
        * 复杂性高
- 面向过程
    * 分析出解决问题所需要的步骤,然后用函数把这些步骤一步一步实现,使用的时候一个一个依次调用
    * 优
        * 效率高
        * 流程明确
    * 劣
        * 重用性低
        * 扩展能力差,维护起来难度比较高

#### PHP的错误类型
- 提示
    * 这都是一些非常正常的信息,而非重大的错误,有些甚至不会展示给用户.比如访问不存在的变量.
- 警告
    * 这是有点严重的错误,将会把警告信息展示给用户,但不会影响代码的输出,比如包含一些不存在的文件.
- 错误
    * 这是真正的严重错误,比如访问不存在的php类

#### file_get_content和fread区别
- fread() 最大一次性能读取8k长度的字节数,所以不能一次性读取大文件去作下载. 优势在于,操作更加灵活,每次读取指定字节的内容,用于下载时方便控制服务器的流量.
- file_get_contents() 函数把整个文件读入一个字符串中. 与 函数file()不同的是 file_get_contents() 把文件读入一个字符串,而file()把整个文件读入一个数组中.
- file_get_contents() 函数是用于将文件的内容读入到一个字符串中的首选方法.如果操作系统支持,还会使用内存映射技术来增强性能.在读取小文本内容到字符串变量时,这个函数最适合使用,简单,更快.