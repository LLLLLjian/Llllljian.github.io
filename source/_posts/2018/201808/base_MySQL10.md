---
title: MySQL_基础 (10)
date: 2018-08-21
tags: MySQL
toc: true
---

### MySQL索引
    版本信息 : MySQL5.6 innodb引擎
    最近面试问到索引的时候发现自己只会一些索引优化和建立索引需要注意的地方,并没有深入理解,重新学一下索引

<!-- more -->

#### 索引是什么
- 转载内容
    * 索引,使用索引可快速访问数据库表中的特定信息
    * 索引是对数据库表中一列或多列的值进行排序的一种结构
    * 在关系数据库中,索引是一种与表有关的数据库结构,它可以使对应于表的SQL语句执行得更快
    * 索引是一个单独的、物理的数据库结构,它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单.
    * 索引提供指向存储在表的指定的列中的数据值的指针,然后根据您指定的排序顺序对这些指针排序
- 个人理解
    * 索引在关系型数据库中相当于目录在新华字典中的作用一样
    * 如果不使用目录查的话,要把整个字典翻一遍,然后和你想找的字一个一个去对比,直到翻完整个字典
    * 如果使用目录查的话,就先去目录中查找相应的条件,然后根据目录中的页码快速找到对应数据所在的页

#### 作用
- 主键递增,数据行写入可以提高插入性能,可以避免page分裂,减少表碎片提升空间和内存的使用
- 主键要选择较短的数据类型, Innodb引擎普通索引都会保存主键的值,较短的数据类型可以有效的减少索引的磁盘空间,提高索引的缓存效率
- 无主键的表删除,在row模式的主从架构,会导致备库夯住

#### 索引利弊
- 优点
    * 大大加快数据的检索速度
    * 通过创建唯一性索引,保证数据库表中每一行数据的唯一性
    * 加速表和表之间的连接
    * 在使用分组和排序子句进行数据检索时,可以显著减少查询中分组和排序的时间
- 缺点
    * 创建索引和维护索引要耗费时间
    * 索引需要占物理空间
    * 索引也要动态的维护

#### 索引使用准则
- 应该创建索引的列
    * 在经常需要搜索的列上,可以加快搜索的速度；
    * 在作为主键的列上,强制该列的唯一性和组织表中数据的排列结构；
    * 在经常用在连接的列上,这些列主要是一些外键,可以加快连接的速度；
    * 在经常需要根据范围进行搜索的列上创建索引,因为索引已经排序,其指定的范围是连续的；
    * 在经常需要排序的列上创建索引,因为索引已经排序,这样查询可以利用索引的排序,加快排序查询时间；
    * 在经常使用在WHERE子句中的列上面创建索引,加快条件的判断速度
- 不应该创建索引的列
    * 对于那些在查询中很少使用或者参考的列不应该创建索引.这是因为,既然这些列很少使用到,因此有索引或者无索引,并不能提高查询速度.相反,由于增加了索引,反而降低了系统的维护速度和增大了空间需求.
    * 对于那些只有很少数据值的列也不应该增加索引.这是因为,由于这些列的取值很少,例如人事表的性别列,在查询的结果中,结果集的数据行占了表中数据行的很大比例,即需要在表中搜索的数据行的比例很大.增加索引,并不能明显加快检索速度.
    * 对于那些定义为text, image和bit数据类型的列不应该增加索引.这是因为,这些列的数据量要么相当大,要么取值很少.
    * 当修改性能远远大于检索性能时,不应该创建索引.这是因为,修改性能和检索性能是互相矛盾的.当增加索引时,会提高检索性能,但是会降低修改性能.当减少索引时,会提高修改性能,降低检索性能.因此,当修改性能远远大于检索性能时,不应该创建索引.

#### 索引类型
- 普通索引
    * 最基本的索引,它没有任何限制
- 唯一索引
    * 索引列的值必须唯一,但允许有空值.如果是组合索引,则列值的组合必须唯一
- 主键索引
    * 是一种特殊的唯一索引,一个表只能有一个主键,不允许有空值
- 组合索引
    * 多个字段上创建的索引,只有在查询条件中使用了创建索引时的第一个字段,索引才会被使用.使用组合索引时遵循最左前缀集合
- 全文索引
    * 主要用来查找文本中的关键字,而不是直接与索引中的值相比较

#### 索引相关概念
- 聚簇索引
    * 数据表的物理顺序与索引顺序相同的
    * 优点是查询速度快
    * 缺点是对表进行修改速度较慢
    * InnoDB中主键索引默认就是聚簇索引
- 非聚簇索引
    * 数据表的物理顺序与索引顺序不相同
- 二叉查找树
    * 左子树的键值小于根的键值,右子树的键值大于根的键值
- 平衡二叉树
    * 符合二叉查找树的条件下,还满足任何节点的两个子树的高度最大差为1
- B-Tree
    * B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块
    * 每个节点中不仅包含数据的key值,还有data值
- B+Tree
    * 所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上