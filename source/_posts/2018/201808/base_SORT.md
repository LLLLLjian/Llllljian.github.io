---
title: SORT_总结
date: 2018-08-05
tags: 
    - SORT 
    - Interview
toc: true
---

### PHP常用算法
    用PHP实现常用算法

<!-- more -->

#### 插入排序
- 实现原理
    * 插入排序是一种最简单直观的排序算法,它的工作原理是通过构建有序序列,对于未排序数据,在已排序序列中从后向前扫描,找到相应位置并插入
- 算法步骤
    * 将第一待排序序列第一个元素看做一个有序序列,把第二个元素到最后一个元素当成是未排序序列
    * 从头到尾依次扫描未排序序列,将扫描到的每个元素插入有序序列的适当位置
- eg
    ```php
        function insertSort($arr) 
        {
            $len=count($arr); 
            for($i=1, $i<$len; $i++) {
                $tmp = $arr[$i];
                //内层循环控制,比较并插入
                for($j=$i-1;$j>=0;$j--) {
                    if($tmp < $arr[$j]) {
                        //发现插入的元素要小,交换位置,将后边的元素与前面的元素互换
                        $arr[$j+1] = $arr[$j];
                        $arr[$j] = $tmp;
                    } else {
                        //如果碰到不需要移动的元素,由于是已经排序好是数组,则前面的就不需要再次比较了.
                        break;
                    }
                }
            }
            return $arr;
        }
    ```

#### 希尔排序
- 实现原理
    * 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序,待整个序列中的记录“基本有序”时,再对全体记录进行依次直接插入排序
- 算法步骤
    * 选择一个增量序列t1,t2,…,tk,其中ti>tj,tk=1；
    * 按增量序列个数k,对序列进行k 趟排序；
    * 每趟排序,根据对应的增量ti,将待排序列分割成若干长度为m 的子序列,分别对各子表进行直接插入排序.仅增量因子为1 时,整个序列作为一个表来处理,表长度即为整个序列的长度
- eg
    ```php
        function ShellSort($arr)
        {
            $count = count($arr);
            $inc = $count;    //增量
            do {
                //计算增量
                //$inc = floor($inc / 3) + 1;
                $inc = ceil($inc / 2);
                for ($i = $inc; $i < $count; $i++) {
                    $temp = $arr[$i];    //设置哨兵
                    //需将$temp插入有序增量子表
                    for ($j = $i - $inc; $j >= 0 && $arr[$j + $inc] < $arr[$j]; $j -= $inc) {
                        $arr[$j + $inc] = $arr[$j]; //记录后移
                    }
                    //插入
                    $arr[$j + $inc] = $temp;
                }
                //增量为1时停止循环
            } while ($inc > 1);
        }
    ```

#### 选择排序
- 实现原理
    * 通过 n - i 次关键字间的比较,从 n - i + 1 个记录中选出关键字最小的记录,并和第 i (1 <= i <= n） 个记录交换,执行n-1趟 后就完成了记录序列的排序
- 算法步骤
    * 首先在未排序序列中找到最小(大）元素,存放到排序序列的起始位置
    * 再从剩余未排序元素中继续寻找最小(大）元素,然后放到已排序序列的末尾.
    * 重复第二步,直到所有元素均排序完毕.
- eg
    ```php
        function selectSort($arr) 
        {
        //双重循环完成,外层控制轮数,内层控制比较次数
        $len=count($arr);
            for($i=0; $i<$len-1; $i++) {
                //先假设最小的值的位置
                $p = $i;
                
                for($j=$i+1; $j<$len; $j++) {
                    //$arr[$p] 是当前已知的最小值
                    if($arr[$p] > $arr[$j]) {
                    //比较,发现更小的,记录下最小值的位置；并且在下次比较时采用已知的最小值进行比较.
                        $p = $j;
                    }
                }
                //已经确定了当前的最小值的位置,保存到$p中.如果发现最小值的位置与当前假设的位置$i不同,则位置互换即可.
                if($p != $i) {
                    $tmp = $arr[$p];
                    $arr[$p] = $arr[$i];
                    $arr[$i] = $tmp;
                }
            }
            //返回最终结果
            return $arr;
        }
    ```

#### 冒泡排序
- 实现原理
    * 重复地走访过要排序的数列,一次比较两个元素,如果他们的顺序错误就把他们交换过来,小的往前,大的往后
- 算法步骤
    * 比较相邻的元素.如果第一个比第二个大,就交换他们两个.
    * 对每一对相邻元素作同样的工作,从开始第一对到结尾的最后一对.这步做完后,最后的元素会是最大的数.
    * 针对所有的元素重复以上的步骤,除了最后一个.
    * 持续每次对越来越少的元素重复上面的步骤,直到没有任何一对数字需要比较
- eg
    ```php
        function bubbleSort($arr)
        {
            $n = count($arr);
            // 冒泡的轮数(最多$n-1轮)
            for ($i=1;$i<$n;$i++) {
                // 是否发生位置交换的标志
                $flag = 0;       
                // 每一轮冒泡(两两比较,大者后移)
                for ($j=0;$j<$n-$i;$j++) {
                    // 前者大于后者,交换位置
                    if ($arr[$j] > $arr[$j+1]) {  
                        $tmp = $arr[$j];
                        $arr[$j] = $arr[$j+1];
                        $arr[$j+1] = $tmp;
                        $flag = 1;
                    }
                }
                // 没有发生位置交换,排序已完成
                if ($flag == 0) {     
                    break;
                }
            }
            
            return $arr;
        }
    ```

#### 快速排序
- 实现原理
    * 通过一趟排序将待排记录分割成独立的两部分,其中一部分的关键字均比另一部分记录的关键字小,则可分别对这两部分记录继续进行快速排序,整个排序过程可以递归进行,以达到整个序列有序的目的.
- 算法步骤
    * 选择一个基准元素,通常选择第一个元素或者最后一个元素.
    * 通过一趟扫描,将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素
    * 基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分
- eg
    ```php
        function quickSort($arr) 
        {
            //先判断是否需要继续进行
            $length = count($arr);
            if($length <= 1) {
                return $arr;
            }
            //选择第一个元素作为基准
            $base_num = $arr[0];
            //遍历除了标尺外的所有元素,按照大小关系放入两个数组内
            //初始化两个数组
            $left_array = array();  //小于基准的
            $right_array = array();  //大于基准的
            for ($i=1; $i<$length; $i++) {
                if ($base_num > $arr[$i]) {
                    //放入左边数组
                    $left_array[] = $arr[$i];
                } else {
                    //放入右边
                    $right_array[] = $arr[$i];
                }
            }
            //再分别对左边和右边的数组进行相同的排序处理方式递归调用这个函数
            $left_array = quick_sort($left_array);
            $right_array = quick_sort($right_array);
            //合并
            return array_merge($left_array, array($base_num), $right_array);
        }
    ```