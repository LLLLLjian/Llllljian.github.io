---
title: Interview_总结 (22)
date: 2019-09-02
tags: Interview
toc: true
---

### 笔试总结
    列一下你的笔试题
    
<!-- more -->

#### 问题1
- Q
    * & 引用,结合案例分析
- A
    * PHP 的引用允许用两个变量来指向同一个内容.
    * 引用传递变量
    * eg1
        ```php
            function foo(&$var)
            { 
                $var++; 
            }
            $a=5;
            foo($a);
        ```
    * eg2
        ```php
            $a = 1;
            $b =& $a;
            unset($a);

            echo $a; // PHP Notice: Undefined variable: a
            echo $b; // 1
        ```

#### 问题2
- Q
    * == 与 === 区别
- A
    * ==是不带类型比较是否相同(比如数字100 == ‘100’结果为true),===是带类型比较是否相同(比如100 == ‘100’结果为false)

#### 问题3
- Q
    * isset 与 empty 区别
- A
    * isset()函数
        * 检测变量是否设置 
        * 若变量不存在则返回 FALSE 
        * 若变量存在且其值为NULL,也返回 FALSE 
        * 若变量存在且值不为NULL,则返回 TURE 
        * 同时检查多个变量时,每个单项都符合上一条要求时才返回 TRUE,否则结果为 FALSE
    * empty()函数
        * 检查一个变量是否为空 
        * 若变量不存在则返回 TRUE 
        * 若变量存在且其值为""、0、"0"、NULL、、FALSE、array()、var $var; 以及没有任何属性的对象,则返回 TURE 
        * 若变量存在且值不为""、0、"0"、NULL、、FALSE、array()、var $var; 以及没有任何属性的对象,则返回 FALSE 

#### 问题4 
- Q
    * 全部魔术函数理解
- A
    * \__construct 类的构造函数,常用来给类的属性赋值,注意事项: 如果子类中定义了构造函数则不会隐式调用其父类的构造函数.要执行父类的构造函数,需要在子类的构造函数中调用 parent::__construct().如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承(假如没有被定义为 private 的话)
    * __destruct 析构函数,析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行.
    * \__call,\__callStatic 在对象中调用一个不可访问方法时,\__call() 会被调用.在静态上下文中调用一个不可访问方法时,__callStatic() 会被调用,作为调用类中不存在的方法时对开发者的一个友好提示
    * \__set,\__get,\__isset ,\__unset 在给不可访问属性赋值时,\__set() 会被调用；读取不可访问属性的值时,__get() 会被调用；当对不可访问属性调用 isset() 或 empty() 时,\__isset() 会被调用；当对不可访问属性调用 unset() 时,__unset() 会被调用.
    * __sleep,__wakeup serialize() 函数会检查类中是否存在一个魔术方法 __sleep().如果存在,该方法会先被调用,然后才执行序列化操作.此功能可以用于清理对象,并返回一个包含对象中所有应被序列化的变量名称的数组.如果该方法未返回任何内容,则 NULL 被序列化,并产生一个 E_NOTICE 级别的错误.返回父类的私有成员的名字,常用于提交未提交的数据,或类似的清理操作；与之相反,unserialize() 会检查是否存在一个 __wakeup() 方法.如果存在,则会先调用 __wakeup 方法,预先准备对象需要的资源.__wakeup() 经常用在反序列化操作中,例如重新建立数据库连接,或执行其它初始化操作
    * __toString 用于当直接echo $obj(一个对象)时该显示什么内容,必须返回一个字符串且不能在方法内抛出异常
    * __invoke 当尝试以调用函数的方式调用一个对象时,__invoke() 方法会被自动调用,例如function __invoke($x) { var_dump($x); } $obj = new CallableClass; $obj(5);会输出int(5)
    * __set_state 调用 var_export() 导出类时,此静态 方法会被调用.本方法的唯一参数是一个数组,其中包含按 array('property' => value, ...) 格式排列的类属性
    * __clone 对象复制可以通过 clone 关键字来完成(如果可能,这将调用对象的 __clone()方法).对象中的 __clone() 方法不能被直接调用.
    * $copy_of_object = clone $object; 当对象被复制后,PHP 5 会对对象的所有属性执行一个浅复制(shallow copy).所有的引用属性 仍然会是一个指向原来的变量的引用.当复制完成时,如果定义了 __clone() 方法,则新创建的对象(复制生成的对象)中的 __clone()方法会被调用,可用于修改属性的值(如果有必要的话).
    * __debugInfo 当var_dumo(new Class)(参数为一个对象时),该方法可以控制显示的内容,若没有定义此方法,var_dump()将默认展示对象的所有属性和方法

#### 问题5
- Q
    * private、protected、public、final 区别
- A
    * public:权限是最大的,可以内部调用,实例调用等.
    * protected: 受保护类型,用于本类和继承此类的子类调用.
    * private: 私有类型,只有在本类中使用.
    * static: 静态资源,可以被子类继承.
    * abstract: 修饰抽象方法,没有方法体,由继承该类的子类来实现.
    * final: 表示该变量、该方法已经“完成”,不可被覆盖.修饰类时该类不能被继承.(因此final和abstract不能同时出现)

#### 问题6
- Q
    * OOP思想
- A
    * 面向对象的编程就是编出一个人来,这个人可以做很多种动作,跑,跳,走,举手...他能做什么取决于你如何组合这些动作,有些动作在一些功能中是不用的.
    * 而层次化的编程(面向过程)就是造出一个具体的工具,他只能干这样一件事,条件——结果.

#### 问题7
- Q
    * 抽象类、接口 分别使用场景
- A
    * 接口通常是为了抽象一种行为,接口是一种规范,在设计上的意义是为了功能模块间的解耦,方便后面的功能扩展、维护,接口不能有具体的方法;
    * 抽象类可以有具体的方法,也可以有抽象方法,一旦一个类有抽象方法,这个类就必须声明为抽象类,很多时候是为子类提供一些共用方法;


