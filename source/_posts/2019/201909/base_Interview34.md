---
title: Interview_总结 (34)
date: 2019-09-20
tags: Interview
toc: true
---

### 笔试总结
    列一下你的笔试题
    
<!-- more -->

#### 问题1
- Q
    * 数据库和缓存的一致性问题
- A
    * 当处理写请求时有两种方式：
        * 先写缓存再写DB, 如果第一步写缓存失败,直接返回,无影响.如果缓存写成功,DB写失败,此时如果不清除缓存中已写入的数据,则会造成数据不一致（缓存中是新值,DB中是旧值）.如果增加清除缓存的逻辑,那么清除操作又失败了该如何处理？
        * 先写DB再写缓存, 如果DB写入失败,直接返回,无影响.如果DB写入成功,缓存写入失败则会造成数据不一致（即DB中是新值,缓存中是旧值）.如果重试写入缓存,那重试也失败该如何处理？
    * 解决方案
        * 开辟一个异步任务去保证最终一致性
        * 缓存数据设置过期时间
    

#### 缓存淘汰算法-LRU算法
- 核心思想
    * 最近使用的页面数据会在未来一段时期内仍然被使用,已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用
- 实现方式
    * 新数据插入到链表头部
    * 每当缓存命中（即缓存数据被访问）,则将数据移到链表头部
    * 当链表满的时候,将链表尾部的数据丢弃.
- 分析
    * 命中率
        * 当存在热点数据时,LRU的效率很好,但偶发性的、周期性的批量操作会导致LRU命中率急剧下降,缓存污染情况(缓存污染是指操作系统将不常用的数据从内存移到缓存,降低了缓存效率的现象)比较严重
    * 复杂度
        * 实现简单
    * 代价
        * 命中时需要遍历链表,找到命中的数据块索引,然后需要将数据移到头部

#### LRU-K
- 核心思想
    * LRU-K中的K代表最近使用的次数,因此LRU可以认为是LRU-1.LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题,其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”
- 实现
    * 1. 数据第一次被访问,加入到访问历史列表；
    * 2. 如果数据在访问历史列表里后没有达到K次访问,则按照一定规则（FIFO,LRU）淘汰；
    * 3. 当访问历史队列中的数据访问次数达到K次后,将数据索引从历史队列删除,将数据移到缓存队列中,并缓存此数据,缓存队列重新按照时间排序；
    * 4. 缓存数据队列中被再次访问后,重新排序；
    * 5. 需要淘汰数据时,淘汰缓存队列中排在末尾的数据,即：淘汰“倒数第K次访问离现在最久”的数据
- 分析
    * 命中率
        * LRU-K降低了“缓存污染”带来的问题,命中率比LRU要高.
    * 复杂度
        * LRU-K队列是一个优先级队列,算法复杂度和代价比较高.
    * 代价
        * 由于LRU-K还需要记录那些被访问过、但还没有放入缓存的对象,因此内存消耗会比LRU要多；当数据量很大的时候,内存消耗会比较可观
        * LRU-K需要基于时间进行排序（可以需要淘汰时再排序,也可以即时排序）,CPU消耗比LRU要高

#### TwoQueues
- 核心思想
    * Two queues（以下使用2Q代替）算法类似于LRU-2,不同点在于2Q将LRU-2算法中的访问历史队列（注意这不是缓存数据的）改为一个FIFO缓存队列,即：2Q算法有两个缓存队列,一个是FIFO队列,一个是LRU队列
- 实现
    * 新访问的数据插入到FIFO队列；
    * 如果数据在FIFO队列中一直没有被再次访问,则最终按照FIFO规则淘汰；
    * 如果数据在FIFO队列中被再次访问,则将数据移到LRU队列头部；
    * 如果数据在LRU队列再次被访问,则将数据移到LRU队列头部；
    * LRU队列淘汰末尾的数据.
- 分析
    * 命中率
        * 2Q算法的命中率要高于LRU.
    * 复杂度
        * 需要两个队列,但两个队列本身都比较简单.
    * 代价
        * FIFO和LRU的代价之和
        * 2Q算法和LRU-2算法命中率类似,内存消耗也比较接近,但对于最后缓存的数据来说,2Q会减少一次从原始存储读取数据或者计算数据的操作.

#### MultiQueue
- 核心思想
    * MQ算法根据访问频率将数据划分为多个队列,不同的队列具有不同的访问优先级,其核心思想是：优先缓存访问次数多的数据
- 实现
    * 新插入的数据放入Q0；
    * 每个队列按照LRU管理数据；
    * 当数据的访问次数达到一定次数,需要提升优先级时,将数据从当前队列删除,加入到高一级队列的头部；
    * 为了防止高优先级数据永远不被淘汰,当数据在指定的时间里访问没有被访问时,需要降低优先级,将数据从当前队列删除,加入到低一级的队列头部；
    * 需要淘汰数据时,从最低一级队列开始按照LRU淘汰；每个队列淘汰数据时,将数据从缓存中删除,将数据索引加入Q-history头部；
    * 如果数据在Q-history中被重新访问,则重新计算其优先级,移到目标队列的头部；
    * Q-history按照LRU淘汰数据的索引
- 分析
    * 命中率
        * MQ降低了“缓存污染”带来的问题,命中率比LRU要高.
    * 复杂度
        * MQ需要维护多个队列,且需要维护每个数据的访问时间,复杂度比LRU高.
    * 代价
        * MQ需要记录每个数据的访问时间,需要定时扫描所有队列,代价比LRU要高.

