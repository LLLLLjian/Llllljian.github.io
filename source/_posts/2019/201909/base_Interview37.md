---
title: Interview_总结 (37)
date: 2019-09-25
tags: Interview
toc: true
---

### 笔试总结
    列一下你的笔试题
    
<!-- more -->

#### MYSQL锁结构图
    针对mysql的innodb存储引擎，mysql锁包括了乐观锁和悲观锁。而悲观锁又包括共享锁和排它锁，共享锁/排它锁里又有行锁和表锁的实现
![MYSQL锁结构图](/img/20190925_1.png)

#### 锁详解
- 乐观锁
    * 乐观锁不是数据库自带的，需要我们自己去实现
    * 乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。
    * 通常实现是这样的：在表中的数据进行操作时(更新)，先给数据表加一个版本(version)字段，每操作一次，将那条记录的版本号加1。然后update的时候，where子句里，增加version值的判断，如果update返回的值是0，说明是版本号冲突，如果是1，则更新成功
- 悲观锁
    * 悲观锁是由数据库自己实现了的
    * 在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作
    * 悲观锁包括共享锁和排它锁
    * 共享锁(读锁)
        * 对于多个不同的事务，对同一个资源共享同一个锁
    * 排它锁(写锁)
        * 对于多个不同的事务，对同一个资源只能有一把锁
    * 如何判断获取的是行锁还是表锁
        * SELECT * from city where id = "1"  lock in share mode; 这个sql里，如果id这个字段带了索引，则获取的是行锁，否则获取的是表锁
    * 行锁
        * 最大的特点就是锁定对象的颗粒度很小, 所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能
        * 由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁
    * 表锁
        * 表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣