---
title: Interview_总结 (46)
date: 2019-10-29
tags: Interview
toc: true
---

### 笔试总结
    列一下你的笔试题

<!-- more -->

#### 问题1
- Q
    * PHP执行的时候有如下执行过程：Scanning(Lexing) - Compilation - Execution - Parsing，其含义分别为
- A
    * 扫描->解析->编译->执行->输出
    * Scanning(Lexing) ,将PHP代码转换为语言片段(Tokens)【将index.php内容变成一个个语言片段(token)】
    * Parsing, 将Tokens转换成简单而有意义的表达式【将一个个语言片段变成有意义的表达式】
    * Compilation, 将表达式编译成Opocdes【将表达式编译成中间码(opcode)】
    * Execution, 顺次执行Opcodes，每次一条，从而实现PHP脚本的功能。【将中间码一条一条的执行】
    * output buffer,将要输出的内容输出到缓冲区

#### 问题2
- Q
    * php魔术常量
- A
    * \_\_LINE__ : 文件中的当前行号
    * \_\_FILE__ : 文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名
    * \_\_DIR__ : 文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录
    * \_\_FUNCTION__ : 返回该函数被定义时的名字
    * \_\_CLASS__ : 类的名称
    * \_\_TRAIT__ : Trait 的名字
    * \_\_METHOD__ : 类的方法名
    * \_\_NAMESPACE__ : 当前命名空间的名称

#### 问题3
- Q
    * PHP文件操作函数及文件指针
- A
    * fopen(),文件打开函数，读写参数有：
        * R  ： 只读，指针在文件开头
        * r+ ： 读写，指针同上
        * W  ： 只写，写入前会删除文件内容，然后指针回到文件开头，文件不存在则创建
        * w+ ： 读写，其他同上
        * A  ： 只写，指针在文件末尾，文件不存在则创建，注意：此模式为“追加”
        * a  ： 读写， 同上
        * x  ： 创建并打开文件（方式：只写），如果文件已存在，则返回一个E_warning错误
        * x+ ： 创建并打开文件（方式：读写），其他同上
    * 读取文件：file() 与file_get_contents()
        * file()返回数组，file_get_contents()返回字符串
    * 文件写操作：fwrite（）
        * 第一个参数为文件指针，第二个参数为传入的字符串
    * 文件指针偏移：fseek（）
        * 第一个参数为文件指针，第二个参数为偏移量（int类型）字节，第三个参数决定文件指针的初始位置，配合第二个参数决定最终指针的位置。
        * 第三个参数的可用选项：
            * SEEK_CUR:指针当前位置
            * SEEK_END：文件末尾，如果想向前偏移，偏移量必须为负数。
            * SEEK_SET:文件开始位置
    * 获取偏移量：ftell（）

#### 问题4
- Q
    * 分库分表之后，id主键如何处理
- A
    * 基于数据库的实现方案
        * 数据库自增id, 单独一个表或者一个库存自增主键, 性能缺陷
        * 设置数据库sequence或者表自增字段步长, 局限性导致后续扩展性低
    * UUID
        * 好处是本地生成，不要基于数据库来了
        * 不好之处就是，UUID 太长了、占用空间大，作为主键性能太差了；更重要的是，UUID 不具有有序性，会导致 B+ 树索引在写的时候有过多的随机写操作
    * 获取系统当前时间
        * 并发很高时并不实用, 要和业务进行拼接生成唯一编号
    * snowflake算法
        * 是 twitter 开源的分布式 id 生成算法，采用 Scala 语言实现，是把一个 64 位的 long 型的 id，1 个 bit 是不用的，用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号

#### 问题5
- Q
    * 简述php的垃圾收集机制
- A
    * php中的变量存储在变量容器zval中，zval中除了存储变量类型和值外，还有is_ref和refcount字段。refcount表示指向变量的元素个数，is_ref表示变量是否有别名。如果refcount为0时，就回收该变量容器。如果一个zval的refcount减1之后大于0，它就会进入垃圾缓冲区。当缓冲区达到最大值后，回收算法会循环遍历zval，判断其是否为垃圾，并进行释放处理。

