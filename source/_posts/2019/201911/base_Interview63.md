---
title: Interview_总结 (63)
date: 2019-11-28
tags: Interview
toc: true
---

### 笔试总结
    列一下你的笔试题 

<!-- more -->

#### 问题1
- Q
    * 数据库范式
- A
    * 第一范式：列不可分, eg:【联系人】(姓名, 性别, 电话), 一个联系人有家庭电话和公司电话, 那么这种表结构设计就没有达到 1NF；
    * 第二范式：有主键, 保证完全依赖.eg:订单明细表【OrderDetail】(OrderID, ProductID, UnitPrice, Discount, Quantity, ProductName), Discount(折扣), Quantity(数量)完全依赖(取决)于主键(OderID,   ProductID), 而 UnitPrice, ProductName 只依赖于 ProductID, 不符合2NF；
    * 第三范式：无传递依赖(非主键列 A 依赖于非主键列 B, 非主键列 B 依赖于主键的情况), eg:订单表【Order】(OrderID, OrderDate, CustomerID, CustomerName, CustomerAddr, CustomerCity)主键是(OrderID), CustomerName, CustomerAddr, CustomerCity 直接依赖的是 CustomerID(非主键列), 而不是直接依赖于主键, 它是通过传递才依赖于主键, 所以不符合 3NF

#### 问题2
- Q
    * B树和B+树差异
- A
    * n 棵子树的结点中含有n个关键码；
    * 所有的叶子结点中包含了全部关键码的信息, 及指向含有这些关键码记录的指针, 且叶子结点本身依关键码的大小自小而大的顺序链接
    * 非终端结点可以看成是索引部分, 结点中仅含有其子树根结点中最大(或最小)关键码.

#### 问题3
- Q
    * 为什么说B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引
- A
    * B+tree的磁盘读写代价更低：B+tree的内部结点并没有指向关键字具体信息的指针(红色部分), 因此其内部结点相对B 树更小.如果把所有同一内部结点的关键字存放在同一盘块中, 那么盘块所能容纳的关键字数量也越多.一次性读入内存中的需要查找的关键字也就越多, 相对来说IO读写次数也就降低了；
    * B+tree的查询效率更加稳定：由于内部结点并不是最终指向文件内容的结点, 而只是叶子结点中关键字的索引, 所以, 任何关键字的查找必须走一条从根结点到叶子结点的路.所有关键字查询的路径长度相同, 导致每一个数据的查询效率相当；
    * 数据库索引采用B+树而不是B树的主要原因：B+树只要遍历叶子节点就可以实现整棵树的遍历, 而且在数据库中基于范围的查询是非常频繁的, 而B树只能中序遍历所有节点, 效率太低.
    * B+树支持range-query非常方便, 而B树不支持

#### 问题4
- Q
    * 索引的优点
- A
    * 大大加快数据的检索速度, 这也是创建索引的最主要的原因；
    * 加速表和表之间的连接；
    * 在使用分组和排序子句进行数据检索时, 同样可以显著减少查询中分组和排序的时间；
    * 通过创建唯一性索引, 可以保证数据库表中每一行数据的唯一性；

#### 问题4
- Q
    * 什么情况下设置了索引但无法使用
- A
    * 以“%(表示任意0个或多个字符)”开头的LIKE语句, 模糊匹配；
    * OR语句前后没有同时使用索引；
    * 数据类型出现隐式转化(如varchar不加单引号的话可能会自动转换为int型)；
    * 对于多列索引, 必须满足 最左匹配原则 (eg：多列索引col1、col2和col3, 则 索引生效的情形包括 col1或col1, col2或col1, col2, col3).

#### 问题5
- Q
    * 什么样的字段适合创建索引？
- A
    * 经常作查询选择的字段
    * 经常作表连接的字段
    * 经常出现在order by, group by, distinct 后面的字段

#### 问题6
- Q
    * 创建索引时需要注意什么
- A
    * 非空字段：应该指定列为NOT NULL, 除非你想存储NULL.在mysql中, 含有空值的列很难进行查询优化, 因为它们使得索引、索引的统计信息以及比较运算更加复杂.你应该用0、一个特殊的值或者一个空串代替空值；
    * 取值离散大的字段：(变量各个取值之间的差异程度)的列放到联合索引的前面, 可以通过count()函数查看字段的差异值, 返回值越大说明字段的唯一值越多字段的离散程度高；
    * 索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高.

#### 问题7
- Q
    * 简单说一说drop、delete与truncate的区别
- A
    * Delete用来删除表的全部或者一部分数据行, 执行delete之后, 用户需要提交(commmit)或者回滚(rollback)来执行删除或者撤销删除,  delete命令会触发这个表上所有的delete触发器；
    * Truncate删除表中的所有数据, 这个操作不能回滚, 也不会触发这个表上的触发器, TRUNCATE比delete更快, 占用的空间更小；
    * Drop命令从数据库中删除表, 所有的数据行, 索引和权限也会被删除, 所有的DML触发器也不会被触发, 这个命令也不能回滚.
    * 在不再需要一张表的时候, 用drop；在想删除部分数据行时候, 用delete；在保留表而删除所有数据的时候用truncate.

#### 问题8
- Q
    * MySQL存储引擎中的MyISAM和InnoDB区别详解
- A
    * 存储结构：每个MyISAM在磁盘上存储成三个文件：第一个文件的名字以表的名字开始, 扩展名指出文件类型..frm文件存储表定义, 数据文件的扩展名为.MYD (MYData), 索引文件的扩展名是.MYI (MYIndex).InnoDB所有的表都保存在同一个数据文件中(也可能是多个文件, 或者是独立的表空间文件), InnoDB表的大小只受限于操作系统文件的大小, 一般为2GB.
    * 存储空间：MyISAM可被压缩, 占据的存储空间较小, 支持静态表、动态表、压缩表三种不同的存储格式.InnoDB需要更多的内存和存储, 它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引.
    * 可移植性、备份及恢复：MyISAM的数据是以文件的形式存储, 所以在跨平台的数据转移中会很方便, 同时在备份和恢复时也可单独针对某个表进行操作.InnoDB免费的方案可以是拷贝数据文件、备份 binlog, 或者用 mysqldump, 在数据量达到几十G的时候就相对痛苦了.
    * 事务支持：MyISAM强调的是性能, 每次查询具有原子性, 其执行数度比InnoDB类型更快, 但是不提供事务支持.InnoDB提供事务、外键等高级数据库功能, 具有事务提交、回滚和崩溃修复能力.
    * AUTO_INCREMENT：在MyISAM中, 可以和其他字段一起建立联合索引.引擎的自动增长列必须是索引, 如果是组合索引, 自动增长可以不是第一列, 它可以根据前面几列进行排序后递增.InnoDB中必须包含只有该字段的索引, 并且引擎的自动增长列必须是索引, 如果是组合索引也必须是组合索引的第一列.
    * 表锁差异：MyISAM只支持表级锁, 用户在操作MyISAM表时, select、update、delete和insert语句都会给表自动加锁, 如果加锁以后的表满足insert并发的情况下, 可以在表的尾部插入新的数据.InnoDB支持事务和行级锁.行锁大幅度提高了多用户并发操作的新能, 但是InnoDB的行锁, 只是在WHERE的主键是有效的, 非主键的WHERE都会锁全表的.
    * 全文索引：MyISAM支持 FULLTEXT类型的全文索引；InnoDB不支持FULLTEXT类型的全文索引, 但是innodb可以使用sphinx插件支持全文索引, 并且效果更好.
    * 表主键：MyISAM允许没有任何索引和主键的表存在, 索引都是保存行的地址.对于InnoDB, 如果没有设定主键或者非空唯一索引, 就会自动生成一个6字节的主键(用户不可见), 数据是主索引的一部分, 附加索引保存的是主索引的值.
    * 表的具体行数：MyISAM保存表的总行数, select count() from table;会直接取出出该值；而InnoDB没有保存表的总行数, 如果使用select count() from table；就会遍历整个表, 消耗相当大, 但是在加了wehre条件后, myisam和innodb处理的方式都一样.
    * CURD操作：在MyISAM中, 如果执行大量的SELECT, MyISAM是更好的选择.对于InnoDB, 如果你的数据执行大量的INSERT或UPDATE, 出于性能方面的考虑, 应该使用InnoDB表.DELETE从性能上InnoDB更优, 但DELETE FROM table时, InnoDB不会重新建立表, 而是一行一行的删除, 在innodb上如果要清空保存有大量数据的表, 最好使用truncate table这个命令.
    * 外键：MyISAM不支持外键, 而InnoDB支持外键.
