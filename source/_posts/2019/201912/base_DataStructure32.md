---
title: DataStructure_基础 (32)
date: 2019-12-30
tags: DataStructure
toc: true
---

### 漫画算法：小灰的算法之旅读书笔记
    漫画算法观后感之面试算法[寻找全排列的下一个数]

<!-- more -->

#### 寻找全排列的下一个数
- Q
    * 假设给定一个正整数, 请给出这个数字全排列的下一个数
    * 例如12345的下一个是12354 12354的下一个是12435
- A
    * <a href="#desc1">字典序算法</a>
    1. 从后向前查看逆序区域, 找到逆序区域的前一位, 也就是数字交换的边界
    2. 让逆序区域的前一位和逆序区域中大于他的最小值交换位置
    3. 把原来的逆序区域改为正序
    ```php
        function nextPermutation($num)
        {
            $len = strlen($num);
            

            // 1.从右往左查找第一个左邻小于右邻的数字
            for ($i=$len-1;$i>0;$i--) {
                if ($num[$i] > $num[$i-1]) {
                    $a = $i - 1;
                    break;
                }
                $a = 0;
            }

            // 2.找到比$a大的数字
            for ($i=$len-1;$i>0;$i--) {
                if ($num[$i] > $num[$a]) {
                    $b = $i;
                    break;
                }
            }

            // 3.交换位置
            $temp = $num[$a];
            $num[$a] = $num[$b];
            $num[$b] = $temp;
    
            // 4.逆序改为正序
            $temp0 = substr($num, 0, $a+1);
            $temp1 = substr($num, $a+1);
    
            return $temp0 . strrev($temp1);
        }

        var_dump(nextPermutation("12345"));
        var_dump(nextPermutation("12354"));
        var_dump(nextPermutation("12435"));
    ``` 

#### 字典序说明
- 什么叫字典序
    * 就是按照字典中出现的先后顺序进行排序
- 单个字符
    * '0' < '1' < '2' < ... < '9' < 'a' < 'b' < ... < 'z'
- 多个字符
    * 从左到右进行比较, 直至有一位可以比较出大小来
- 全排列的字典序
    * 给定多个字符, 可以按照任意顺序进行排列, 所有排列称为全排列.每一种排列对应一个字符串, 如果这些字符串按照字符串大小的顺序进行排序, 那么就这种排序是基于字典序的全排列
- 字典序算法
    * 以输入为 358764 为例, 字典序算法的步骤：
    1. 从原排列中, 从右至左, 找到第一个左邻小于右邻的字符, 记左邻位置为 a.示例中 a=1, list\[a] = 5.
    2. 重新从右至左, 找到第一个比 list\[a] 大的字符, 记为位置为 b.示例中 b=4, list\[b] = 6.
    3. 交换 a 和 b 两个位置的值.示例变为了 368754.
    4. 将 a 后面的数, 由小到大排列.示例变为了 364578.
- 注意：
    1. 第1步中, 如果找不到左邻小于右邻的数, 则说明给定的排列已经是全排列的最后一个排列了, 则直接返回全排列的第一个排列, 即所有排列中最小的排列, 形成一个循环.
    2. 在第3步交换前, a 后面的数是按照从大到小进行排列(否则第1步中就可以找到左邻小于右邻的数了).
    3. 在交换之后, a 后面的数仍然是按照从大到小排列的, 尽管 b 位置的值变成了 list\[a], 但是由于 b 位置是第一个比 list\[a] 大的, 因此交换之后 list\[a] 仍然比左邻小, 比右邻大.
    4. 既然 a 后面的数是从大到小排列的, 那么第4步的排序, 直接将 a 后面的数倒序即可.

