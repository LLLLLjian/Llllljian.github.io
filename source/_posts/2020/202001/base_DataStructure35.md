---
title: DataStructure_基础 (35)
date: 2020-01-03
tags: DataStructure
toc: true
---

### 漫画算法：小灰的算法之旅读书笔记
    漫画算法观后感之面试算法[求解金矿问题]

<!-- more -->

#### 求解金矿问题
- Q
    * 10个工人挖矿, 每个人只能挖一次, 每个矿必须挖完, 
    * 200kg黄金/3个人 300kg黄金/4个人 350kg黄金/3个人 400kg黄金/5个人  500kg黄金/5个人
- 解题思路1
    * 假设第1个矿注定不被挖, 那么问题就转化为 10个工人在后4个金矿中作出最优解
        * 假设第2个矿注定不被挖, 那么问题就转化为 10个工人在后3个金矿中作出最优解
        * 假设第2个矿一定被挖, 那么问题就转化为 6个工人在后3个矿中作出最优解
    * 相应地假设第1个矿一定被挖, 那么问题就转化为 7个工人在后4个矿中作出最优解
        * 假设第2个矿注定不被挖, 那么问题就转化为 7个工人在后3个金矿中作出最优解
        * 假设第2个矿一定被挖, 那么问题就转化为 3个工人在后3个矿中作出最优解
    * ![金矿问题](/img/20200103_1.png)
    * 缺陷 : 很多无效的重复调用
- 解题思路2
    * ![金矿问题](/img/20200103_2.png)
    * n表示有n个金矿供选择, w表示有w个工人可以使用, p\[n-1]表示第n-1个矿所需要的人数, g\[n-1]表示第n-1个矿所得到的收益, 最优收益是f(n, w)的值
    * 第1行第1列 1个工人1个矿, 但矿所需要的人数5大于目前有的人数1, 所以f(1, 1) = 0
    * 同理可得, 第1行的前4个均为0, 即f(1, 2) = 0;f(1, 3) = 0;f(1, 4) = 0;对应的状态转移方程式为f(n, w) = f(n-1, w)(n>1, w&gt;p\[n-1])
    * 第1行的5个人, f(n, w) = max(f(n-1, w), f(n-1, w-p\[n-1]) + g\[n-1])(n>1, w>=p\[n-1]); 所以f(1, 5) = max(f(0, 5), f(0, 5-5)+400) = max(0, 400) = 400;
    * 同理可得, f(1, 6) = max(f(0, 6), f(0, 6-5) + 400) = 400;
- A
    ```php
        /**
         * $w 工人数量
         * $p 金矿开采所需的工人数量
         * $g 金矿储量
         */
        function getBestGoldMiningV1($w, $p, $g)
        {
            $res= array();
            for ($i=0;$i<count($g);$i++) {
                for ($j=0;$j<=$w;$j++) {
                    $res[$i][$j] = 0;
                }
            }

            for ($i=1;$i<=count($g);$i++) {
                for ($j=1;$j<=$w;$j++) {
                    // 
                    if ($j < $p[$i-1]) {
                        $res[$i][$j] = $res[$i-1][$j];
                    } else {
                        $res[$i][$j] = max($res[$i-1][$j], $res[$i-1][$j-$p[$i-1]] + $g[$i-1]);
                    }
                }
            }
            return $res[count($g)][$w];
        }

        function getBestGoldMiningV2($w, $p, $g)
        {
            $res = array();
            for ($i=1; $i<=$w;$i++) {
                $res[$i] = 0;
            }
            $countG = count($g);
            for ($i=1;$i<=$countG;$i++) {
                for ($j=$w;$j>=1;$j--) {
                    if ($j >= $p[$i-1]) {
                        $res[$j] = max($res[$j], $res[$j-$p[$i-1]] + g[$i-1]);
                    }
                }
            }

            // 返回最后一个格子的值
            return $res[$w];
        }

        $p = array(5, 5, 3, 4, 3);
        $g = array(400, 500, 200, 300, 350);
        var_dump(getBestGoldMiningV1(10, $p, $g));
        var_dump(getBestGoldMiningV2(10, $p, $g));
    ```

    


