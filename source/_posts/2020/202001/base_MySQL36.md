---
title: MySQL_基础 (36)
date: 2020-01-13
tags: 
    - MySQL 
    - Interview
toc: true
---

### 数据库知识点汇总
    基本概念

<!-- more -->

#### 为什么用自增列作为主键
>如果我们定义了主键(PRIMARY KEY), 那么InnoDB会选择主键作为聚集索引.如果没有显式定义主键, 则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引.如果也没有这样的唯一索引, 则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增, 这个ROWID不像ORACLE的ROWID那样可引用, 是隐含的).数据记录本身被存于主索引(一颗B+Tree)的叶子节点上.这就要求同一个叶子节点内(大小为一个内存页或磁盘页)的各条数据记录按主键顺序存放, 因此每当有一条新的记录插入时, MySQL会根据其主键将其插入适当的节点和位置, 如果页面达到装载因子(InnoDB默认为15/16), 则开辟一个新的页(节点).如果表使用自增主键, 那么每次插入新的记录, 记录就会顺序添加到当前索引节点的后续位置, 当一页写满, 就会自动开辟一个新的页. 如果使用非自增主键(如果身份证号或学号等), 由于每次插入主键的值近似于随机, 因此每次新纪录都要被插到现有索引页得中间某个位置, 此时MySQL不得不为了将新记录插到合适位置而移动数据, 甚至目标页面可能已经被回写到磁盘上而从缓存中清掉, 此时又要从磁盘上读回来, 这增加了很多开销, 同时频繁的移动、分页操作造成了大量的碎片, 得到了不够紧凑的索引结构, 后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面.

#### 非关系型数据库和关系型数据库区别, 优势比较?
- 非关系型数据库的优势：
    * 性能：NOSQL是基于键值对的, 可以想象成表中的主键和值的对应关系, 而且不需要经过SQL层的解析, 所以性能非常高.
    * 可扩展性：同样也是因为基于键值对, 数据之间没有耦合性, 所以非常容易水平扩展.
- 关系型数据库的优势：
    * 复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询.
    * 事务支持：使得对于安全性能很高的数据访问要求得以实现.

#### 什么是 内连接、外连接、交叉连接、笛卡尔积等?
- 内连接: 只连接匹配的行
- 左连接: 包含左边表的全部行(不管右边的表中是否存在与它们匹配的行), 以及右边表中全部匹配的行
- 右连接: 包含右边表的全部行(不管左边的表中是否存在与它们匹配的行), 以及左边表中全部匹配的行
- 全外连接: 包含左、右两个表的全部行, 不管另外一边的表中是否存在与它们匹配的行.
- 交叉连接: 生成笛卡尔积－它不使用任何匹配或者选取条件, 而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配

#### varchar和char的使用场景?
1. char的长度是不可变的, 而varchar的长度是可变的.定义一个char[10]和varchar[10].如果存进去的是‘csdn’,那么char所占的长度依然为10, 除了字符‘csdn’外, 后面跟六个空格, varchar就立马把长度变为4了, 取数据的时候, char类型的要用trim()去掉多余的空格, 而varchar是不需要的.
2. char的存取数度还是要比varchar要快得多, 因为其长度固定, 方便程序的存储与查找.char也为此付出的是空间的代价, 因为其长度固定, 所以难免会有多余的空格占位符占据空间, 可谓是以空间换取时间效率.varchar是以空间效率为首位.
3. char的存储方式是：对英文字符(ASCII)占用1个字节, 对一个汉字占用两个字节.varchar的存储方式是：对每个英文字符占用2个字节, 汉字也占用2个字节.
4. 两者的存储数据都非unicode的字符数据.

#### count(*)、count(1)、count(column)的区别
1. count(*)对行的数目进行计算,包含NULL
2. count(column)对特定的列的值具有的行数进行计算,不包含NULL值.
3. count()还有一种使用方式,count(1)这个用法和count(*)的结果是一样的.
- 性能问题:
    1. 任何情况下SELECT COUNT(*) FROM tablename是最优选择;
    2. 尽量减少SELECT COUNT(*) FROM tablename WHERE COL = ‘value’ 这种查询;
    3. 杜绝SELECT COUNT(COL) FROM tablename WHERE COL2 = ‘value’ 的出现.
    4. 如果表没有主键,那么count(1)比count(*)快.
    5. 如果有主键,那么count(主键,联合主键)比count(*)快.
    6. 如果表只有一个字段,count(*)最快.
    7. count(1)跟count(主键)一样,只扫描主键.count(*)跟count(非主键)一样,扫描整个表.明显前者更快一些.

#### 最左前缀原则
> 多列索引： ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age);
> 最左前缀原则：顾名思义, 就是最左优先, 上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引, (lname,fname)组合索引以及(lname,fname,age)组合索引.

