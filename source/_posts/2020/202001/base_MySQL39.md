---
title: MySQL_基础 (39)
date: 2020-01-17
tags: 
    - MySQL 
    - Interview
toc: true
---

### 数据库知识点汇总
    MySQL面试常见问题

<!-- more -->

#### 数据库引擎innodb与myisam的区别
- InnoDB
    * 是 MySQL 默认的**事务型**存储引擎, 只有在需要它不支持的特性时, 才考虑使用其它存储引擎.
    * 实现了四个标准的隔离级别, 默认级别是**可重复读**(REPEATABLE READ).在可重复读隔离级别下, **通过多版本并发控制(MVCC)+ 间隙锁(Next-Key Locking)防止幻影读.**
    * 主索引是**聚簇索引**, 在索引中保存了数据, 从而避免直接读取磁盘, 因此对查询性能有很大的提升.
    * 内部做了很多优化, 包括从磁盘读取数据时采用的**可预测性读**、能够加快读操作并且自动创建的**自适应哈希索引**、能够加速插入操作的插入缓冲区等.
    * 支持真正的**在线热备份**.其它存储引擎不支持在线热备份, 要获取一致性视图需要停止对所有表的写入, 而在读写混合场景中, 停止写入可能也意味着停止读取
- MyISAM
    * 设计简单, 数据以**紧密格式存储**.对于只读数据, 或者表比较小、可以容忍修复操作, 则依然可以使用它.
    * 提供了大量的特性, 包括**压缩表**、**空间数据索引**等.
    * **不支持事务**.
    * **不支持行级锁**, 只能对整张表加锁, 读取时会对需要读到的所有表加共享锁, 写入时则对表加排它锁.但在表有读取操作的同时, 也可以往表中插入新的记录, 这被称为并发插入(CONCURRENT INSERT).

#### MySQL是如何执行一条SQL的
> 客户端请求->连接器(验证用户身份, 给予权限) -> 查询缓存(存在缓存则直接返回, 不存在则执行后续操作)->分析器(对SQL进行词法分析和语法分析操作) -> 优化器(主要对执行的sql优化选择最优的执行方案方法) -> 执行器(执行时会先看用户是否有执行权限, 有才去使用这个引擎提供的接口)->去引擎层获取数据返回(如果开启查询缓存则会缓存查询结果)
- 简单概括
    **连接器**：管理连接、权限验证；
    **查询缓存**：命中缓存则直接返回结果
    **分析器**：对SQL进行词法分析、语法分析；(判断查询的SQL字段是否存在也是在这步)
    **优化器**：执行计划生成、选择索引；
    **执行器**：操作引擎、返回结果；
    **存储引擎**：存储数据、提供读写接口
![MySQL执行SQL过程](/img/20200117_1.png)

#### 为什么使用索引
- 通过创建**唯一性索引**, 可以保证数据库表中每一行数据的唯一性
- 可以大大**加快数据的检索速度**, 这也是创建索引的最主要的原因
- 帮助服务器**避免排序和临时表**将**随机IO变为顺序IO**
- 可以加速**表和表之间的连接**, 特别是在实现数据的参考完整性方面特别有意义

#### 索引这么多优点, 为什么不对表总的每一列创建一个索引

- 当对表中的数据进行增加、删除和修改的时候, **索引也要动态的维护**, 这样就降低了数据的维护速度.
- **索引需要占物理空间**, 除了数据表占数据空间之外, 每一个索引还要占一定的物理空间, 如果要建立簇索引, 那么需要的空间就会更大.
- **创建索引和维护索引要耗费时间**, 这种时间随着数据量的增加而增加

#### 索引如何提高查询速度的
> 将无序的数据变成相对有序的数据(就像查有目的一样)

#### 使用索引的注意事项
- 在经常需要搜索的列上, 可以加快搜索的速度
- 在经常使用在where子句中的列上面创建索引, 加快条件的判断速度
- 在经常需要排序的列上创建索引, 因为索引已经排序, 这样查询可以利用索引的排序, 加快排序查询时间
- 在中到大型表索引都是非常有效的, 但是特大型表的维护开销会很大, 不适合建索引
- 在经常用到连续的列上, 这些列主要是由一些外键, 可以加快连接的速度
- 避免where子句中对字段施加函数, 这会造成无法命中索引
- 在使用InnoDB时使用与业务无关的自增主键作为主键, 即使用逻辑主键, 而不要使用业务主键
- **将打算加索引的列设置为NOT NULL, 否则将导致引擎放弃使用索引而进行全表扫描**
- 删除长期未使用的索引, 不用的索引的存在会造成不必要的性能损耗
- 在使用limit offset查询缓存时, 可以借助索引来提高性能.

#### MySQL索引主要使用的两种数据结构
- **哈希索引**, 对于哈希索引来说, 底层的数据结构肯定是哈希表, 因此在绝大多数需求为单条记录查询的时候, 可以选择哈希索引, 查询性能最快；其余大部分场景, 建议选择BTree索引
- **BTree索引**, Mysql的BTree索引使用的是B树中的B+Tree但对于主要的两种存储引擎(MyISAM和InnoDB)的实现方式是不同的.

#### myisam和innodb实现btree索引方式的区别
- MyISAM, **B+Tree叶节点的data域存放的是数据记录的地址**, 在索引检索的时候, 首先按照B+Tree搜索算法搜索索引, 如果指定的key存在, 则取出其data域的值, 然后以data域的值为地址读区相应的数据记录, 这被称为“非聚簇索引”
- InnoDB, 其数据文件本身就是索引文件, 相比MyISAM, **索引文件和数据文件是分离的**, **其表数据文件本身就是按B+Tree组织的一个索引结构, 树的节点data域保存了完整的数据记录**, 这个索引的key是数据表的主键, 因此InnoDB表数据文件本身就是主索引.这被称为“聚簇索引”或者聚集索引, 而其余的索引都作为辅助索引, 辅助索引的data域存储相应记录主键的值而不是地址, 这也是和MyISAM不同的地方, 在根据主索引搜索时, 直接找到key所在的节点即可取出数据；在根据辅助索引查找时, 则需要先取出主键的值, 在走一遍主索引.因此, 在设计表的时候, 不建议使用过长的字段为主键, 也不建议使用非单调的字段作为主键, 这样会造成主索引频繁分裂.

#### 数据库结构优化
- **范式优化**： 比如消除冗余(节省空间..
- **反范式优化**：比如适当加冗余等(减少join)
- **限定数据的范围**： 务必禁止不带任何限制数据范围条件的查询语句.比如：我们当用户在查询订单历史的时候, 我们可以控制在一个月的范围内.
- **读/写分离**： 经典的数据库拆分方案, 主库负责写, 从库负责读；
- **拆分表**：分区将数据在物理上分隔开, 不同分区的数据可以制定保存在处于不同磁盘上的数据文件里.这样, 当对这个表进行查询时, 只需要在表分区中进行扫描, 而不必进行全表扫描, 明显缩短了查询时间, 另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O, 一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开.对数据量大的时时表可采取此方法.可按月自动建表分区

#### drop,delete与truncate的区别
- drop直接删掉表;
- truncate删除表中数据, 再插入时自增长id又从1开始 ;
- delete删除表中数据, 可以加where字句.



