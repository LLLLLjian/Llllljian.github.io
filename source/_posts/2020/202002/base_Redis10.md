---
title: Redis_基础 (10)
date: 2020-02-17
tags: 
    - Redis
    - Interview
toc: true
---

### Redis面试须知
    记录一下面试中遇到的Redis相关问题

<!-- more -->

#### 单线程的redis为什么这么快
> 纯内存操作
> 单线程操作, 避免了频繁的上下文切换
> 采用了非阻塞I/O多路复用机制

#### Memcache与Redis的区别
1. 存储方式 Memecache把数据全部存在内存之中, 断电后会挂掉, 数据不能超过内存大小. Redis有部份存在硬盘上, redis可以持久化其数据
2. 数据支持类型 memcached所有的值均是简单的字符串, redis作为其替代者, 支持更为丰富的数据类型 , 提供list, set, zset, hash等数据结构的存储
3. 使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样. Redis直接自己构建了VM 机制 , 因为一般的系统调用系统函数的话, 会浪费一定的时间去移动和请求.
4. value 值大小不同: Redis 最大可以达到 1gb；memcache 只有 1mb.
5. redis的速度比memcached快很多
6. Redis支持数据的备份, 即master-slave模式的数据备份

#### 为什么Redis的操作是原子性的, 怎么保证原子性的
> 对于Redis而言, 命令的原子性指的是: 一个操作的不可以再分, 操作要么执行, 要么不执行.Redis的操作之所以是原子性的, 是因为Redis是单线程的.Redis本身提供的所有API都是原子操作, Redis中的事务其实是要保证批量操作的原子性.多个命令在并发中也是原子性的吗？不一定,  将get和set改成单命令操作, incr .使用Redis的事务, 或者使用Redis+Lua==的方式实现

#### Redis持久化机制
> Redis是一个支持持久化的内存数据库, 通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化.当Redis重启后通过把硬盘文件重新加载到内存, 就能达到恢复数据的目的.
- 实现
    * 单独创建fork()一个子进程, 将当前父进程的数据库数据复制到子进程的内存中, 然后由子进程写入到临时文件中, 持久化的过程结束了, 再用这个临时文件替换上次的快照文件, 然后子进程退出, 内存释放.
    * RDB是Redis默认的持久化方式.按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件.即Snapshot快照存储, 对应产生的数据文件为dump.rdb, 通过配置文件中的save参数来定义快照的周期.( 快照可以是其所表示的数据的一个副本, 也可以是数据的一个复制品.)
    * AOF: Redis会将每一个收到的写命令都通过Write函数追加到文件最后, 类似于MySQL的binlog.当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容.当两种方式同时开启时, 数据恢复Redis会优先选择AOF恢复

#### 热点数据和冷数据是什么
- 热点数据, 缓存才有价值对于冷数据而言, 大部分数据可能还没有再次访问到就已经被挤出内存, 不仅占用内存, 而且价值不场景.对于热点数据, 比如我们的某IM产品, 生日祝福模块, 当天的寿星列表, 缓存以后可能读取数十万次.再举个例子, 某导航产品, 我们将导航信息, 缓存以后可能读取数百万次.数据更新前至少读取两次, 缓存才有意义.这个是最基本的策略, 如果缓存还没有起作用就失效了, 那就没有太大价值了.那存不存在, 修改频率很高, 但是又不得不考虑缓存的场景呢？有！比如, 这个读取接口对数据库的压力很大, 但是又是热点数据, 这个时候就需要考虑通过缓存手段, 减少数据库的压力, 比如我们的某助手产品的, 点赞数, 收藏数, 分享数等是非常典型的热点数据, 但是又不断变化, 此时就需要将数据同步保存到Redis缓存, 减少数据库压力

#### 缓存雪崩
- 场景
    * 当缓存服务器重启或者大量缓存集中在某一个时间段失效, 这样在失效的时候, 也会给后端系统(比如DB)带来很大压力
- 解决办法
    * 大多数系统设计者考虑用加锁( 最多的解决方案)或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写, 从而避免失效时大量的并发请求落到底层存储系统上.还有一个简单方案就时讲缓存失效时间分散开

#### 缓存穿透
- 场景 
    * key对应的数据在数据源并不存在, 每次针对此key的请求从缓存获取不到, 请求都会到数据源, 从而可能压垮数据源.比如用一个不存在的用户id获取用户信息, 不论缓存还是数据库都没有, 若黑客利用此漏洞进行攻击可能压垮数据库
- 解决办法
    * 最常见的则是采用布隆过滤器, 将所有可能存在的数据哈希到一个足够大的bitmap中, 一个一定不存在的数据会被这个bitmap拦截掉, 从而避免了对底层存储系统的查询压力.另外也有一个更为简单粗暴的方法, 如果一个查询返回的数据为空(不管是数据不存在, 还是系统故障), 我们仍然把这个空结果进行缓存, 但它的过期时间会很短, 最长不超过五分钟.通过这个直接设置的默认值存放到缓存, 这样第二次到缓冲中获取就有值了, 而不会继续访问数据库, 这种办法最简单粗暴

#### 缓存击穿
- 场景
    * key对应的数据存在, 但在redis中过期, 此时若有大量并发请求过来, 这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存, 这个时候大并发的请求可能会瞬间把后端DB压垮
- 解决办法
    * 使用互斥锁(mutex key). 业界比较常用的做法, 是使用mutex.简单地来说, 就是在缓存失效的时候(判断拿出来的值为空), 不是立即去load db, 而是先使用缓存工具的某些带成功操作返回值的操作(比如Redis的SETNX或者Memcache的ADD)去set一个mutex key, 当操作返回成功时, 再进行load db的操作并回设缓存；否则, 就重试整个get缓存的方法

#### 缓存预热
- 场景
    * 系统上线后, 将相关的缓存数据直接加载到缓存系统.这样就可以避免在用户请求的时候, 先查询数据库, 然后再将数据缓存的问题
- 解决办法
    * 直接写个缓存刷新页面, 上线时手工操作下；
    * 数据量不大, 可以在项目启动的时候自动进行加载；
    * 定时刷新缓存；

#### 缓存更新
> 除了缓存服务器自带的缓存失效策略之外(Redis默认的有6中策略可供选择), 我们还可以根据具体的业务需求进行自定义的缓存淘汰, 常见的策略有两种: (1)定时去清理过期的缓存；(2)当有用户请求过来时, 再判断这个请求所用到的缓存是否过期, 过期的话就去底层系统得到新数据并更新缓存.两者各有优劣, 第一种的缺点是维护大量缓存的key是比较麻烦的, 第二种的缺点就是每次用户请求过来都要判断缓存失效, 逻辑相对比较复杂！具体用哪种方案, 大家可以根据自己的应用场景来权衡.

#### 缓存降级
- 场景
    * 当访问量剧增、服务出现问题(如响应时间慢或不响应)或非核心服务影响到核心流程的性能时, 仍然需要保证服务还是可用的, 即使是有损服务
- 解决办法
    * 是为了防止Redis服务故障, 导致数据库跟着一起发生雪崩问题.因此, 对于不重要的缓存数据, 可以采取服务降级策略, 例如一个比较常见的做法就是, Redis出现问题, 不去数据库查询, 而是直接返回默认值给用户

#### redis的过期策略以及内存淘汰机制
> redis采用的是定期删除+惰性删除策略.为什么不用定时删除策略?定时删除,用一个定时器来负责监视key,过期则自动删除.虽然内存及时释放, 但是十分消耗CPU资源.在大并发请求下, CPU要将时间应用在处理请求, 而不是删除key,因此没有采用这一策略.定期删除+惰性删除是如何工作的呢?定期删除, redis默认每个100ms检查, 是否有过期的key,有过期key则删除.需要说明的是, redis不是每个100ms将所有的key检查一次, 而是随机抽取进行检查(如果每隔100ms,全部key进行检查, redis岂不是卡死).因此, 如果只采用定期删除策略, 会导致很多key到时间没有删除.于是, 惰性删除派上用场.也就是说在你获取某个key的时候, redis会检查一下, 这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除
- 思考
    * 采用定期删除+惰性删除就没其他问题了么?
    * 不是的, 如果定期删除没删除key.然后你也没即时去请求key, 也就是说惰性删除也没生效.这样, redis的内存会越来越高.那么就应该采用内存淘汰机制
- 内存淘汰机制
    * volatile-lru: 从已设置过期时间的数据集(server.db[i].expires)中挑选最近最少使用的数据淘汰




