---
title: Redis_基础 (11)
date: 2020-02-18
tags: 
    - Redis
    - Interview
toc: true
---

### Redis面试须知
    记录一下面试中遇到的Redis相关问题

<!-- more -->

#### Redis数据类型
- <a href="#desc1" title="字符串对象">字符串</a>
    * string 是Redis的最基本的数据类型, 可以理解为与 Memcached 一模一样的类型, 一个key 对应一个 value.string 类型是二进制安全的, 意思是 Redis 的 string 可以包含任何数据, 比如图片或者序列化的对象, 一个 redis 中字符串 value 最多可以是 512M
    * 应用场景
        * 计数: 由于Redis单线程的特点, 我们不用考虑并发造成计数不准的问题, 通过 incrby 命令, 我们可以正确的得到我们想要的结果.
        * 限制次数: 比如登录次数校验, 错误超过三次5分钟内就不让登录了, 每次登录设置key自增一次, 并设置该key的过期时间为5分钟后, 每次登录检查一下该key的值来进行限制登录
    * 底层实现
        * 使用**整数值**实现的字符串对象
        * 使用**embstr编码的动态字符串**实现的字符串对象
        * 使用**动态字符串**实现的字符串对象
- <a href="#desc2" title="列表对象">列表</a>
    * 是简单的字符串列表, 按照插入顺序排序.你可以添加一个元素到列表的头部(左边)或者尾部(右边)
    * 应用场景
        * 缓存热点数据
        * 取最新N个数据的操作：记录前N个最新登陆的用户Id列表, 超出的范围可以从数据库中获得
    * 底层实现
        * 使用**压缩列表**实现的列表对象
        * 使用**双端连标**实现的列表对象
- <a href="#desc3" title="哈希对象">哈希</a>
    * 是一个键值对集合, 是一个 string 类型的 key和 value 的映射表, key 还是key, 但是value是一个键值对(key-value)
    * 应用场景
        * 存储客户信息或者销售信息
    * 底层实现
        * 使用**压缩列表**实现的哈希对象
        * 使用**字典**实现的哈希对象
- <a href="#desc4" title="集合对象">集合</a>
    * 无序的去重的string类型
    * 应用场景
        * 共同好友 
        * 利用唯一性,统计访问网站的所有独立ip 
        * 好友推荐时,根据tag求交集,大于某个阈值就可以推荐
    * 底层实现
        * 使用**整数集合**实现的集合对象
        * 使用**字典**实现的集合对象
- <a href="#desc5" title="有序集合对象">有序集合</a>
    * 有序的去重的string类型
    * 应用场景
        * 排行榜 
        * 带权重的消息队列
    * 底层实现
        * 使用**压缩列表**实现的有序集合对象
        * 使用**跳跃表和字典**实现的有序集合对象

#### Redis应用
1. 显示最新的项目列表-列表
    * 将大表的热点数据放在列表中, 只要不是点击查看全部, 就从Redis中取, 只有在访问很久之前数据的时候才去查库
2. 删除与过滤-列表
    * 可以使用LREM来删除评论
3. 排行榜相关-有序集合
    * 游戏排行榜前几名||当前用户排名
4. 按照用户投票和时间排序-列表
5. 处理过期项目-有序集合
    * 按时间排序插入
6. 计数-字符串
    * 用户停留20s之后显示你想让他看到的东西
7. 特定时间内的特定项目-集合
    * 统计在某段特点时间里有多少特定用户访问了某个特定资源
8. 实时分析正在发生的情况, 用于数据统计与防止垃圾邮件等
9. Pub/Sub
10. 队列
11. 缓存

#### Redis底层数据结构
- 显示数据类型的底层数据结构
    ```bash
        OBJECT ENCODING  key
    ```
- 简单动态字符串
    * 获取字符串长度的复杂度为O(1)
    * API是安全的, 不会造成缓冲区溢出
    * 修改字符串长度N次, 最多需要执行N次内存重分配
    * 可以保存文本或二进制数据
    * 可以使用一部分&gt;string.h>库中的函数
- 链表
    * 通过为链表设置不同类型的特定函数, Redis链表可以保存各种不同类型的值, 除了用作列表键, 还在发布与订阅、慢查询、监视器等方面发挥作用
- 字典
    * Redis的字典底层使用哈希表实现, 每个字典通常有两个哈希表, 一个平时使用, 另一个用于rehash时使用, 使用链地址法解决哈希冲突.
- 跳跃表
    * 是有序集合的底层实现之一, 表中的节点按照分值大小进行排序
- 整数集合
    * 集合键的底层实现之一, 底层由数组构成, 升级特性能尽可能的节省内存
- 压缩列表
    * 是Redis为节省内存而开发的顺序型数据结构, 通常作为列表键和哈希键的底层实现之一

#### <span id="desc1">字符串对象</a>
> 字符串是Redis最基本的数据类型, 不仅所有key都是字符串类型, 其它几种数据类型构成的元素也是字符串.注意字符串的长度不能超过512M
- 编码
    * int 编码：保存的是可以用 long 类型表示的整数值
    * raw 编码：保存长度大于44字节的字符串(redis3.2版本之前是39字节, 之后是44字节)
    * embstr 编码：保存长度小于44字节的字符串(redis3.2版本之前是39字节, 之后是44字节)
- 图示
    ![字符串对象内部编码](/img/20200218_1.png)

#### <span id="desc2">列表对象</a>
> 是简单的字符串列表, 按照插入顺序排序, 你可以添加一个元素到列表的头部(左边)或者尾部(右边), 它的底层实际上是个链表结构
- 编码
    * 列表保存元素个数小于512个且每个元素长度小于64字节, 则使用ziplist(压缩列表)
    * 不能满足上边两个条件则使用linkedlist(双端链表)
- 图示
    ![列表对象内部编码](/img/20200218_2.png)

#### <span id="desc3">哈希对象</a>
> 哈希对象的键是一个字符串类型, 值是一个键值对集合
- 编码
    * 列表保存元素个数小于512个且每个元素长度小于64字节, 则使用ziplist(压缩列表)
    * 不能满足上边两个条件则使用hashtable(字典)
- 图示
    ![哈希对象内部编码](/img/20200218_3.png)

#### <span id="desc4">集合对象</a>
> 集合对象 set 是 string 类型(整数也会转换成string类型进行存储)的无序集合.注意集合和列表的区别：集合中的元素是无序的, 因此不能通过索引来操作元素；集合中的元素不能有重复
- 编码
    * 集合对象中所有元素都是整数且集合对象所有元素数量不超过512, 则使用intset(整数集合)
    * 不能满足上边两个条件则使用hashtable(字典)
- 图示
    ![集合对象内部编码](/img/20200218_4.png)

#### <span id="desc4">有序集合对象</a>
> 和上面的集合对象相比, 有序集合对象是有序的.与列表使用索引下标作为排序依据不同, 有序集合为每个元素设置一个分数(score)作为排序依据
- 编码
    * 保存的元素数量小于128且保存的所有元素长度都小于64字节, 则使用ziplist(压缩列表)
    * 不能满足上边两个条件则使用skiplist(跳跃表和字典)
- 图示
    ![有序集合对象内部编码](/img/20200218_5.png)


