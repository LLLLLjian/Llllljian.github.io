---
title: Interview_总结 (85)
date: 2020-03-30
tags: 
    - Redis
    - Interview
toc: true
---

### 面试题
    今日被问傻系列

<!-- more -->

#### Redis和Memcache区别
1. Redis和Memcache都是将数据存放在内存中,都是内存数据库.不过memcache还可用于缓存其他东西,例如图片、视频等等. 
2. Redis不仅仅支持简单的k/v类型的数据,同时还提供list,set,hash等数据结构的存储. 
5. 分布式–设定memcache集群,利用magent做一主多从;redis可以做一主多从.都可以一主一从 
6. 存储数据安全–memcache挂掉后,数据没了；redis可以定期保存到磁盘(持久化) 
7. 灾难恢复–memcache挂掉后,数据不可恢复; redis数据丢失后可以通过aof恢复 
8. Redis支持数据的备份,即master-slave模式的数据备份.
- 综合结论
    1. 性能上 : 性能上都很出色,具体到细节,由于Redis只使用单核,而Memcached可以使用多核,所以平均每一个核上Redis在存储小数据时比 Memcached性能更高.而在100k以上的数据中,Memcached性能要高于Redis,虽然Redis最近也在存储大数据的性能上进行优化,但是比起 Memcached,还是稍有逊色.
    2. 内存空间和数据量大小 : MemCached可以修改最大内存,采用LRU算法.Redis增加了VM的特性,突破了物理内存的限制.
    3. 操作便利上 : MemCached数据结构单一,仅用来缓存数据,而Redis支持更加丰富的数据类型,也可以在服务器端直接对数据进行丰富的操作,这样可以减少网络IO次数和数据体积.
    4. 可靠性上 : MemCached不支持数据持久化,断电或重启后数据消失,但其稳定性是有保证的.Redis支持数据持久化和数据恢复,允许单点故障,但是同时也会付出性能的代价.
    5. 应用场景 : Memcached: 动态系统中减轻数据库负载,提升性能；做缓存,适合多读少写,大数据量的情况(如人人网大量查询用户信息、好友信息、文章信息等). Redis: 适用于对读写效率要求都很高,数据处理业务复杂和对安全性要求较高的系统(如新浪微博的计数和微博发布部分系统,对数据安全性、读写要求都很高).

#### Redis的过期策略和内存淘汰机制
> redis的过期策略: **定期删除+惰性删除**
注意: Redis中过期的key并不会马上删除,因为定期删除可能正好没抽取到它,我们也没有访问它触发惰性删除
1. 知识点
    * 惰性删除(被动删除): 指某个键值过期后,此键值不会马上被删除,而是等到下次被使用的时候,才会被检查到过期,此时才能得到删除,惰性删除的缺点很明显是浪费内存.
    * 定时删除: Redis设定每隔100ms**随机**抽取设置了过期时间的key,并对其进行检查,如果已经过期则删除.为什么是随机抽取？ 因为如果存储了大量数据,全部遍历一遍是非常影响性能的！每隔一段时间执行一次删除操作,并通过限制删除操作执行的时长和频率,来减少删除操作对cpu的影响.另一方面定时删除也有效的减少了因惰性删除带来的内存浪费.
    * 立即删除: 立即删除能保证内存中数据的最大新鲜度,因为它保证过期键值会在过期后马上被删除,其所占用的内存也会随之释放.但是立即删除对cpu是最不友好的.因为删除操作会占用cpu的时间,如果刚好碰上了cpu很忙的时候,比如正在做交集或排序等计算的时候,就会给cpu造成额外的压力.
2. Redis内存淘汰机制(如何保证redis中的数据都是热点数据)
    * 引入原因: 如果定期删除漏掉了很多过期的key,而我们也没有再去访问它,如果不加处理,很可能导致内存耗尽.
    * 解决方法: Redis配置文件中可以设置maxmemory,内存的最大使用量,到达限度时会执行内存淘汰机制.
    * Redis中的内存淘汰机制: 没有配置时,默认为no-eviction
    * volatile-lru  从已设置过期时间的数据集中挑选【最近最少使用】的数据淘汰
    * volatile-lfu  从已设置过期时间的数据集中挑选【最不经常使用】的数据淘汰
    * volatile-ttl  从已设置过期时间的数据集中挑选【将要过期】的数据淘汰
    * volatile-random 从已设置过期时间的数据集中挑选【任意数据】淘汰
    * allkeys-lru 当内存不足写入新数据时淘汰最近最少使用的Key
    * allkeys-random  当内存不足写入新数据时随机选择key淘汰
    * allkeys-lfu 当内存不足写入新数据时移除最不经常使用的Key
    * no-eviction 【当内存不足写入新数据时,写入操作会报错,同时不删除数据】

#### redis缓存雪崩,缓存穿透,缓存击穿的解决方法
1. 缓存雪崩
    * 缓存雪崩表示在某一时间段,缓存集中失效,导致请求全部走数据库,有可能搞垮数据库,使整个服务瘫痪.
    * 使缓存集中失效的原因: 
        * redis服务器挂掉了.
        * 对缓存数据设置了相同的过期时间,导致某时间段内缓存集中失效.
    * 如何解决缓存集中失效: 
        * 针对原因1,可以实现redis的高可用,Redis Cluster 或者 Redis Sentinel(哨兵) 等方案.
        * 针对原因2,设置缓存过期时间时加上一个随机值,避免缓存在同一时间过期.
        * 使用双缓存策略,设置两个缓存,原始缓存和备用缓存,原始缓存失效时,访问备用缓存,备用缓存失效时间设置长点.
2. 缓存穿透
    * 缓存穿透表示查询一个一定不存在的数据,由于没有获取到缓存,所以没写入缓存,导致这个不存在的数据每次都需要去数据库查询,失去了缓存的意义.请求的数据大量的没有获取到缓存,导致走数据库,有可能搞垮数据库,使整个服务瘫痪.
    * 解决方案: 
        * 对于像ID为负数的非法请求直接过滤掉,采用布隆过滤器(Bloom Filter).
        * 针对在数据库中找不到记录的,我们仍然将该空数据存入缓存中,当然一般会设置一个较短的过期时间.
3. 缓存击穿
    * 缓存击穿表示某个key的缓存非常热门,有很高的并发一直在访问,如果该缓存失效,那同时会走数据库,压垮数据库.缓存击穿与缓存雪崩的区别是这里针对的是某一热门key缓存,而雪崩针对的是大量缓存的集中失效.
    * 解决方案: 
        * 让该热门key的缓存永不过期.
        * 使用互斥锁,通过redis的setnx实现互斥锁.


