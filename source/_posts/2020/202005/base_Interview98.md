---
title: Interview_总结 (98)
date: 2020-05-29
tags: Interview
toc: true
---

### 面试题
    面试题汇总

<!-- more -->

#### MySQL的四种事务隔离级别
- 事务的基本要素(ACID)   
    1. 原子性(Atomicity):事务开始后所有操作, 要么全部做完, 要么全部不做, 不可能停滞在中间环节.事务执行过程中出错,  会回滚到事务开始前的状态, 所有的操作就像没有发生一样.也就是说事务是一个不可分割的整体, 就像化学中学过的原子, 是物质 构成的基本单位.
    2. 一致性(Consistency):事务开始前和结束后, 数据库的完整性约束没有被破坏 .比如A向B转账, 不可能A扣了钱, B却没 收到.
    3. 隔离性(Isolation):同一时间, 只允许一个事务请求同一数据, 不同的事务之间彼此没有任何干扰.比如A正在从一张银行 卡中取钱, 在A取钱的过程结束前, B不能向这张卡转账.
    4. 持久性(Durability):事务完成后, 事务对数据库的所有更新将被保存到数据库, 不能回滚
- 事务的并发问题
    1. 脏读:事务A操作了数据库, 比如添加了一条数据, 但是没有提交事务.这时, 来了事务B, 他要查询所有数据, 如果没有事务 之间没有有效隔离, 那么事务B返回的结果中就会出现事务A刚才添加的数据.
        * “select”操作没有规矩
    2. 不可重复读:事务 A 多次读取同一数据, 事务 B 在事务A多次读取的过程中, 对数据作了更新并提交, 导致事务A多次读取同 一数据时, 结果不一致.
        * “update”操作没有规矩
    3. 幻读:事务A访问了数据库, 查询数据, 同时, 事务B来了, 往数据库加入了一个新的数据.这时候, 事务A再次查询所有数据 的时候, 会出现两次结果不一致.就好像发生了幻觉一样, 这就叫幻读
        * “insert”和“delete”操作没有规矩
- MySQL事务隔离级别
    1. 读未提交(Read Uncommitted)
        * 读未提交, 顾名思义, 就是可以读到未提交的内容,  容易脏读
    2. 读已提交(Read Committed)
        * 只能读到已经提交了的内容, 避免脏读, 会存在不可重复读
    3. 可重复读(Repeated Read)
        * 事务A在读到一条数据之后, 此时事务B对该数据进行了修改并提交, 那么事务A再读该数据, 读到的还是原来的内容.有效的避免“不可重复读”.但却避免不了“幻读”
    4. 串行化(Serializable)
        * 是数据库最高的隔离级别, 这种级别下, 事务“串行化顺序执行”, 也就是一个一个排队执行. 这种级别下, “脏读”、“不可重复读”、“幻读”都可以被避免, 但是执行效率奇差, 性能开销也最大, 所以基本没人会用


#### MVCC多版本并发控制
- 基本原理
    * MVCC的实现, 通过保存数据在某个时间点的快照来实现的.这意味着一个事务无论运行多长时间, 在同一个事务里能够看到数据一致的视图.根据事务开始的时间不同, 同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的
- 基本特征
    1. 每行数据都存在一个版本, 每次数据更新时都更新该版本.
    2. 修改时Copy出当前版本随意修改, 各个事务之间无干扰.
    3. 保存时比较版本号, 如果成功(commit), 则覆盖原记录；失败则放弃copy(rollback)
- InnoDB存储引擎MVCC的实现策略
    * 在每一行数据中额外保存两个隐藏的列: 当前行创建时的版本号和删除时的版本号(可能为空, 其实还有一列称为回滚指针, 用于事务回滚, 不在本文范畴).这里的版本号并不是实际的时间值, 而是系统版本号.每开始新的事务, 系统版本号都会自动递增.事务开始时刻的系统版本号会作为事务的版本号, 用来和查询每行记录的版本号进行比较






