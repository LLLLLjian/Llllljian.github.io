---
title: Interview_总结 (103)
date: 2020-06-05
tags: Interview
toc: true
---

### 面试题
    面试题汇总

<!-- more -->

#### Redis相关
- redis的过期策略
    * 定期删除+惰性删除
- 知识点
    * 惰性删除(被动删除) : 指某个键值过期后, 此键值不会⻢上被删除, 而是等到下次被使用的时候, 才会被检查到过期, 此时才能得到删除, 惰性删除的缺点很明显是浪费内存
    * 定时删除 : Redis设定每隔100ms【随机】抽取设置了过期时间的key, 并对其进行检查, 如果已经过期则删除.为什么是随机抽取? 因为如果存储了大量数据, 全部遍历一遍是非常影响性能的! 每隔一段时间执行一次删除操作, 并通过限制删除操作执行的时⻓和频率, 来减少删除操作对cpu的影响. 另一方面定时删除也有效的减少了因惰性删除带来的内存浪费
    * 立即删除 : 立即删除能保证内存中数据的最大新鲜度, 因为它保证过期键值会在过期后⻢上被删除, 其所占用的内存也会随之释放.但是立即删 除对cpu是最不友好的.因为删除操作会占用cpu的时间, 如果刚好碰上了cpu很忙的时候, 比如正在做交集或排序等计算的时候, 就 会给cpu造成额外的压力
- 考点剖析
    1. 为什么要随机抽取呢?
        * 假设Redis中有大量的key, 并且都设置了过期时间, 如果全量检查的话, 将会耗费大量的CPU时间, 这样有损Redis对外的服务性能
    2. 随机抽取会带来什么问题呢?
        * 可能导致已经过期的key还滞留在内存中, 占用着内存空间. 
    3. 如何解决随机抽取带来的问题呢?
        * 为了解决这个问题, Redis引入了惰性删除.
    4. 如果某些key没有触发惰性删除, 也就是说经过惰性删除 + 定期删除两轮清理, 依旧存在, 该如何解决呢?
        * 这种情况, 在内存不足的时候, Redis的内存淘汰策略就派上用场了
- Redis内存淘汰机制
    * 引入原因:如果定期删除漏掉了很多过期的key, 而我们也没有再去访问它, 如果不加处理, 很可能导致内存耗尽. 
    * 解决方法:Redis配置文件中可以设置maxmemory, 内存的最大使用量, 到达限度时会执行内存淘汰机制.
    * Redis中的内存淘汰机制:没有配置时, 默认为no-eviction
    * 可选项
        * volatile-lru 从已设置过期时间的数据集中挑选【最近最少使用】的数据淘汰 
        * volatile-lfu 从已设置过期时间的数据集中挑选【最不经常使用】的数据淘汰 
        * volatile-ttl 从已设置过期时间的数据集中挑选【将要过期】的数据淘汰 
        * volatile-random 从已设置过期时间的数据集中挑选【任意数据】淘汰 
        * allkeys-lru 当内存不足写入新数据时淘汰最近最少使用的Key
        * allkeys-random 当内存不足写入新数据时随机选择key淘汰
        * allkeys-lfu 当内存不足写入新数据时移除最不经常使用的Key
        * no-eviction 【当内存不足写入新数据时, 写入操作会报错, 同时不删除数据】
- 缓存雪崩
> 缓存雪崩表示在某一时间段, 缓存集中失效, 导致请求全部走数据库, 有可能搞垮数据库, 使整个服务瘫痪. 使缓存集中失效的原因:
1. redis服务器挂掉了.
2. 对缓存数据设置了相同的过期时间, 导致某时间段内缓存集中失效.
    * 如何解决缓存集中失效:
        1. 针对原因1, 可以实现redis的高可用, Redis Cluster 或者 Redis Sentinel(哨兵) 等方案. 
        2. 针对原因2, 设置缓存过期时间时加上一个随机值, 避免缓存在同一时间过期. 
        3. 使用双缓存策略, 设置两个缓存, 原始缓存和备用缓存, 原始缓存失效时, 访问备用缓存, 备用缓存失效时间设 置⻓点.
- 缓存穿透 
> 缓存穿透表示查询一个一定不存在的数据, 由于没有获取到缓存, 所以没写入缓存, 导致这个不存在的数据每次都需 要去数据库查询, 失去了缓存的意义. 请求的数据大量的没有获取到缓存, 导致走数据库, 有可能搞垮数据库, 使整个服务瘫痪. 比如文章表, 一般我们的主键ID都是无符号的自增类型, 有些人想要搞垮你的数据库, 每次请求都用负数ID, 而ID为 负数的记录在数据库根本就没有.
1. 解决方案:
    1. 对于像ID为负数的非法请求直接过滤掉, 采用布隆过滤器(Bloom Filter). 
    2. 针对在数据库中找不到记录的, 我们仍然将该空数据存入缓存中, 当然一般会设置一个较短的过期时间. 
- 缓存击穿 
> 缓存击穿表示某个key的缓存非常热⻔, 有很高的并发一直在访问, 如果该缓存失效, 那同时会走数据库, 压垮数据库.缓存击穿与缓存雪崩的区别是这里针对的是某一热⻔key缓存, 而雪崩针对的是大量缓存的集中失效.
1. 解决方案:
    1. 让该热⻔key的缓存永不过期.
    2. 使用互斥锁, 通过redis的setnx实现互斥锁

