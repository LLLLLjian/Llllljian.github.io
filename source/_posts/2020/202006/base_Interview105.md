---
title: Interview_总结 (105)
date: 2020-06-09
tags: Interview
toc: true
---

### 面试题
    面试题汇总

<!-- more -->

#### redis持久化
- AOF
    * 原理是将Reids的操作日志以追加的方式写入文件
    * 愿意牺牲一些性能, 换取更高的缓存一致性
- RDB
    * 原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化
    * 愿意写操作频繁的时候, 不启用备份来换取更高的性能, 待手动运行save的时候, 再做备份
- 二者的区别
    * RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘, 实际操作过程是fork一个子进程, 先将数据集写入临时文件, 写入成功后, 再替换之前的文件, 用二进制压缩存储.
    * AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作, 查询操作不会记录, 以文本的方式记录, 可以打开文件看到详细的操作记录
- 二者优缺点
    * RDB
        1. 优势 
            * RDB文件紧凑, 全量备份, 非常适合用于进行备份和灾难恢复.
            * 生成RDB文件的时候, redis主进程会fork()一个子进程来处理所有保存工作, 主进程不需要进行任何磁盘IO操作.
            * RDB在恢复大数据集时的速度比AOF的恢复速度要快.
        2. 劣势
            * RDB快照是一次全量备份, 存储的是内存数据的二进制序列化形式, 存储上非常紧凑.当进行快照持久化时, 会开启一个子进程专⻔负责快照持久化, 子进程会拥有父进程的内存数据, 父进程修改内存子进程不会反应出来, 所以在快照持久化期间修改的数据不会被保存, 可能丢失数据.
    * AOF
        1. 优点 
            * AOF可以更好的保护数据不丢失, 一般AOF会每隔1秒, 通过一个后台线程执行一次fsync操作, 最多丢失1秒钟的数据.
            * AOF日志文件没有任何磁盘寻址的开销, 写入性能非常高, 文件不容易破损.
            * AOF日志文件即使过大的时候, 出现后台重写操作, 也不会影响客户端的读写.
            * AOF日志文件的命令通过非常可读的方式进行记录, 这个特性非常适合做灾难性的误删除的紧急恢复.比如某人不小心用flushall命令清空了所有数据, 只要这个时候后台rewrite还没有发生, 那么就可以立即拷⻉AOF文件, 将最后一条flushall命令给删了, 然后再将该AOF文件放回去, 就可以通过恢复机制, 自动恢复所有数据
        2. 劣势
            * 对于同一份数据来说, AOF日志文件通常比RDB数据快照文件更大
            * AOF开启后, 支持的写QPS会比RDB支持的写QPS低, 因为AOF一般会配置成每秒fsync一次日志文件, 当然, 每秒一次fsync, 性能也还是很高的
            * 以前AOF发生过bug, 就是通过AOF记录的日志, 进行数据恢复的时候, 没有恢复一模一样的数据出来

#### Redis的容错机制 
> 节点之间会定时的互相发送ping命令, 测试节点的健康状态, 当节点接受到ping命令后, 会返回一个pong字符串. 投票机制:如果一个节点A给节点B发送ping没有得到pong返回, 会通知其他节点再次给B发送ping, 如果集群中有超过一半的节点收不B节点的pong.那么就认为B节点挂了.一般会为每个节点提供一个备份节点, 如果挂掉会切换到备份节点

#### Redis集群存储原理
> Redis对于每个存放的key会进行hash操作, 生成一个[0-16384]的hash值(先进行crc算法再对16384取余). 集群的情况下, 就是把[0-16384]的区间进行拆分, 放到不同的redis中

#### Redis高可用
> 是当一台服务器停止服务后, 对于业务及用户毫无影响. 停止服务的原因可能由于网卡、路由器、机房、CPU负载过高、内存溢出、自然灾害等不可预期的原因导致, 在很多时候也称单点问题
- 解决单点问题的方式
    * 主备方式
        * 这种通常是一台主机、一台或多台备机, 在正常情况下主机对外提供服务, 并把数据同步到备机, 当主机宕机后, 备机立刻开始服务. Redis HA中使用比较多的是keepalived, 它使主机备机对外提供同一个虚拟IP, 客户端通过虚拟IP进行数据操作, 正常期间主机一直对外提供服务, 宕机后VIP自动漂移到备机上. 优点是对客户端毫无影响, 仍然通过VIP操作. 缺点也很明显, 在绝大多数时间内备机是一直没使用, 被浪费着的
    * 主从方式
        * 这种采取一主多从的办法, 主从之间进行数据同步. 当Master宕机后, 通过选举算法(Paxos、Raft)从slave中选举出新Master继续对外提供服务, 主机恢复后以slave的身份重新加入. 主从另一个目的是进行读写分离, 这是当单机读写压力过高的一种通用型解决方案. 其主机的⻆色只提供写操作或少量的读, 把多余读请求通过负载均衡算法分流到单个或多个slave服务器上. 缺点是主机宕机后, Slave虽然被选举成新Master了, 但对外提供的IP 服务地址却发生变化了, 意味着会影响到客户端. 解决这种情况需要一些额外的工作, 在当主机地址发生变化后及时通知到客户端, 客户端收到新地址后, 使用新地址继续发送新请求
- 数据同步
    * 同步方式:当主机收到客户端写操作后, 以同步方式把数据同步到从机上, 当从机也成功写入后, 主机才返回给客户端成功, 也称数据强一致性. 很显然这种方式性能会降低不少, 当从机很多时, 可以不用每台都同步, 主机同步某一台从机后, 从机再把数据分发同步到其他从机上, 这样提高主机性能分担同步压力. 在Redis中是支持这杨配置的, 一台master, 一台slave, 同时这台salve又作为其他slave的master.
    * 异步方式:主机接收到写操作后, 直接返回成功, 然后在后台用异步方式把数据同步到从机上. 这种同步性能比较好, 但无法保证数据的完整性, 比如在异步同步过程中主机突然宕机了, 也称这种方式为数据弱一致性
- 方案选择
    * keepalived方案配置简单、人力成本小, 在数据量少、压力小的情况下推荐使用.如果数据量比较大, 不希望过多浪费机器, 还希望在宕机后, 做一些自定义的措施, 比如报警、记日志、数据迁移等操作, 推荐使用主从方式, 因为和主从搭配的一般还有个管理监控中心.宕机通知这块, 可以集成到客户端组件上, 也可单独抽离出来

#### Redis分布式
> 是当业务量、数据量增加时, 可以通过任意增加减少服务器数量来解决问题
- 集群时代
    * 至少部署两台Redis服务器构成一个小的集群, 主要有2个目的: 
        * 高可用性:在主机挂掉后, 自动故障转移, 使前端服务对用户无影响. 
        * 读写分离:将主机读压力分流到从机上.
    * 可在客户端组件上实现负载均衡, 根据不同服务器的运行情况, 分担不同比例的读请求压力




