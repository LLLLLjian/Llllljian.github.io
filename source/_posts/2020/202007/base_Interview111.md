---
title: Interview_总结 (111)
date: 2020-07-09
tags: Interview
toc: true
---

### 面试题
    面试题汇总

<!-- more -->

#### 问题1
- Q
    * TCP与UDP的区别
- A
    * TCP是面向连接的, UDP是<a href="#desc1">无连接的</a>
    * TCP是可靠的, UDP<a href="#desc2">不可靠</a>
    * TCP只支持点对点通信, UDP支持一对一、一对多、多对一、多对多
    * TCP是<a href="#desc3">面向字节流的</a>, UDP是面向报文的
    * TCP有拥塞控制机制, UDP没有.网络出现的拥塞不会使源主机的发送速率降低, 这对某些实时应用是很重要的, 比如媒体通信, 游戏；
    * TCP首部开销(20字节)比UDP首部开销(8字节)要大
    * UDP 的主机不需要维持复杂的连接状态表

#### 注释
- Q
    * 什么是无连接<span id="desc1"></span>
- A
    * UDP发送数据之前不需要建立连接
    
#### 注释
- Q
    * 什么叫不可靠<span id="desc2"></span>
- A
    * UDP接收方收到报文后, 不需要给出任何确认

#### 注释
- Q
    * 什么叫面向字节流<span id="desc3"></span>
- A
    * 面向字节流是指发送数据时以字节为单位, 一个数据包可以拆分成若干组进行发送, 而UDP一个报文只能一次发完

#### 问题2
- Q
    * 什么时候选择TCP, 什么时候选UDP
- A
    * 对某些实时性要求比较高的情况, 选择UDP, 比如游戏, 媒体通信, 实时视频流(直播), 即使出现传输错误也可以容忍；其它大部分情况下, HTTP都是用TCP, 因为要求传输的内容可靠, 不出现丢失

#### 问题3
- Q
    * HTTP可以使用UDP吗
- A
    * HTTP不可以使用UDP, HTTP需要基于可靠的传输协议, 而UDP不可靠

#### 问题4
- Q
    * TCP如何保证传输的可靠性
- A
    * 数据包校验
    * 对失序数据包重新排序(TCP报文具有序列号)
    * 丢弃重复数据
    * 应答机制：接收方收到数据之后, 会发送一个确认(通常延迟几分之一秒)；
    * 超时重发：发送方发出数据之后, 启动一个定时器, 超时未收到接收方的确认, 则重新发送这个数据；
    * 流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出

#### TCP三握四挥
- 三次握手
    * 第一次握手:建立连接时, 客户端发送syn包(syn=x)到服务器, 并进入SYN_SENT状态, 等待服务器确认;SYN:同步序列编号 (Synchronize Sequence Numbers).
    * 第二次握手:服务器收到syn包, 必须确认客户的SYN(连接请求)(ack=x+1), 同时自己也发送一个SYN包(syn=y), 即 SYN+ACK包, 此时服务器进入SYN_RECV状态;
    * 第三次握手:客户端收到服务器的SYN+ACK包, 向服务器发送确认包ACK(ack=y+1), 此包发送完毕, 客户端和服务器进入 ESTABLISHED(TCP连接成功)状态, 完成三次握手.
- 四次挥手
    * 第一次挥手:Client发送一个FIN(释放连接), 用来关闭Client到Server的数据传送, Client进入FIN_WAIT_1(终止等待1)状 态.
    * 第二次挥手:Server收到FIN后, 发送一个ACK(确认标志)给Client, 确认序号为收到序号+1(与SYN相同, 一个FIN占用一个序 号), Server进入CLOSE_WAIT(关闭等待)状态.
    * 第三次挥手:Server发送一个FIN, 用来关闭Server到Client的数据传送, Server进入LAST_ACK(最后确认)状态.
    * 第四次挥手:Client收到FIN后, Client进入TIME_WAIT(时间等待)状态, 接着发送一个ACK给Server, 确认序号为收到序号 +1, Server进入CLOSED状态, 完成四次挥手

##### 为什么连接的时候是三次握手, 关闭的时候却是四次握手?
> 因为当Server端收到Client端的SYN连接请求报文后, 可以直接发送SYN+ACK报文.其中ACK报文是用来应答的, SYN报文是用 来同步的.但是关闭连接时, 当Server端收到FIN报文时, 很可能并不会立即关闭SOCKET, 所以只能先回复一个ACK报文, 告诉 Client端, "你发的FIN报文我收到了".只有等到我Server端所有的报文都发送完了, 我才能发送FIN报文, 因此不能一起发送.故需要 四步握手

#### 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态
> 虽然按道理, 四个报文都发送完毕, 我们可以直接进入CLOSE状态了, 但是我们必须假象网络是不可靠的, 有可以最后一个ACK丢失.所以TIME_WAIT状态就是用来重发可能丢失的ACK报文.在Client发送出最后的ACK回复, 但该ACK可能丢失.Server如果没有 收到ACK, 将不断重复发送FIN片段.所以Client不能立即关闭, 它必须确认Server接收到了该ACK.Client会在发送出ACK之后进入到 TIME_WAIT状态.Client会设置一个计时器, 等待2MSL的时间.如果在该时间内再次收到FIN, 那么Client会重发ACK并再次等待 2MSL.所谓的2MSL是两倍的MSL(Maximum Segment Lifetime).MSL指一个片段在网络中最大的存活时间, 2MSL就是一个发送和 一个回复所需的最大时间.如果直到2MSL, Client都没有再次收到FIN, 那么Client推断ACK已经被成功接收, 则结束TCP连接

#### 为什么不能用两次握手进行连接
> 3次握手完成两个重要的功能, 既要双方做好发送数据的准备工作(双方都知道彼此已准备好), 也要允许双方就初始序列号进行协商, 这个序列号在握手过程中被发送和确认.现在把三次握手改成仅需要两次握手, 死锁是可能发生的.作为例子, 考虑计算机S和C之间的通信, 假定C给S发送一个连接请求 分组, S收到了这个分组, 并发送了确认应答分组.按照两次握手的协定, S认为连接已经成功地建立了, 可以开始发送数据分组.可 是, C在S的应答分组在传输中被丢失的情况下, 将不知道S 是否已准备好, 不知道S建立什么样的序列号, C甚至怀疑S是否收到自己 的连接请求分组.在这种情况下, C认为连接还未建立成功, 将忽略S发来的任何数据分 组, 只等待连接确认应答分组.而S在发出的 分组超时后, 重复发送同样的分组.这样就形成了死锁

#### 如果已经建立了连接, 但是客户端突然出现故障了怎么办
> TCP还设有一个保活计时器, 显然, 客户端如果出现故障, 服务器不能一直等下去, 白白浪费资源.服务器每收到一次客户端的请求 后都会重新复位这个计时器, 时间通常是设置为2小时, 若两小时还没有收到客户端的任何数据, 服务器就会发送一个探测报文段, 以 后每隔75秒钟发送一次.若一连发送10个探测报文仍然没反应, 服务器就认为客户端出了故障, 接着就关闭连接

#### web页面加载速度优化
- Q
    * 打开页面白屏10s才能显示,请进行优化排查
- A
    * 页面分析
        * 锁定耗费时间较长的请求
    * 优化图片
        * 合并小图片
        * 优化图片格式
    * 使用免费cdn加载第三方资源
    * 使用cdn储存静态资源
    * 合并压缩js css
    * 代码优化
        * HTML头部的JavaScript和写在HTML标签中的Style会阻塞页面的渲染
        * 按需加载,把统计. 分享等 js 在页面 onload 后再进行加载,可以提高访问速度
        * 优化cookie,减少cookie体积
        * 避免&lt;img>的src为空
        * 尽量避免设置图片大小,多次重设图片大小会引发图片的多次重绘,影响性能
        * 合理使用display属性
            a.display:inline后不应该再使用width. height. margin. padding以及float
            b.display:inline-block后不应该再使用float
            c.display:block后不应该再使用vertical-align
            d.display:table-*后不应该再使用margin或者float
        * 不滥用Float和web字体
        * 尽量使用CSS3动画
        * 使用ajax异步加载部分请求

#### PHP如何处理大流量高并发或者提高页面访问速度
1. 流量优化
    * 防盗链处理(去除恶意请求)
2. 前端优化
    1. 减少HTTP请求[将css,js等合并]
    2. 添加异步请求(先不将所有数据都展示给用户,用户触发某个事件,才会异步请求数据)
    3. 启用浏览器缓存和文件压缩
    4. CDN加速
    5. 建立独立的图片服务器(减少I/O)
3. 服务端优化
    1. 页面静态化
    2. 并发处理
    3. 队列处理
4. 数据库优化
    1. 数据库缓存
    2. 分库分表,分区
    3. 读写分离
    4. 负载均衡
5. web服务器优化
    1. nginx反向代理实现负载均衡
    2. lvs实现负载均衡
