---
title: Interview_总结 (125)
date: 2020-08-27
tags: 
    - HTTP
    - Interview
toc: true
---

### 图解TCP/IP详解
    今日被问傻系列-我的心里为啥没TCP/IP协议

<!-- more -->

#### TCP/IP协议分层
- 四层
    * 应用层
        * FTP 简单文件传输协议
        * HTTP 超文本传输协议
        * TELNET 远程登录
        * SMTP 简单邮件传送协议
        * DNS 域名系统
        * SNMP 简单网络管理协议
    * 传输层
        * TCP协议
        * UDP协议
    * 网络层
        * IP Internet协议
        * ICMP Internet控制信息协议
        * ARP 地址解析协议
        * RARP 反向地址解析协议
        * BOOTP 自举协议
    * 数据链路层
- 五层
    * 应用层
    * 传输层
    * 网络层
    * 数据链路层
        * Frame Relay, HDLC, PPP, IEEE 802.3/802.2, FDDI, ATM,  IEEE 802.5/802.2
    * 物理层
        * EIA/TIA-232, EIA/TIA-499, V.35, V.24, RJ45, Ethernet, 802.3, 802.5, FDDI, NRZI, NRZ, B8ZS
- OSI七层参考模型
    * 应用层
    * FTP,WWW,Telnet,NFS,SMTP,Gateway,SNMP
        * 为应用程序提供服务并规定应用程序中通信的相关细节.包括文件传输、电子邮件、远程登录等协议.
    * 表示层
        * TIFF,GIF,JPEG,PICT,ASCII,EBCDIC,encryption,MPEG,MIDI,HTML
        * 将应用处理的信息转换为适合网络传输的格式,或将来自下一层的数据转换为上层能够处理的格式.因此它主要负责数据格式的转换.
    * 会话层
        * RPC,SQL,NFS,NetBIOS,names,AppleTalk,ASP,DECnet,SCP 
        * 负责建立和断开通信连接(数据流动的逻辑通路),以及数据的分割等数据传输相关的管理.
    * 传输层
        * 起着可靠传输的作用.只在通信双方节点上进行处理,而无需在路由器上处理.会话层负责决定建立连接和断开连接的时机,而传输层进行实际的建立和断开处理
    * 网络层
        * 将数据传输到目标地址.目标地址可以是多个网络通过路由器连接而成的某个地址.因此这一层主要负责寻址和路由选择
    * 数据链路层
        * 负责物理层上的互联、节点之间的通信传输.例如与1个以太网相连的2个节点之间的通信.将0、1序列划分为具有意义的数据帧传送给对端(数据帧的生成与接收).
    * 物理层
        * 负责0、1比特流(0、1序列)与电压的高低、光的闪灭之间的互换
- 图示
    ![TCP/IP协议五层](/img/20200827_1.png)
    ![OSI七层参考模型](/img/20200827_2.png)

#### 故事重现五层协议
> 以五层协议为基础,小明表白小红为主线.
小明暗恋小红很久了,可是却羞于当面表达爱意.于是他决定写一份email发给小红,来表白.
- 第一集
    * 小明从商店买了一堆物理线、网线接口、光纤等.一头连自己家,另一头连小红家.小明想到的第一个问题是: 怎么才能让这个两个物理硬件之间进行通信呢？于是小明发明了比特流,通过 1与 0之间转化为电流的强弱进行信号的传输也就人们常说的数模转换与模数转换.这时候已经完成了第一步,两个物理硬件之间的通信.这也就是我们通常所说的**物理层**
- 第二集
    * 小明想啊: 我这两个物理硬件之间已经完成了通信,但是我怎么确保传输的数据是可靠的、安全的呢？因为小明想要求这封信是可靠的,安全的.他不想别人知道他喜欢小红.因为在我们实际生活当中物理线路往往是不可靠,不安全的.可能会被别人偷听到,网线被别人挖了等等.于是小明发明了**数据链路层**.通过数据链路层来确保数据的正确传输.当中就有一个叫数据包的家伙,通过一个个数据包来传输数据.数据包通过奇偶校验的形式或者其他的形式来校验数据是不是正确的.这个时候我们就完成了一个节点到另外一个节点数据包的传递
- 第三集
    * 小明心想,这时候我已经可以把信发送到小红家了,可是万一小红不在家呢？在学校或者在其他某个地方旅游呢？那岂不是看不到我的信了？这时候小明发明了**网络层**,即路由器.这时候小明会先把他的数据包发送给路由器,然后路由器发送给路由器,一路传过去,最后发送到了小红所在的电脑上,这就是网络层.同时,小明为了标识网络层的各个节点,他定义了Ip协议.因此每个节点都会有个IP
- 第四集
    * 小明心想,这时候在我们数据链路层,能保证数据是否是正确的,但是不能保证我们的数据是不是可靠的.这个时候,我们需要一个能够保证我们数据传输出错后,能够自动重传机制.自动校验数据是否是发对了.这时候小明发明了**传输层**.在传输层里面小明又制定了TCP/UDP协议.TCP协议是基于连接的,会在小明和小红电脑之间建立连接,在这个连接上去传输数据
- 第五集
    * 这时候小明该做的也做了.可是我们的数据是为哪个应用服务的呢？是一个HTTP?还是一个FTP?还是一个Email的协议呢？这个就是小明发明的最后一个协议——**应用层**协议

#### URL在五层协议中的行进路线
> DNS解析->TCP链接->发送HTTP请求->服务器处理请求->浏览器解析渲染页面->连接结束
* 用户输入url,浏览器内部代码将url进行拆分解析
* 浏览器首先去找本地的hosts文件,检查在该文件中是否有相应的域名、IP对应关系,如果有,则向其IP地址发送请求,如果没有就会将domain(域)发送给 dns(域名服务器)进行解析(解析如下图),将域名解析成对应的服务器IP地址,发回给浏览器
* 网络通信
    * **应用层**客户端发送HTTP请求
    * **传输层**TCP传输报文
    * **网络层**IP协议查询MAC地址
    * 服务器接收数据
    * 服务器响应请求
    * 服务器返回相应文件
    * 关闭TCP连接
* 页面的渲染阶段
    * 解析HTML生成DOM树.
    * 解析CSS生成CSSOM规则树.
    * 将DOM树与CSSOM规则树合并在一起生成渲染树.
    * 遍历渲染树开始布局,计算每个节点的位置大小信息.
    * 将渲染树每个节点绘制到屏幕

#### TCP流量控制
> 如果发送方把数据发送得过快,接收方可能会来不及接收,这就会造成数据的丢失.所谓流量控制就是让发送方的发送速率不要太快,要让接收方来得及接收.
利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制
- 问题一: 如何保证次序？
    * 提出问题: 在我们滑动窗口协议之前,我们如何来保证发送方与接收方之间,每个包都能被收到.并且是按次序的呢
    ![单个发送](/img/20200827_3.png)
    * 发送方发送一个包1,这时候接收方确认包1.发送包2,确认包2.就这样一直下去,知道把数据完全发送完毕,这样就结束了.那么就解决了丢包,出错,乱序等一些情况！同时也存在一些问题.问题: 吞吐量非常的低.我们发完包1,一定要等确认包1.我们才能发送第二个包.
- 问题二: 如何提高吞吐量
    * 提出问题: 那么我们就不能先连发几个包等他一起确认吗？这样的话,我们的速度会不会更快,吞吐量更高些呢？
    ![多个发送](/img/20200827_4.png)
    * 如图,这个就是我们把两个包一起发送,然后一起确认.可以看出我们改进的方案比之前的好很多,所花的时间只是一个来回的时间.接下来,我们还有一个问题: 改善了吞吐量的问题
- 问题三: 如何实现最优解？
    * 问题: 我们每次需要发多少个包过去呢？发送多少包是最优解呢？
    * 限制: 
        * 接收方的缓存(接收窗口)可能已经满了,无法接收数据.
        * 网络的带宽也不一定足够大,一口发太多会导致丢包事故
    * 正式引入滑动窗口
- 滑动窗口
    * 发送方缓冲区: 发送方缓冲区用于存储已经准备就绪数据和发送了但是没有被确认的数据.
    * 接收方缓冲区: 接收方缓冲区用于存储已经被接收但是还没有被用户进程消费的数据
    * **初始情况**: 在图中,我们可看出灰色1号2号3号包已经发送完毕,并且已经收到Ack.这些包就已经是过去式.4、5、6、7号包是黄色的,表示已经发送了.但是并没有收到对方的Ack,所以也不知道接收方有没有收到.8、9、10号包是绿色的.是我们还没有发送的.这些绿色也就是我们接下来马上要发送的包. 可以看出我们的窗口正好是11格.后面的11-16还没有被读进内存.要等4号-10号包有接下来的动作后,我们的包才会继续往下发送
        ![TCP初始情况](/img/20200827_5.png)
    * **正常情况**: 可以看到4号包对方已经被接收到,所以被涂成了灰色.“窗口”就往右移一格,这里只要保证“窗口”是7格的. 我们就把11号包读进了我们的缓存.进入了“待发送”的状态.8、9号包已经变成了黄色,表示已经发送出去了.接下来的操作就是一样的了,确认包后,窗口往后移继续将未发送的包读进缓存,把“待发送“状态的包变为”已发送“.
        ![TCP正常情况](/img/20200827_6.png)
    * **丢包情况**: 一直在等Ack.如果一直等不到的话,我们也会把读进缓存的待发送的包也一起发过去.但是,这个时候我们的窗口已经发满了.所以并不能把12号包读进来,而是始终在等待5号包的Ack.
        ![TCP丢包情况](/img/20200827_7.png)
        * 解决方法: 超时重发





