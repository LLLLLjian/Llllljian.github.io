---
title: MySQL_基础 (52)
date: 2020-08-13
tags: 
    - MySQL 
    - Interview
toc: true
---

### 更好的理解MySQL
    MySQL常见考题在实际工作中的运用

<!-- more -->

#### 索引使用场景
- where
    * 根据id查询记录,因为id字段仅建立了主键索引,因此此SQL执行可选的索引只有主键索引,如果有多个,最终会选一个较优的作为检索的依据.
- order by
    * 当我们使用order by将查询结果按照某个字段排序时,如果该字段没有建立索引,那么执行计划会将查询出的所有数据使用外部排序(将数据从硬盘分批读取到内存使用内部排序,最后合并排序结果),这个操作是很影响性能的,因为需要将查询涉及到的所有数据从磁盘中读到内存(如果单条数据过大或者数据量过多都会降低效率),更无论读到内存之后的排序了
- join
    * 对join语句匹配关系(on)涉及的字段建立索引能够提高效率

#### 联合索引是什么？为什么需要注意联合索引中的顺序？
> MySQL可以使用多个字段同时建立一个索引,叫做联合索引.在联合索引中,如果想要命中索引,需要按照建立索引时的字段顺序挨个使用,否则无法命中索引.具体原因为:MySQL使用索引时需要索引有序,假设现在建立了"name,age,school"的联合索引,那么索引的排序为: 先按照name排序,如果name相同,则按照age排序,如果age的值也相等,则按照school进行排序.当进行查询时,此时索引仅仅按照name严格有序,因此必须首先使用name字段进行等值查询,之后对于匹配到的列而言,其按照age字段严格有序,此时可以使用age字段用做索引查找,以此类推.因此在建立联合索引的时候应该注意索引列的顺序,一般情况下,将查询需求频繁或者字段选择性高的列放在前面.此外可以根据特例的查询或者表结构进行单独的调整.

#### explain结果分析
- type
    * ALL 扫描全表数据
    * index 遍历索引
    * range 索引范围查找
    * index_subquery 在子查询中使用 ref
    * unique_subquery 在子查询中使用 eq_ref
    * ref_or_null 对Null进行索引的优化的 ref
    * fulltext 使用全文索引
    * ref 使用非唯一索引查找数据
    * eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联
- extra
    * Using index 使用覆盖索引
    * Using where 使用了用where子句来过滤结果集
    * Using filesort 使用文件排序,使用非索引列进行排序时出现,非常消耗性能,尽量优化.
    * Using temporary 使用了临时表

#### 慢查询优化
- 慢查询出现的原因
    1. 没有命中索引
    2. load了不需要的数据列
    3. 数据量太大

#### MySQL的复制原理以及流程
> 主从复制：将主数据库中的DDL和DML操作通过二进制日志(BINLOG)传输到从数据库上,然后将这些日志重新执行(重做)；从而使得从数据库的数据与主数据库保持一致.
- 主从复制的作用
    * 主数据库出现问题,可以切换到从数据库.
    * 可以进行数据库层面的读写分离.
    * 可以在从数据库上进行日常备份.
- MySQL主从复制解决的问题
    1. 数据分布：随意开始或停止复制,并在不同地理位置分布数据备份
    2. 负载均衡：降低单个服务器的压力
    3. 高可用和故障切换：帮助应用程序避免单点失败
    4. 升级测试：可以用更高版本的MySQL作为从库
- MySQL主从复制工作原理
    1. 在主库上把数据更高记录到二进制日志, binlog线程——记录下所有改变了数据库数据的语句,放进master上的binlog中
    2. 从库将主库的日志复制到自己的中继日志, io线程——在使用start slave 之后,负责从master上拉取 binlog 内容,放进自己的relay log中
    3. 从库读取中继日志的事件,将其重放到从库数据中, sql执行线程——执行relay log中的语句


