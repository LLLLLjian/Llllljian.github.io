---
title: Interview_总结 (131)
date: 2020-09-16
tags: Interview
toc: true
---

### 面试题
    别看了 这就是你的题

<!-- more -->

#### Apache和Nginx的区别
- Nginx
    * 轻量级,采用 C 进行编写,同样的 web 服务,会占用更少的内存及资源
    * 抗并发,nginx 以 epoll and kqueue 作为开发模型,处理请求是异步非阻塞的,负载能力比 apache 高很多,而 apache 则是阻塞型的
    * nginx 能保持低资源低消耗高性能 ,而 apache 在 PHP 处理慢或者前端压力很大的情况下,很容易出现进程数飙升,从而拒绝服务的现象.
    * nginx 处理静态文件好,静态处理性能比 apache 高三倍以上
    * nginx 的设计高度模块化,编写模块相对简单
    * nginx 配置简洁,正则配置让很多事情变得简单,而且改完配置能使用 -t 测试配置有没有问题,apache 配置复杂
    * nginx 作为负载均衡服务器,支持 7 层负载均衡
    * nginx 本身就是一个反向代理服务器,而且可以作为非常优秀的邮件代理服务器
    * 启动特别容易, 并且几乎可以做到 7*24 不间断运行,即使运行数个月也不需要重新启动,还能够不间断服务的情况下进行软件版本的升级
    * 社区活跃,各种高性能模块出品迅速
- Apache
    * apache 的 rewrite 比 nginx 强大,在 rewrite 频繁的情况下,用 apache
    * apache 发展到现在,模块超多,基本想到的都可以找到
    * apache 更为成熟,少 bug ,nginx 的 bug 相对较多
    * apache 超稳定
    * apache 对 PHP 支持比较简单,nginx 需要配合其他后端用
    * apache 在处理动态请求有优势,nginx 在这方面是鸡肋,一般动态请求要 apache 去做,nginx 适合静态和反向.
    * apache 仍然是目前的主流,拥有丰富的特性,成熟的技术和开发社区
- 总结
    * 两者最核心的区别在于 apache 是同步多进程模型,一个连接对应一个进程,而 nginx 是异步的,多个连接(万级别)可以对应一个进程
    * 需要性能的 web 服务,用 nginx .如果不需要性能只求稳定,更考虑 apache

#### nginx的异步非阻塞是怎么实现的？或者说I/O多路复用了解吗
- 同步与异步的理解
    * 同步与异步的重点在消息通知的方式上, 也就是调用结果通知的方式.
    * 同步: 当一个同步调用发出去后, 调用者要一直等待调用结果的通知后, 才能进行后续的执行.
    * 异步: 当一个异步调用发出去后, 调用者不能立即得到调用结果的返回.
    * 异步调用, 要想获得结果, 一般有两种方式: 
        1. 主动轮询异步调用的结果;
        2. 被调用方通过callback来通知调用方调用结果
- 生活实例
    * 同步取快递: 小明收到快递将送达的短信, 在楼下一直等到快递送达.
    * 异步取快递: 小明收到快递将送达的短信, 快递到楼下后, 小明再下楼去取.
    * 异步取快递, 小明知道快递到达楼下有两种方式: 1、不停的电话问快递小哥到了没有, 即主动轮询；2、快递小哥到楼下后, 打电话通知小明, 然后小明下楼取快递, 即回调通知.
- 阻塞与非阻塞的理解
    * 阻塞与非阻塞的重点在于进/线程等待消息时候的行为, 也就是在等待消息的时候, 当前进/线程是挂起状态, 还是非挂起状态.
    * 阻塞阻塞调用在发出去后, 在消息返回之前, 当前进/线程会被挂起, 直到有消息返回, 当前进/线程才会被激活
    * 非阻塞非阻塞调用在发出去后, 不会阻塞当前进/线程, 而会立即返回.
- 生活实例
    * 阻塞取快递: 小明收到快递即将送达的信息后, 什么事都不做, 一直专门等快递.
    * 非阻塞取快递: 小明收到快递即将送达的信息后, 等快递的时候, 还一边敲代码、一边刷微信.
> 同步与异步, 重点在于消息通知的方式；阻塞与非阻塞, 重点在于等消息时候的行为
- 组合方式
    1. 同步阻塞: 小明收到信息后, 啥都不干, 等快递
    2. 同步非阻塞: 小明收到信息后, 边刷微博, 边等着取快递
    3. 异步阻塞: 小明收到信息后, 啥都不干, 一直等着快递员通知他取快递
    4. 异步非阻塞: 小明收到信息后, 边刷着微博, 边等快递员通知他取快递
- I/O多路复用
    1. select
        * 单个进程所打开的FD是有限制的,通过FD_SETSIZE设置,默认1024
        * 每次调用select,都需要把fd集合从用户态拷贝到内核态,这个开销在fd很多时会很大
        * 对socket扫描时是线性扫描,采用轮询的方法,效率较低(高并发时)
    2. poll
        * poll与select相比,只是没有fd的限制,其它基本一样
    3. epoll
        * 只能运行在linux系统下
- Nginx的异步非阻塞
    ```bash
        events {
            worker_connections  1024;
            use epoll;
        }
    ```
> 在一个Web服务中, 延迟最多的就是等待网络传输.nginx在启动后, 会有一个master进程和多个worker进程.master进程主要用来管理worker进程, 包含: 接收来自外界的信号, 向各worker进程发送信号, 监控worker进程的运行状态, 当worker进程退出后(异常情况下), 会自动重新启动新的worker进程.而基本的网络事件, 则是放在worker进程中来处理了.在一个请求需要等待的时候, worker可以空闲出来处理其他的请求, 少数几个worker进程就能够处理大量的并发.

#### 进程和线程以及它们的区别
- 进程是对运行时程序的封装, 是系统进行资源调度和分配的的基本单位, 实现了操作系统的并发；
- 线程是进程的子任务, 是CPU调度和分派的基本单位, 用于保证程序的 实时性, 实现进程内部的并发；
- 一个程序至少有一个进程, 一个进程至少有一个线程, 线程依赖于进程而存在；
- 进程在执行过程中拥有独立的内存单元, 而多个线程共享进程的内存.

#### 进程切换与线程切换的区别
> 进程切换与线程切换的一个最主要区别就在于进程切换涉及到虚拟地址空间的切换而线程切换则不会.因为每个进程都有自己的虚拟地址空间, 而线程是共享所在进程的虚拟地址空间的, 因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换

#### 什么是虚拟内存
> 虚拟内存是操作系统为每个进程提供的一种抽象, 每个进程都有属于自己的、私有的、地址连续的虚拟内存, 当然我们知道最终进程的数据及代码必然要放到物理内存上, 那么必须有某种机制能记住虚拟地址空间中的某个数据被放到了哪个物理内存地址上, 这就是所谓的地址空间映射, 也就是虚拟内存地址与物理内存地址的映射关系, 那么操作系统是如何记住这种映射关系的呢, 答案就是页表, 页表中记录了虚拟内存地址到物理内存地址的映射关系.有了页表就可以将虚拟地址转换为物理内存地址了, 这种机制就是虚拟内存.每个进程都有自己的虚拟地址空间, 进程内的所有线程共享进程的虚拟地址空间

#### 进程(线程)的同步和互斥
- 互斥
    * 是指某一资源同时只允许一个访问者对其进行访问, 具有唯一性和排它性.但互斥无法限制访问者对资源的访问顺序, 即访问是无序的.　　
- 同步
    * 是指在互斥的基础上(大多数情况), 通过其它机制实现访问者对资源的有序访问.在大多数情况下, 同步已经实现了互斥, 特别是所有写入资源的情况必定是互斥的.少数情况是指可以允许多个访问者同时访问资源

