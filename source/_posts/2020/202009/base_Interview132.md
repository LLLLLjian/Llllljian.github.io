---
title: Interview_总结 (132)
date: 2020-09-18
tags: Interview
toc: true
---

### 面试题
    别看了 这就是你的题

<!-- more -->

#### 让你实现一个PHP框架, 保留最核心的功能, 你会留存哪些部分
1. 统一入口
2. 定义常量
3. 引入函数库
4. 自动加载类
5. 启动框架
6. 路由解析
7. 加载控制器
8. 返回结果

#### 一个请求到服务端的过程
- 浏览器 → url → dns → ip → port → TCP → Nginx → server name → php-fpm/fast cgi → php → php-fpm/fast cgi → Nginx → TCP → 浏览器
* 用户输入url,浏览器内部代码将url进行拆分解析
    * scheme://login:password@adress:post/path/to/resource/?query_string#fragment
    * ``scheme`` 协议名称
    * ``://`` 层级URl的标记符号(固定不变, 语法规定)
    * ``login:password`` 访问资源所需要的凭证信息(可选)
    * ``@adress:`` 从哪个服务器获取数据
    * ``port`` 需要连接的端口号(默认80, 可选)
    * ``/path/to/resource`` 指向资源的层级文件路径
    * ``query_string`` 查询字符串
    * ``fragment`` 片段ID
* 浏览器首先去找本地的hosts文件,检查在该文件中是否有相应的域名、IP对应关系,如果有,则向其IP地址发送请求,如果没有就会将domain(域)发送给 dns(域名服务器)进行解析(解析如下图),将域名解析成对应的服务器IP地址,发回给浏览器
    * 浏览器客户端向本地DNS服务器发送一个含有域名www.cnblogs.com的DNS查询报文.
    * 本地DNS服务器把查询报文转发到根DNS服务器,根DNS服务器注意到其com后缀,于是向本地DNS服务器返回comDNS服务器的IP地址.
    * 本地DNS服务器再次向comDNS服务器发送查询请求,comDNS服务器注意到其www.cnblogs.com后缀并用负责该域名的权威DNS服务器的IP地址作为回应.
    * 本地DNS服务器将含有www.cnblogs.com的IP地址的响应报文发送给客户端
    * ![DNS服务器解析说明](/img/20190917_1.jpg)
* 浏览器费了一顿周折终于拿到了服务器IP,接下来就是网络通信(过程如下图),分层由高到低分别为：应用层、传输层、网络层、数据链路层.发送端从应用层往下走,接收端从数据链路层往上走
    * ![网络通信解析说明](/img/20190917_2.png)
    * ***应用层客户端发送HTTP请求*** : HTTP请求包括请求报头和请求主体两个部分,其中请求报头包含了至关重要的信息,包括请求的方法(GET / POST)、目标url、遵循的协议(http / https / ftp…),返回的信息是否需要缓存,以及客户端是否发送cookie等
    * ***传输层TCP传输报文*** : 位于传输层的TCP协议为传输报文提供可靠的字节流服务.它为了方便传输,将大块的数据分割成以报文段为单位的数据包进行管理,并为它们编号,方便服务器接收时能准确地还原报文信息.TCP协议通过“三次握手”等方法保证传输的安全可靠.客户端发送一个带有SYN标志的数据包给服务端,在一定的延迟时间内等待接收的回复.服务端收到后,回传一个带有SYN/ACK标志的数据包以示传达确认信息,最后客户端再回传一个带ACK标志的数据包,代表握手结束,连接成功
    * ***网络层IP协议查询MAC地址*** : IP协议的作用是把TCP分割好的各种数据包传送给接收方.而要保证确实能传到接收方还需要接收方的MAC地址,也就是物理地址.IP地址和MAC地址是一一对应的关系,一个网络设备的IP地址可以更换,但是MAC地址一般是固定不变的.ARP协议可以将IP地址解析成对应的MAC地址.当通信的双方不在同一个局域网时,需要多次中转才能到达最终的目标,在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标
    * 服务器接收数据 : 接收端的服务器在链路层接收到数据包,再层层向上直到应用层.这过程中包括在运输层通过TCP协议将分段的数据包重新组成原来的HTTP请求报文
    * 服务器响应请求 : 服务接收到客户端发送的HTTP请求后,查找客户端请求的资源,并返回响应报文,响应报文中包括一个重要的信息——状态码
    * 服务器返回相应文件 : 服务器端收到请求后的由web服务器(准确说应该是http服务器)处理请求,诸如Apache、Ngnix、IIS等.web服务器解析用户请求,知道了需要调度哪些资源文件,再通过相应的这些资源文件处理用户请求和参数,并调用数据库信息,最后将结果通过web服务器返回给浏览器客户端
    * 关闭TCP连接 : 为了避免服务器与客户端双方的资源占用和损耗,当双方没有请求或响应传递时,任意一方都可以发起关闭请求.与创建TCP连接的3次握手类似,关闭TCP连接,需要4次握手.
* 页面的渲染阶段
    * 解析HTML生成DOM树.
    * 解析CSS生成CSSOM规则树.
    * 将DOM树与CSSOM规则树合并在一起生成渲染树.
    * 遍历渲染树开始布局,计算每个节点的位置大小信息.
    * 将渲染树每个节点绘制到屏幕

#### PHP运行方式
    web server(比如说nginx)只是内容的分发者.
    如果请求/index.html,那么web server会去文件系统中找到这个文件,发送给浏览器,这里分发的是静态数据.
    如果现在请求的是/index.php,根据配置文件,nginx知道这个不是静态文件,需要去找PHP解析器来处理,那么他会把这个请求简单处理后交给PHP解析器
    CGI就是规定要传哪些数据、以什么样的格式传递给后方处理这个请求的协议.仔细想想,你在PHP代码中使用的用户从哪里来的.
    当web server收到/index.php这个请求后,会启动对应的CGI程序,这里就是PHP的解析器.接下来PHP解析器会解析php.ini文件,初始化执行环境,然后处理请求,再以规定CGI规定的格式返回处理后的结果,退出进程.web server再把结果返回给浏览器.

    标准的CGI对每个请求都会执行这些步骤,所以处理每个时间的时间会比较长.这明显不合理嘛！那么Fastcgi是怎么做的呢？首先,Fastcgi会先启一个master,解析配置文件,初始化执行环境,然后再启动多个worker.当请求过来时,master会传递给一个worker,然后立即可以接受下一个请求.这样就避免了重复的劳动,效率自然是高.而且当worker不够用时,master可以根据配置预先启动几个worker等着；当然空闲worker太多时,也会停掉一些,这样就提高了性能,也节约了资源.这就是fastcgi的对进程的管理.

    大家都知道,PHP的解释器是php-cgi.php-cgi只是个CGI程序,他自己本身只能解析请求,返回结果,不会进程管理所以就出现了一些能够调度php-cgi进程的程序,PHP-FPM就是这种程序
- CGI
    * 通用网关接口
    * 是一个可伸缩地、高速地在HTTP server和动态脚本语言间通信的接口
    * 把网页和Web服务器中的执行程序连接起来,它把HTML接收的指令传递给服务器的执行程序,再把服务器执行程序的结果返还给HTML页
- FastCGI
    * 激活后一直运行,像是一个常驻的CGI
    * PHP的FastCGI进程管理器是PHP-FPM
- CLI
    * 命令行运行
- Web模块模式
    * Apache等Web服务器运行的模式
    * 以mod_php5模块的形式集成
    * 接收Apache传递过来的PHP文件请求,并处理这些请求,然后将处理后的结果返回给Apache
- ISAPI
    * 是微软提供的一套面向Internet服务的API接口.一个ISAPI的DLL,可以在被用户请求激活后长驻内存,等待用户的另一个请求,还可以在一个DLL里设置多个用户请求处理函数,此外,ISAPI的DLL应用程序和WWW服务器处于同一个进程中,效率要显著高于CGI




