---
title: Interview_总结 (134)
date: 2020-09-29
tags: Interview
toc: true
---

### 面试题
    别看了 这就是你的题

<!-- more -->

#### 如何扛住亿级流量之布隆过滤器

##### 什么是布隆过滤器
> 是一个二进制向量数据结构,当时专门解决数据查询问题.可以用来告诉你 某样东西一定不存在或者可能存在.相比于传统的 List、Set、Map 等数据结构,它更高效、占用空间更少,但是缺点是其返回的结果是概率性的,而不是确切的.

##### 布隆过滤器有什么用
- 说起布隆过滤器的作用可以大家可能首先想到的就是Redis缓存穿透,那我们先来说说什么是缓存穿透？
    * 大流量访问系统的时候, 常规的系统架构操作是, 先查缓存数据库redis是否存在目标信息, 存在的话直接返回,不存在的话去对应数据库中进行查询,查询到的结果的话返回前端并储存一份信息到redis缓存数据库中,不存在的话就直接返回.这种做法理论上来说是没问题的, 但是架不住有坏人一直用不存在的id来刷你的系统,这样的话就会导致一直无效地去数据库中查询不存在的数据,徒增数据库压力,这就是所谓的缓存穿透
    * 破解缓存穿透最笨的做法就是如果目标数据不存在的话,也要记录一份到redis中,这样下次就不会把查询流量打到数据库中,好一点的方法就是直接使用布隆过滤器了
- 布隆过滤器可以有效的降低缓存穿透

##### 布隆过滤器原理
> 布隆过滤器可以有效减少缓存穿透的情况.其主旨是采用一个很长的二进制数组,通过一系列的 Hash 函数来确定该数据是否存在.
- 模拟过程
    * 布隆过滤器的初始化开始过程
        ![布隆过滤器的初始化开始过程](/img/20200929_1.png)
    * 若干次 Hash 来确定其位置
        * 假设有 1000 个商品编号,从 1~1000.作为布隆过滤器,在初始化的时候,实际上就是对每一个商品编号进行若干次 Hash 来确定它们的位置.
        * 对编号1进行三次hash, 第1次hash定位到二进制第2位并将其数值从 0 改为 1; 第2次hash定位到二进制第5位并将其数值从 0 改为 1; 第3次hash定位到二进制第99位并将其数值从 0 改为 1; 
        * 对编号2进行三次hash, 分别定位到索引为1, 3, 98号位置上
        * ....
        * 对编号1000进行三次hash, 分别定位到索引为3, 6, 98号位置上
    * 布隆过滤器的初始化完毕过程
        ![布隆过滤器的初始化完毕过程](/img/20200929_2.png)
- 实践
    * 假设要查询编号858, 三次hash之后的位置分别为1, 5, 98, 对应的数值都是1, 所以它是存在的
    * 假设要查询编号9999, 三次hash之后的位置分别为3, 6, 100, 对应的数值有一个是0, 所以它不存在
- 结论
    * 如果布隆过滤器所有Hash的值都是1的话,则代表这个数据可能存在.但如果某一位的数值是0的话,它是一定不存在的.
- 误判情况
    * 假设要查询编号9998, 三次hash之后的位置分别为3, 6, 98, 对应的数值都是1, 所以它在布隆过滤器中是存在的, 但数据库中其实是不存在的, 这种小概率误判情况在可以接受的范围内, 因为他已经过滤掉了大部分垃圾数据

##### 减少布隆过滤器的误判
1. 增加二进制位数.在原始情况下我们设置索引位到达了 100,但是如果我们把它放大 1 万倍,到达了 100 万,是不是 Hash 以后的数据会变得更分散,出现重复的情况就会更小,这是第一种方式.
2. 增加 Hash 的次数.其实每一次 Hash 处理都是在增加数据的特征,特征越多,出现误判的概率就越小.

##### 延伸: 初始化后,对应商品被删怎么办
1. 定时异步重建布隆过滤器.比如说我们每过 4 个小时在额外的一台服务器上,异步去执行一个任务调度,来重新生成布隆过滤器,替换掉已有的布隆过滤器.
2. 计数布隆过滤器.在标准的布隆过滤器下,是无法得知当前某一位它是被哪些具体数据进行了引用,但是计数布隆过滤器它是在这一位上额外的附加的计数信息,表达出该位被几个数据进行了引用.





