---
title: Interview_总结 (137)
date: 2020-10-13
tags: Interview
toc: true
---

### 面试题
    别看了 这就是你的题
    框架相关(2)

<!-- more -->

#### 分布式事务

分布式事务解决的用户最本质诉求是什么？数据一致.

大中企业有一个共同的诉求是数据一致, 几乎覆盖到各个行业.

比如说零售行业, 库存与出货的数据需要保持一致, 出货量与库存数据不匹配, 显而易见会出问题, 拿到订单却没货了, 或者有货却下不了订单.

比如说金融行业, 转账数据搞错了, A扣款了, B没加上, 马上该用户投诉了；A没扣款, B却加上了, 产生资损.又比如从总账户中买了基金、股票后余额不对了, 等等, 都会导致严重问题.

以前多数企业的数据规模相对较小, 很多操作是单机完成, 数据库本地事务可以搞定, 所以数据一致问题不那么明显.随着互联网技术快速发展, 数据规模增大, 分布式系统越来越普及, 采用分布式数据库或者跨多个数据库的应用在中大规模企业普遍存在, 服务化也是广泛应用, 由于网络的不可靠和机器不可靠, 数据不一致问题很容易出现.

- 事务的基本特性
    * Atomicity(原子性): 是指事务是一个不可分割的整体, 所有操作要么全做, 要么全不做；只要事务中有一个操作出错, 回滚到事务开始前的状态, 那么之前已经执行的所有操作都是无效的, 都应该会滚到开始前的状态.
    * Consistency(一致性): 指事务执行前后, 数据从一个状态到另一个状态必须是一致的, 比如A向B转账(A、B的总金额就是一个一致性状态), 不可能出现A扣了钱,  B却没收到的情况.
    * Isolation(隔离性): 多个并发事务之间相互隔离, 不能相互干扰.这里的并发事务指的是两个事务操作了同一份数据的情况, 要求不能出现脏读、幻读的情况.常用手段就是通过数据库的相关锁机制来保证.
    * Durablity(持久性): 事务完成后, 对数据库的更改是永久保存的, 不能回滚.
- 分布式事务
    * 分布式事务是为了解决微服务架构(形式都是分布式系统)中不同节点之间的数据一致性的问题.这个一致性问题本质上解决的也是传统事务需要解决的问题, 即一个请求在多个微服务调用链中, 所有服务的数据处理要么全部成功, 要么全部回滚.当然分布式事务问题的形式可能与传统事务会有比较大的差异, 但是问题本质是一致的, 都是要求解决数据的一致性问题, 并且满足事务的基本特性(ACID).
- 分布式事务如何处理一致性问题
    * 业务无侵入方案
        * 两阶段提交(2PC, Two-phase Commit)
            * 阶段1: 请求阶段(commit-request phase, 或称表决阶段, voting phase). 协调者节点向所有参与者节点询问是否可以执行提交操作, 并开始等待各参与者节点的响应.参与者节点执行询问发起为止的所有事务操作, 并将Undo信息和Redo信息写入日志.各参与者节点响应协调者节点发起的询问.如果参与者节点的事务操作实际执行成功, 则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败, 则它返回一个”中止”消息. 有时候, 第一阶段也被称作投票阶段, 即各参与者投票是否要继续接下来的提交操作..
            * 阶段2: 提交阶段(commit phase). 在该阶段, 协调者将基于第一个阶段的投票结果进行决策: 提交或取消.当且仅当所有的参与者同意提交事务协调者才通知所有的参与者提交事务, 否则协调者将通知所有的参与者取消事务.参与者在接收到协调者发来的消息后将执行响应的操作.
            * 成功
                * 当协调者节点从所有参与者节点获得的相应消息都为”同意”时
                * 协调者节点向所有参与者节点发出”正式提交”的请求.
                * 参与者节点正式完成操作, 并释放在整个事务期间内占用的资源.
                * 参与者节点向协调者节点发送”完成”消息.
                * 协调者节点收到所有参与者节点反馈的”完成”消息后, 完成事务.
            * 失败
                * 如果任一参与者节点在第一阶段返回的响应消息为”终止”, 或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时
                * 协调者节点向所有参与者节点发出”回滚操作”的请求.
                * 参与者节点利用之前写入的Undo信息执行回滚, 并释放在整个事务期间内占用的资源.
                * 参与者节点向协调者节点发送”回滚完成”消息.
                * 协调者节点收到所有参与者节点反馈的”回滚完成”消息后, 取消事务.
            * 问题
                * **同步阻塞问题**: 它的执行过程中间, 节点都处于阻塞状态.即节点之间在等待对方的相应消息时, 它将什么也做不了.特别是, 当一个节点在已经占有了某项资源的情况下, 为了等待其他节点的响应消息而陷入阻塞状态时, 当第三个节点尝试访问该节点占有的资源时, 这个节点也将连带陷入阻塞状态
                * **单点故障**: 由于协调者的重要性, 一旦协调者发生故障.参与者会一直阻塞下去.尤其在第二阶段, 协调者发生故障, 那么所有的参与者还都处于锁定事务资源的状态中, 而无法继续完成事务操作.(如果是协调者挂掉, 可以重新选举一个协调者, 但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题)
                * **数据不一致**: 如果出现协调者和参与者都挂了的情况, 有可能导致数据不一致.
        * 三阶段提交(3PC)
            * 2PC的升级版, 相较于2PC升级的地方在于: 1. 引入超时机制.同时在协调者和参与者中都引入超时机制.2. 在第一阶段和第二阶段中插入一个准备阶段.保证了在最后提交阶段之前各参与节点的状态是一致的.
    * 业务侵入方案
        * TCC(Try-Confirm-Cancel)补偿模式
            * 核心思想是: 针对每个操作, 都要注册一个与其对应的确认和补偿(撤销)操作
            * Try: 尝试执行业务
                * 完成所有业务检查(一致性)
                * 预留必须业务资源(准隔离性)
            * Confirm: 确认执行业务
                * 真正执行业务
                * 不做任何业务检查
                * 只使用try阶段预留的业务资源
                * Confirm操作满足幂等性
            * Cancel: 取消执行业务
                * 释放Try阶段预留的业务资源
                * Cancel操作满足幂等性
        * 基于消息的最终一致性
            * 消息一致性方案是通过消息中间件保证上、下游应用数据操作的一致性.基本思路是将本地操作和发送消息放在一个事务中, 保证本地操作和消息发送要么两者都成功或者都失败.下游应用向消息系统订阅该消息, 收到消息后执行相应操作.







