---
title: Interview_总结 (139)
date: 2020-10-15
tags: Interview
toc: true
---

### 面试题
    别看了 这就是你的题
    框架相关(5)

<!-- more -->

#### 分布式ID生成器
- 基本要求
    * 全局唯一, 区别于单点系统的唯一, 全局是要求分布式系统内唯一.
    * 有序性, 通常都需要保证生成的ID是有序递增的.例如, 在数据库存储等场景中, 有序ID便于确定数据位置, 往往更加高效.

##### 分布式系统唯一ID生成方案汇总
- 数据库自增长序列或字段
    * 优点
        * 简单, 代码方便, 性能可以接受.
        * 数字ID天然排序, 对分页或者需要排序的结果很有帮助.
    * 缺点
        * 不同数据库语法和实现不同, 数据库迁移的时候或多数据库版本支持的时候需要处理.
        * 在单个数据库或读写分离或一主多从的情况下, 只有一个主库可以生成.有单点故障的风险.
        * 在性能达不到要求的情况下, 比较难于扩展.
        * 如果遇见多个系统需要合并或者涉及到数据迁移会相当痛苦.
        * 分表分库的时候会有麻烦
    * 优化方案
        * 针对主库单点, 如果有多个Master库, 则每个Master库设置的起始数字不一样, 步长一样, 可以是Master的个数.比如: Master1 生成的是 1, 4, 7, 10, Master2生成的是2,5,8,11 Master3生成的是 3,6,9,12.这样就可以有效生成集群中的唯一ID, 也可以大大降低ID生成数据库操作的负载.
- UUID
    * 常见的方式.可以利用数据库也可以利用程序生成, 一般来说全球唯一.
    * 优点
        * 简单, 代码方便
        * 生成ID性能非常好, 基本不会有性能问题
        * 全球唯一, 在遇见数据迁移, 系统数据合并, 或者数据库变更等情况下, 可以从容应对
    * 缺点
        * 没有排序, 无法保证趋势递增
        * UUID往往是使用字符串存储, 查询的效率比较低
        * 存储空间比较大, 如果是海量数据库, 就需要考虑存储量的问题
        * 传输数据量大
        * 不可读
- Redis生成ID
    * 依赖于Redis是单线程的, 所以也可以用生成全局唯一的ID.可以用Redis的原子操作 INCR和INCRBY来实现. 可以使用Redis集群来获取更高的吞吐量.假如一个集群中有5台Redis.可以初始化每台Redis的值分别是1,2,3,4,5, 然后步长都是5.各个Redis生成的ID为: A: 1,6,11,16,21; B: 2,7,12,17,22; C: 3,8,13,18,23; D: 4,9,14,19,24; E: 5,10,15,20,25;
    * 优点
        * 不依赖于数据库, 灵活方便, 且性能优于数据库
        * 数字ID天然排序, 对分页或者需要排序的结果很有帮助
    * 缺点
        * 如果系统中没有Redis, 还需要引入新的组件, 增加系统复杂度
        * 需要编码和配置的工作量比较大
- Twitter的snowflake算法
    * snowflake是Twitter开源的分布式ID生成算法, 结果是一个long型的ID.其核心思想是: 使用41bit作为毫秒数, 通常使用System.currentTimeMillis()
    * 优点
        * 不依赖于数据库, 灵活方便, 且性能优于数据库
        * ID按照时间在单机上是递增的
    * 缺点
        * 在单机上是递增的, 但是由于涉及到分布式环境, 每台机器上的时钟不可能完全同步, 也许有时候也会出现不是全局递增的情况.
- 利用zookeeper生成唯一ID
    * zookeeper主要通过其znode数据版本来生成序列号, 可以生成32位和64位的数据版本号, 客户端可以使用这个版本号来作为唯一的序列号.很少会使用zookeeper来生成唯一ID.主要是由于需要依赖zookeeper, 并且是多步调用API, 如果在竞争较大的情况下, 需要考虑使用分布式锁.因此, 性能在高并发的分布式环境下, 也不甚理想.
- MongoDB的ObjectId
    * MongoDB的主键
    * 由于时间戳在前, 这意味着ObjectId 大致会按照插入的顺序排列







