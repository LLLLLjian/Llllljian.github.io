---
title: MySQL_基础 (59)
date: 2021-04-21
tags: MySQL
toc: true
---

### 更好的理解MySQL
    四问自己
    1.索引的本质是什么
    2.MySQL中索引使用哪些数据结构
    3.索引使用B+Tree的数据结构, 如何存放在磁盘中
    4.如何通过离散性, 最左匹配, 回表操等原则分析优秀的索引

<!-- more -->

#### 故事背景
> 人要活到老学到老呀, 要不然这些都忘了

#### 问题
- Q
    * 索引的本质是什么
- A
    * 帮助mysql高效获取数据的数据结构
    * 在关系型数据库中, 索引存储在硬盘上

#### 问题1
- Q
    * name like "llllljian%" 会用到索引吗
- A
    * 不一定, 要根据表的情况来定, 可能会用到,  也有可能用不到
- eg
    ```sql
        mysql> SHOW CREATE TABLE test_name;
        +-----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
        | Table     | Create Table                                                                                                                                                                                                                     |
        +-----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
        | test_name | CREATE TABLE `test_name` (
        `id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(30) NOT NULL,
        `age` tinyint(2) NOT NULL,
        PRIMARY KEY (`id`),
        KEY `name` (`name`)
        ) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8 |
        +-----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
        1 row in set (0.00 sec)

        mysql> SHOW CREATE TABLE test_name1;
        +------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
        | Table      | Create Table                                                                                                                                                                                                                      |
        +------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
        | test_name1 | CREATE TABLE `test_name1` (
        `id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(30) NOT NULL,
        `age` tinyint(2) NOT NULL,
        PRIMARY KEY (`id`),
        KEY `name` (`name`)
        ) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 |
        +------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
        1 row in set (0.00 sec)

        mysql> select * from test_name;
        +----+--------------+-----+
        | id | name         | age |
        +----+--------------+-----+
        |  1 | a            |   0 |
        |  2 | b            |   0 |
        |  3 | c            |   0 |
        |  4 | d            |   0 |
        |  5 | llllljian123 |   0 |
        |  6 | llllljian456 |   0 |
        +----+--------------+-----+
        6 rows in set (0.00 sec)

        mysql> select * from test_name1;
        +----+------------+-----+
        | id | name       | age |
        +----+------------+-----+
        |  1 | llllljian  |   0 |
        |  2 | llllljian1 |   0 |
        |  3 | llllljian2 |   0 |
        |  4 | llllljian3 |   0 |
        |  5 | llllljian4 |   0 |
        +----+------------+-----+
        5 rows in set (0.00 sec)

        mysql> EXPLAIN SELECT * FROM test_name WHERE name LIKE "llllljian%";
        +----+-------------+-----------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+
        | id | select_type | table     | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra                 |
        +----+-------------+-----------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+
        |  1 | SIMPLE      | test_name | NULL       | range | name          | name | 92      | NULL |    2 |   100.00 | Using index condition |
        +----+-------------+-----------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+
        1 row in set, 1 warning (0.01 sec)

        mysql> EXPLAIN SELECT * FROM test_name1 WHERE name LIKE "llllljian%";
        +----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+
        | id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
        +----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+
        |  1 | SIMPLE      | test_name1 | NULL       | ALL  | name          | NULL | NULL    | NULL |    5 |   100.00 | Using where |
        +----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+
        1 row in set, 1 warning (0.00 sec)
    ```
- 分析
    * test_name表用到了索引, 最左前缀, 从explain分析中可以看出
    * tes_name1表没有用到索引, 因为数据大部分是一致的, 索引失效, 直接全表扫描了

#### 问题2
- Q
    * 为什么mysql默认要使用b+ tree,而不是b tree、avl
- A
    * 哈希虽然查找单个很快, 但是范围查找很慢, 而且数据量过多的时候可能会出现哈希冲突
    * 普通的二叉搜索树会因为节点不当导致树变成链表形式
    * avl(二叉平衡搜索树)会随着数据多少而变成一个非常高的树, 查询不稳定
    * b树虽然矮胖, 但是因为所有节点上都有数据块导致每一个page上存放的节点有限, 而且不利于范围查找
    * b+树是b树的升级版, 而且b+树只在叶子节点上才存放数据, 所以每一个page上存放的数据比b树多, 叶子节点之前是有序的链表形式, 有利于排序和返回查找

#### 问题3
- Q
    * 为什么不建议写SELECT * FROM 进行查询
- A
    * 覆盖索引失效, 很容易回表, 用什么查什么就可以了

#### 问题4
- Q
    * 最左匹配原则是怎么理解的
- A
    * 最常查询和离散性最大的放在左边, 联合索引会转化为多个索引
- eg
    * 已有联合索引 idx_name_ph(name, phoneNum, age), 下面的查询语句会不会用到索引
    * select * from user where name = "peter" and phoneNum > 1333333333 and age = 18;
    * 会, 只能用到name和phoneNum, 大于小于之后的就用不到了
    * select * from user where name = "peter" and age = 18;
    * 会, 只能用到name, age不是下一个顺序, 所以用不到
    * select * from user where phoneNum = 133333333 and age = 18;
    * 不会, 因为联合索引的第一个不是phoneNum
    * select * from user where phoneNum = 133333333 and name = "peter";
    * 会, mysql自己内部的优化器会调整where条件中的顺序

