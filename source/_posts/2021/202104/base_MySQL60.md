---
title: MySQL_基础 (60)
date: 2021-04-22
tags: MySQL
toc: true
---

### 更好的理解MySQL
    四问自己
    1.索引的本质是什么
    2.MySQL中索引使用哪些数据结构
    3.索引使用B+Tree的数据结构, 如何存放在磁盘中
    4.如何通过离散性, 最左匹配, 回表操等原则分析优秀的索引

<!-- more -->

#### 故事背景
> 人要活到老学到老呀, 要不然这些都忘了, 接上一节

#### 问题5
- Q
    * 为什么建议主键自增, 和b+ tree有什么关联
- A
    * 使用自增id可以避免页分裂. mysql的InnoDB引擎底层数据结构是 B+ 树, 所谓的索引其实就是一颗 B+ 树, 一个表有多少个索引就会有多少颗 B+ 树, mysql 中的数据都是按顺序保存在 B+ 树上的(所以说索引本身是有序的). 然后 mysql 在底层又是以数据页为单位来存储数据的, 一个数据页大小默认为 16k, 当然你也可以自定义大小, 也就是说如果一个数据页存满了, mysql 就会去申请一个新的数据页来存储数据.如果主键为自增 id 的话, mysql 在写满一个数据页的时候, 直接申请另一个新数据页接着写就可以了.如果主键是非自增 id, 为了确保索引有序, mysql 就需要将每次插入的数据都放到合适的位置上.当往一个快满或已满的数据页中插入数据时, 新插入的数据会将数据页写满, mysql 就需要申请新的数据页, 并且把上个数据页中的部分数据挪到新的数据页上.这就造成了页分裂, 这个大量移动数据的过程是会严重影响插入效率的.其实对主键 id 还有一个小小的要求, 在满足业务需求的情况下, 尽量使用占空间更小的主键 id, 因为普通索引的叶子节点上保存的是主键 id 的值, 如果主键 id 占空间较大的话, 那将会成倍增加 mysql 空间占用大小
    * 对于InnoDB这种聚集主键类型的引擎来说, 数据会按照主键进行排序, 由于UUID的无序性, InnoDB会产生巨大的IO压力, 而且由于索引和数据存储在一起, 字符串做主键会造成存储空间增大一倍.在存储和检索的时候, innodb会对主键进行物理排序, 这对auto_increment_int是个好消息, 因为后一次插入的主键位置总是在最后.但是对uuid来说, 这却是个坏消息, 因为uuid是杂乱无章的, 每次插入的主键位置是不确定的, 可能在开头, 也可能在中间, 在进行主键物理排序的时候, 势必会造成大量的 IO操作影响效率, 在数据量不停增长的时候, 特别是数据量上了千万记录的时候, 读写性能下降的非常厉害.

#### 问题6
- Q
    * 你是如何理解三星索引的
- A
    * 第一颗星
        * 定义：如果与一个查询相关的索引行是相邻的, 或者至少相距足够靠近的话, 那这个索引就可以标记上一颗星
        * 收益：它最小化了必须扫描的索引片的宽度
        * 实现：把 WHERE 后的等值条件列作为索引最开头的列, 如此, 必须扫描的索引片宽度就会缩至最短
    * 第二颗星
        * 定义：如果索引行的顺序与查询语句的需求一致, 则索引可以标记上第二颗星
        * 收益：它排除了排序操作
        * 实现：将 ORDER BY 列加入到索引中, 保持列的顺序
    * 第三颗星
        * 定义：如果索引行中包含查询语句中的所有列, 那么这个索引就可以标记上第三颗星
        * 收益：这避免了访问表的操作(避免了回表操作), 只访问索引就可以满足了
        * 实现：将查询语句中剩余的列都加入到索引中

#### 问题7
- Q
    * and和or在使用索引时有什么区别
- A
    * and前后有没有索引互不影响
    * or前后必须都有索引, 要不然就都失效了

