---
title: MySQL_基础 (64)
date: 2021-04-28
tags: MySQL
toc: true
---

### 更好的理解MySQL
    MySQL实战45讲

<!-- more -->

#### 故事背景
> 今天在b站学习mysql的时候 突然觉得b站的学习氛围不是很好了呀, 都是随便讲的, 都是想吃互联网第二波饭的人, 两个小时的视频里有一个多小时是在卖课,  在给人洗脑, 然后我就找呀找, 最后找到了【MySQL实战45讲】, 看过的人都说好, 我也来看看吧, 学一学

#### 01基础架构: 一条SQL查询语句是如何执行的
SQL语句在MySQL各个功能模块中的执行过程
![mysql逻辑架构图](/img/20210428_1.png)
大体来说, MySQL 可以分为**Server层**和**存储引擎层**两部分
Server层包括: 连接器、查询缓存、分析器、优化器、执行器等
存储引擎负责数据的存储和提取.常用的存储引擎InnoDB、MyISAM
查询缓存的失效非常频繁, 只要有对一个表的更新, 这个表上所有的查询缓存都会被清空.建议大多数情况下不要使用查询缓存.MySQL8.0版本把查询缓存功能已去除

#### 02日志系统: 一条SQL查询语句是如何执行的
与查询流程不一样的是, 更新流程还涉及两个重要的日志模块: redo log(重做日志)和binlog(归档日志)
1. 日志模块: redolog
    ![redolog](/img/20210428_2.png)
    * 在做更新操作时, 如果每一次更新操作都立即写进磁盘, 那么整个过程IO成本、查找成本都很高.redo log就是为了解决这一问题, MySQL通过WAL(Write-Ahead Logging)技术, 先把更新操作写入redo log日志, 并更新内存, 这时更新操作就完成了, 同时InnoDB引擎会在适当的时候(系统比较空闲时), 将一批操作更新到磁盘里面.如果redo log写满时, 就不能再执行新的更新, 得停下来先擦掉redo log一些记录, 写入磁盘, 再执行新的更新.
    * 有了redo log, InnoDB就可以保证即使数据库发生异常重启, 之前提交的记录都不会丢失, 这个能力称为crash-safe
2. 日志模块: binlog
    * redo log和binlog不同点: redo log 是 InnoDB 引擎特有的；binlog是MySQL的Server层实现的, 所有引擎都可以使用, redo log是物理日志, 记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志, 记录的是这个语句的原始逻辑, 比如“给ID=2这一行的c字段加1”.binlog两种模式: statement格式记录SQL语句, row格式记录行的内容, 两条(更新前和更新后)
    * redo log 是循环写的, 空间固定会用完；binlog是可以追加写入的.“追加写”是指binlog文件写到一定大小后会切换到下一个, 并不会覆盖以前的日志
    * update语句执行流程: 
    ![redolog](/img/20210428_3.png)
    * 将redo log的写入拆成了两个步骤: prepare 和 commit, 这就是“两阶段提交”.“两阶段提交”的目的是为了让两份日志之间的逻辑一致.保证一致性
    * 数据恢复过程
        * 首先, 找到最近的一次全量备份, 从这个备份恢复到临时库
        * 然后, 从备份的时间点开始, 将备份的binlog依次取出来, 重放到中午误删表之前的那个时刻
        * 最后把表数据从临时库取出来, 按需要恢复到线上库去



