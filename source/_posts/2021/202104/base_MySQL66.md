---
title: MySQL_基础 (66)
date: 2021-04-30
tags: MySQL
toc: true
---

### 更好的理解MySQL
    MySQL实战45讲

<!-- more -->

#### 故事背景
> 今天在b站学习mysql的时候 突然觉得b站的学习氛围不是很好了呀, 都是随便讲的, 都是想吃互联网第二波饭的人, 两个小时的视频里有一个多小时是在卖课,  在给人洗脑, 然后我就找呀找, 最后找到了【MySQL实战45讲】, 看过的人都说好, 我也来看看吧, 学一学

#### 06全局锁和表锁 : 给表加个字段怎么有这么多阻碍？

数据库锁设计的初衷是处理并发问题.根据加锁的范围, MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类.

##### 全局锁

全局锁就是对整个数据库实例进行加锁.要想使数据库处于只读状态, 加全局读锁, 使用命令: Flush table with read lock(FTWRL).使用全局读锁后, 其他线程的数据更新语句、数据定义语句和更新类事物的提交语句都将被阻塞.

全局锁的典型使用场景是, 做全库逻辑备份.也就是把整库每个表都select出来存成文本.

MyISAM不支持可重复读的事物隔离级别, 因数据库备份时要使用FTWRL(只读全局锁)来进行备份, 期间只能进行读操作.因此建议使用InnoDB引擎.InnoDB使用mysqldump备份时, 建议使用参数--single-transaction

设置全库只读: Flush table with read lock(FTWRL)、   set global readonly=true.建议使用FTWRL, 原因是: 

- 有些系统中readonly值会用来做逻辑判断, 比如判断是主库还是从库.因此, 修改global变量的方式影响面更大, 不建议使用.
- 异常处理机制有差异.执行FTWRL命令后, 如果由于客户端发生异常断开, 那么MySQL会自动释放这个全局锁, 整个库回到正常更新状态.而设置readonly后, 如果客户端发生异常, MySQL会一直保持readonly状态, 数据库长时间处于不可写状态, 风险较高.

##### 表级锁

表锁一般是引擎不支持行锁是才被用到.

MySQL表级锁有两种: 表锁、元数据锁(meta data lock,  MDL)

表锁语法: lock tables ... read/write.  unlock tables 释放锁.

MDL: 不需要显示使用, 在访问一个表时会被自动加上.MDL的作用是, 保证读写的正确性.当对一个表做增删改查、结构变更操作的时候, 加MDL锁.

- 读锁之间不互斥, 多个线程可以同时对一张表增删改查
- 读写锁之间、写锁之间是互斥的, 用来保证变更表结构操作的安全性.因此, 两个线程要同时给一个表加字段, 其中一个要等另一个执行完才能执行.


##### 如何安全的给小表加字段: 

如果一个表有频繁的查询语句, 而且客户端有重试机制, 这时改变表结构可能会导致库的线程爆满, 从而整个库挂掉.当有多个查询在执行时, 语句结束后并不会马上释放MDL读锁, 而是等到整个事物提交后释放, 这时更改表结构会被阻塞, 它被阻塞后, 之后的所有操作都会被阻塞, 整个表就不可读写了.

如何安全加字段: 

- 解决长事物.如果要做DDL变更的表有长事物在执行, 要考虑暂停DDL, 或者kill掉这个长事物.如果这个表是热点表, 有频繁的请求, 那么kill未必管用, 因为新的请求马上就来了.可以通过在alter table语句里面设定等待时间, 如果等待时间内能拿到MDL写锁就执行, 拿不到就放弃, 不用阻塞后面的业务语句, 之后再重试这个过程.

MariaDB 已经合并了AliSQL的这个功能.


