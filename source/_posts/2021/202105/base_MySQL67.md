---
title: MySQL_基础 (67)
date: 2021-05-06
tags: MySQL
toc: true
---

### 更好的理解MySQL
    MySQL实战45讲

<!-- more -->

#### 故事背景
> 今天在b站学习mysql的时候 突然觉得b站的学习氛围不是很好了呀, 都是随便讲的, 都是想吃互联网第二波饭的人, 两个小时的视频里有一个多小时是在卖课,  在给人洗脑, 然后我就找呀找, 最后找到了【MySQL实战45讲】, 看过的人都说好, 我也来看看吧, 学一学

#### 07行锁功过：怎么减少行锁对性能的影响？

行锁是针对数据库表中行记录的锁.存储引擎InnoDB支持行锁, MyISAM不支持行锁.

**两阶段锁协议**：在InnoDB事物中, 行锁是在需要的时候才加上的, 但并不是不需要了就立刻释放, 而是要等到事务结束时才释放.

如果你的事务中需要锁多个行, 要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放.原因是这个锁的时间最少, 减少了事务之间的锁等待, 提升了并发度.


##### 死锁和死锁检测

当并发系统中不同线程出现循环资源依赖, 涉及的线程都在等待别的线程释放资源时, 就会导致这几个线程都进入无限等待的状态, 称为死锁.

应对死锁有两种策略：

- 一种策略是, 直接进入等待, 直到超时.超时时间通过参数innodb_lock_wait_timeout来设置.默认为50s
- 另一种策略是, 发起死锁检测, 发现死锁后, 主动回滚死锁链条中的某一个事务, 让其他事物得以继续执行.开启这个逻辑, 通过设置参数innodb_deadlock_detect 为on来实现.默认为on.


如果死锁检测过多, 就会消耗大量的CPU资源.比如1000个并发线程同时更新一行记录, 那么死锁检测就是100万量级.

如何解决：

- 如果能够保证这个业务不会出现死锁, 可以临时把死锁检测关掉.不推荐, 关掉死锁检测意味着可能出现大量的超时, 这是业务有损的.
- 另一种是控制并发度.客户端无法控制, 要在服务端控制.中间件实现或修改MySQL源码, 基本思路是对于相同行的更新, 在引入引擎之前排队.
- 把一行变为多行, 减少锁等待个数.这需要业务上的支持和设计

#### 08事务到底是隔离的还是不隔离的？

begin/start transaction 命令并不是事物的的起点, 在执行的它们之后的第一个操作InnoDB表的语句, 事物才真正启动.要想立即启动事物可以使用start transaction with consistent snapshot这个命令.

**视图：**

- 一个是view.它是一个用查询语句定义的虚拟表, 在调用的时候执行查询语句并生成结果
- 一个是InnoDB在实现MVCC时用到的一致性读视图, 即consistent read view.用于支持RC(Read Committed读提交)和RR(Repeatable Read可重复读)隔离级别的实现


在可重复读隔离级别下,事务在启动的时候就“拍了个快照”.注意,这个快照是基于整库的.
InnoDB 利用了“所有数据都有多个版本”的这个特性,实现了“秒级创建快照”的能力.

对于一个事务视图来说,除了自己的更新总是可见以外,有三种情况: 

1. 版本未提交,不可见
2. 版本已提交, 但是在创建视图数组之后提交的, 不可见
3. 在视图数组创建之前提交的, 可见

更新数据都是先读后写的,而这个读,只能读当前的值,称为“当前读”(current read).
除了 update 语句外,select 语句如果加锁,也是当前读.

可重复读的核心就是一致性读(consistent read);而事务更新数据的时候,只能用当前读.如果当前的记录的行锁被其他事务占用的话,就需要进入锁等待.

读提交的逻辑和可重复读的逻辑类似,它们最主要的区别是:

- 在可重复读隔离级别下,只需要在事务开始的时候创建一致性视图,之后事务里的其他查询都共用这个一致性视图；
- 在读提交隔离级别下,每一个语句执行前都会重新算出一个新的视图.

InnoDB的行数据有多个版本, 每个数据版本有自己的row trx_id, 每个事务或者语句有自己的一致性视图.普通查询语句是一致性读, 一致性读会根据row trx_id和一致性视图确定数据版本的可见性

- 对于可重复读, 查询只承认在事务启动前就已经完成提交的数据
- 对于读提交, 查询只承认在语句启动前就已经提交完成的数据
- 而当前读, 总是读取已经提交完成的最新版本






