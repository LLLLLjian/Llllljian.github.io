---
title: MySQL_基础 (70)
date: 2021-05-10
tags: MySQL
toc: true
---

### 更好的理解MySQL
    MySQL实战45讲

<!-- more -->

#### 故事背景
> 今天在b站学习mysql的时候 突然觉得b站的学习氛围不是很好了呀, 都是随便讲的, 都是想吃互联网第二波饭的人, 两个小时的视频里有一个多小时是在卖课,  在给人洗脑, 然后我就找呀找, 最后找到了【MySQL实战45讲】, 看过的人都说好, 我也来看看吧, 学一学

#### 12为什么我的MySQL会“抖”一下？

##### 你的 SQL 语句为什么变“慢”了

当内存数据页跟磁盘数据页内容不一致的时候, 我们称这个内存页为“脏页”.内存数据写入到磁盘后, 内存和磁盘上的数据数据页的内容一致, 称为“干净页”.不论是脏页还是干净页, 都在内存中.

![孔乙己赊账 更新和flush过程](/img/20210510_1.png)


因此不难想象, 平时执行很快的更新操作, 其实就是在写内存和日志, 而MySQL偶尔“抖”一下的那个瞬间, 可能就是在刷脏页.

**什么情况下回触发数据库的flush过程: **

1. 第一种情况是, InnoDB的redo log写满了.这时系统会停止所有更新操作, 把checkpoint往前推进, 为redo log留出空间继续写.checkpoint推进的这段范围上的脏页都flush到磁盘上后, redo log才可继续写.
2. 第二种情况是, 系统内存不足.当需要新的内存页, 而内存不够用的时候, 就要淘汰一些数据页, 空出内存给别的数据页使用.如果淘汰的是脏页, 就要先将脏页写到磁盘.
3. 第三种情况是, MySQL认为系统“空闲”的时候.
4. 第四种情况是, MySQL正常关闭的情况.这时, MySQL会把内存的脏页都flush到磁盘上.


**上述四种场景对性能的影响: **

1. 第三种是空闲时候写, 第四种是数据库关闭时候写, 通常不会关注性能问题.
2. 第一种是redo log写满了, 要flush脏页.这时系统不再接受更新了, 所有的更新都会堵住.
3. 第二种是内存不够了, 现将脏页写到磁盘, 数据页淘汰机制(最久不使用).InnoDB 用缓冲池(buffer pool)管理内存,缓冲池中的内存页有三种状态:
	1. 还没使用的
	2. 使用了是干净页
	3. 使用了是脏页
    如果淘汰的是脏页, 要先flush到磁盘后, 才能复用.

##### InnoDB 刷脏页的控制策略

首先告诉InnoDB所在主机的IO能力, 这样InnoDB才能知道需要全力刷脏页的时候, 可以刷多快.通过innodb_io_capacity这个参数设置, 该值建议设置成磁盘的IOPS(可以通过fio工具测试).

InnoDB怎么控制引擎按照“全力”的百分比来刷脏页？

刷盘速度要参考两个因素: 一个是脏页比例, 一个是redo log写盘速度.

![InnoDB刷脏页速度策略](/img/20210510_2.png)


无论是你的查询语句在需要内存的时候可能要求淘汰一个脏页,还是由于刷脏页的逻辑会占用 IO 资源并可能影响到了你的更新语句,都可能是造成你从业务端感知到 MySQL“抖”了一下的原因.要避免这种情况, 就要合理地设置innodb_io_capacity的值, 并且平时要多关注脏页的比例, 不要让它经常接近75%.

在刷脏页时, 如果跟它相邻的数据页也还是脏页的话, 也会被放到一起刷(该行为在机械硬盘时代很有意义, 但在SSD时IOPS往往就不是瓶颈了).innodb_flush_neighbors参数来控制这个行为.值为1时, 会有上述的“连坐”机制；值为0时, 表示不找邻居, 只刷自己.MySQL8.0, 该参数默认值为0.

#### 13为什么表数据删掉一半, 表文件大小不变？

主要内容: 数据库表的空间回收.为什么简单地删除表数据到不到表空间回收的效果, 如何正确回收空间？

InnoDB表包含两部分: 表结构定义和数据.MySQL8.0之前, 表结构是存在 .frm 为后缀的文件里, 8.0版本则允许把表结构定义放在系统数据表中了.

##### 参数 innodb_file_per_table

参数 innodb_file_per_table 设置为OFF时, 表的数据放在共享表空间, 也就是跟数据字典放在一起；当设置为ON表示, 每个InnoDB表数据存储在一个以.idb为后缀的文件中.从MySQL5.6.6开始, 默认为ON.

建议设置该值为ON.因为单独存储为一个文件更容易管理, 可以通过drop table命令直接删除这个文件.如果放在共享表空间中, 即使表删掉了, 空间也是不会回收的.

##### 数据删除流程

记录和数据页删除后, 会被标记为删除可复用.记录的复用只限于符合范围条件的数据, 当有新的记录插入时, 如果位置范围是在删除的记录上, 则复用.对于数据页则是可复用与任何位置.

如果相邻的两个数据页利用率都很小, 系统会把两个数据页上的数据合并到一个页上, 另外一个数据页就被标记为可复用.

如果用delete命令把整个表的数据删除, 那么所有的数据页都被标记为可复用.但磁盘上, 文件不会变小.

delete命令只是把记录的位置, 或者数据页标记为“可复用”, 但磁盘文件的大小是不会变的.这些可复用, 而没有被利用的空间, 看起来就像是“空洞”.

不仅删除数据会造成空洞, 插入数据, 更新索引上的值也会造成空洞.当一个在一个已满的数据页上插入数据, 就会申请一个新的页面保存数据, 页分裂完成后, 老的数据页尾就留下了空洞.更新索引值, 可以理解为删除一个旧的值, 再插入一个新值.

##### 如何去除空洞, 收缩表空间: 重建表

可以使用 alter table A engine=InnoDB命令来重建表.该命令的执行流程是: 新建一个与表A结构相同的表B, 然后按照主键ID递增的顺序, 把数据一行一行从表A读出插入表B.表B就没有像表A中的空洞了, 索引更加紧凑.完成后用表B替换表A.

![改锁表DDL](/img/20210510_3.png)

在MySQL5.5之前, 流程和上述描述差不多, 区别是临时表B不需要你自己创建, MySQL会自动完成上述操作.在上述往临时表插入数据过程中, 如果有新的数据要写入表A的话, 就会造成数据丢失.因此在整个DDL过程中, 表A不能有更新, 也就是DDL不是Online的.

MySQL5.6版本开始引入Online DDL, 对操作流程做了优化: 

1. 建立一个临时文件, 扫描表A主键的所有数据页
2. 用数据页中表A的记录生成B+树, 存储到临时文件中
3. 生成临时文件的过程中, 将所有对A的操作记录在一个日志文件(row log)中, 对应的是图中state2的状态
4. 临时文件生成后, 将日志文件中的操作应用到临时文件中, 得到一个逻辑数据上与表A相同的数据文件, 对应的就是图中state3的状态
5. 用临时文件替换表A的数据文件

![online DDL](/img/20210510_4.png)
