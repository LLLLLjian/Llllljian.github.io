---
title: MySQL_基础 (71)
date: 2021-05-11
tags: MySQL
toc: true
---

### 更好的理解MySQL
    MySQL实战45讲

<!-- more -->

#### 故事背景
> 今天在b站学习mysql的时候 突然觉得b站的学习氛围不是很好了呀, 都是随便讲的, 都是想吃互联网第二波饭的人, 两个小时的视频里有一个多小时是在卖课,  在给人洗脑, 然后我就找呀找, 最后找到了【MySQL实战45讲】, 看过的人都说好, 我也来看看吧, 学一学

#### 14count(*)这么慢, 我该怎么办？

**count(*)的实现方式**

不同的MySQL引擎, count(*)有不同的实现方式: 

- MyISAM引擎把一个表的总行数存在了磁盘上, 因此执行count(*)时会直接返回这个数, 效率很高；
- InnoDB引擎需要把数据一行一行地从引擎里面读出来, 然后累计计数.

InnoDB没有把总行数存起来的原因是: 由于多版本并发控制(MVCC)的原因, InnoDB表“应该返回多少行”也是不确定的.

在保证逻辑正确的前提下, 尽量减少扫描的数据量, 是数据库系统设计的通用法则之一.

小结: 

- MyISAM表虽然count(*)很快, 但是不支持事物
- show table status 命令虽然返回很快, 但是不准确
- InnoDB表直接count(*)会遍历全表, 虽然结果准确, 但会导致性能问题

如果要经常统计操作记录总数的话, 应该自己把操作记录表的行数存起来.


##### 用缓存系统保存计数

使用redis缓存来保持计数会存在不精确的问题: 

- redis可能会出现异常重启的情况, 这时如果内存中的数据没用及时持久化的话, 会丢失更新计数.
- 即使redis正常工作, 也会出现逻辑上不精确
	- 先插入数据库数据, 再更新redis计数值.这时在它们中间有一个线程读取了数据库, 是有最新的插入数据, 但读redis时没有计数没有增加这条记录, 就会出现数据不精确
	- 如果先更新redis计数值, 再插入数据库数据.同样在它们中间一个线程先读取redis, 再读取数据库, 这时不能读取到要新插入到数据.


##### 在数据库保存计数

如果把计数存在一个表中, 就可以解决存在缓存中出现的问题: 

- InnoDB支持崩溃恢复不丢失数据
- 通过InnoDB事物特性, 可以确保在执行累加和插入操作未提交事物时, 其他事物是看不到中间状态结果的.

##### 不同的count用法

count(*), count(主键 id), count(字段), count(1) 性能分析: 

- count(主键 id): InnoDB会遍历整张表, 取出每一行id, 然后返回给server层.server层再判断id不可能为null, 按行累加.
- count(1): 遍历整张表, 但不取值, server层对返回的每一行放”1”进去, 判断不可能为空, 按行累加.
- count(字段): 
	- 如果该字段定义为非null的话, 一行行从记录里取出这个字段, 判断不可能为null, 按行累加.
	- 如果这个“字段”定义允许为 null,那么执行的时候,判断到有可能是 null,还要把值取出来再判断一下, 不是null时才累加.
- count(\*) 是例外,并不会把全部字段取出来,而是专门做了优化,不取值.count(*) 肯定不是 null,按行累加.

结论是:按照效率排序的话,count(字段)&gt;count(主键 id)&gt;count(1)≈count(\*),所以建议尽量使用count(*).

