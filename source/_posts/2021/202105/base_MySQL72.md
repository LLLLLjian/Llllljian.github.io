---
title: MySQL_基础 (72)
date: 2021-05-12
tags: MySQL
toc: true
---

### 更好的理解MySQL
    MySQL实战45讲

<!-- more -->

#### 故事背景
> 今天在b站学习mysql的时候 突然觉得b站的学习氛围不是很好了呀, 都是随便讲的, 都是想吃互联网第二波饭的人, 两个小时的视频里有一个多小时是在卖课,  在给人洗脑, 然后我就找呀找, 最后找到了【MySQL实战45讲】, 看过的人都说好, 我也来看看吧, 学一学

#### 16“order by”是怎么工作的？

##### 全字段排序

![全字段排序](/img/20210512_1.png)


排序动作的执行, 可能在内存中完成, 也可能需要使用外部排序, 利用磁盘临时文件辅助排序.这取决于排序所需要的内存和MySQL为排序开辟的内存(sort_buffer)的大小.sort_buffer的大小由sort_buffer_size参数决定.

内部排序使用快速排序算法, 外部排序一般使用归并排序算法.


##### rowid排序

上述排序如果单行数据很大, 那么排序性能就会很差.

修改参数, 当单行长度超过该值时, MySQL就会换一种算法.先取排序的字段和ID, 然后排序, 最后再回表取出结果集.

    SET max_length_for_sort_data = 16;


![rowid排序](/img/20210512_2.png)


##### 全字段排序 VS rowid 排序

如果MySQL认为内存足够大, 会优先选择全字段排序, 若内存不够用则选择rowid排序.

MySQL的一个设计思想: 如果内存够, 就要多利用内存, 尽量减少磁盘访问.


建立联合索引, 避免执行排序: 

![联合索引排序](/img/20210512_3.png)


使用覆盖索引, 避免回表查询: 

![覆盖索引排序](/img/20210512_3.png)

#### 17如何正确地显示随机消息？

### 内存临时表

Extra 字段显示 Using temporary, 表示的是需要使用临时表； Using filesort, 表示的是需要执行排序操作.

对于InnoDB表来说, 执行全字段排序会减少磁盘访问, 因此会被优先选择.

对于内存表, 回表过程只是简单地根据数据行的位置, 直接访问内存得到数据, 根本不会导致多访问磁盘.优化器这时就会优先考虑的是, 用于排序的行越小越好(是因为单行数据很大, 那么排序性能就会很差), 所以, MySQL这时就会选择rowid排序.

如果你创建的表没有主键, 或者把一个表的主键删掉了, 那么InnoDB会自己生成一个长度为6字节的rowid来作为主键.


* 对于有主键的InnoDB表来说, 这个rowid就是主键ID
* 对于没有主键的InnoDB表来说, 这个rowid就是由系统生成的


order by rand() 使用了内存临时表, 内存临时表排序的时候使用的是rowid排序方法.

### 磁盘临时表

如果临时表大小超过了tmp_table_size(默认值是16M), 那么内存临时表就会转成磁盘临时表.

当使用磁盘临时表的时候, 对应的就是一个没有显式索引的InnoDB表的排序过程.

临时文件算法-->归并排序算法


### 随机排序方法

    mysql> select count(*) into @C from t;
    set @Y1 = floor(@C * rand());
    set @Y2 = floor(@C * rand());
    set @Y3 = floor(@C * rand());
    select * from t limit @Y1, 1； // 在应用代码里面取 Y1、Y2、Y3 值, 拼出 SQL 后执行
    select * from t limit @Y2, 1；
    select * from t limit @Y3, 1；

在实际应用的过程中, 比较规范的用法就是: 尽量将业务逻辑写在业务代码中, 让数据库只做“读写数据”的事情.