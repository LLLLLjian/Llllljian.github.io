---
title: MySQL_基础 (74)
date: 2021-05-14
tags: MySQL
toc: true
---

### 更好的理解MySQL
    MySQL实战45讲

<!-- more -->

#### 故事背景
> 今天在b站学习mysql的时候 突然觉得b站的学习氛围不是很好了呀, 都是随便讲的, 都是想吃互联网第二波饭的人, 两个小时的视频里有一个多小时是在卖课,  在给人洗脑, 然后我就找呀找, 最后找到了【MySQL实战45讲】, 看过的人都说好, 我也来看看吧, 学一学

#### 20幻读是什么, 幻读有什么问题？

##### 幻读是什么？

**注意: 下面的假设场景都是不成立的, 是为了反正间隙锁的存在.**

幻读指的是一个事物在前后两次查询同一个范围的时候, 后一次查询看到了前一次查询没有看到的行.

幻读说明: 

1. 在可重复读隔离级别下, 普通的查询是快照读, 是不会看到别的事物插入的数据的.因此, 幻读在“当前读”下才会出现.
2. 上面sessionB的修改结果, 被sessionA之后的select语句用“当前读”看到, 不能成为幻读.幻读仅专指“新插入的行”.


##### 如何解决幻读？

产生幻读的原因是, 行锁只能锁住行, 但是新插入记录这个动作, 要更新的是记录之间的“间隙”.因此为了解决幻读问题, InnoDB只好引入新的锁, 也就是间隙锁(Gap Lock).

间隙锁, 锁的是两个值之间的空隙.例如下面插入6条记录产生的7个间隙: 
![间隙锁](/img/20210514_1.png)

当你执行 select * from t where d=5 for update 的时候, 就不止是给数据库中已有的6个记录加上了行锁, 还同时加了7个间隙锁.这样就确保了无法再插入新的记录.

两种类型行锁的冲突关系: 
![两种类型行锁的冲突关系](/img/20210514_2.png)

但是间隙锁不一样, 跟间隙锁存在冲突关系的, 是“往这个间隙中插入一个记录”这个操作.间隙锁之间都不存在冲突关系.间隙锁的目标是保护这个间隙, 不允许插入值.但它们之间是不冲突的.

间隙锁和行锁合称 next-key lock, 每个 next-key lock 是前开后闭区间.例如  (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20,25]、(25, +supernum]

间隙锁和 next-key lock 的引入帮我们解决了幻读的问题.但是间隙锁的引入, 可能会导致同样的语句锁住更大的范围, 这就影响了并发读.

间隙锁是在可重复读隔离级别下才会生效的.如果把隔离级别设置为读提交的话, 就没有间隙锁了.但同时要解决可能出现的数据和日志不一致的问题, 需要把binlog格式设置为row.

#### 21 | 为什么我只改一行的语句, 锁这么多？

加锁规则: 包含了两个“原则“, 两个“优化”和一个“bug”.

1. 原则1: 加锁的基本单位是 next-key lock.next-key lock是前开后闭区间.
2. 原则2: 查找过程中访问到的对象才会加锁
3. 优化1: 索引上的等值查询, 给唯一索引加锁的时候, next-key lock 退化为行锁
4. 优化2: 索引上的等值查询, 向右遍历时且最后一个值不满足等值条件的时候, next-key lock 退化为间隙锁.
5. 一个bug: 唯一索引上的范围查询会访问到不满足条件的第一个值为止.

##### 小结

上面所有案例都是在可重复读隔离级别下验证的.同时, 可重复读隔离级别遵守两阶段锁协议, 所有加锁的资源, 都是在事务提交或者回滚的时候才释放的.

在读提交隔离级别下还有一个优化, 即: 语句执行过程中加上的行锁, 在语句执行完成后, 就要把“不满足条件的行”上的行锁直接释放了, 不需要等到事务提交.也就是说, 读提交隔离级别下, 锁的范围更小, 锁的时间更短.
