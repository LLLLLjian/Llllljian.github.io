---
title: 消息中间件 (01)
date: 2021-07-19
tags: MQ
toc: true
---

### 跟着项目学习系列
    项目中用到RabbitMQ了， 那我肯定要学一下鸭

<!-- more -->


#### MQ是什么
> MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应用程序通过 队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求。

#### MQ能干什么

#### MQ优点
> 异步、削峰、解耦
1. 异步
    * ![异步](/img/20210719_1.png)
    * 例如原来的一套逻辑，完成支付可能涉及先修改订单状态、计算会员积分、通知物流配送几个逻辑才能完成；通过MQ架构设计，就可将紧急重要（需要立刻响应）的业务放到该调用方法中，响应要求不高的使用消息队列，放到MQ队列中，供消费者处理。
    * 疑问: 为什么不用线程/线程池去做
        * 用线程去做的话，这么多业务就要调用这么多接口，每次加一个业务都要重新发布一次，耦合太多了。而且出了问题排查会很麻烦
2. 解耦
    * ![解耦](/img/20210719_2.png)
    * 交互系统之间没有直接的调用关系，只是通过消息传输，故系统侵入性不强，耦合度低
3. 削峰
    * 通过消息作为整合，大数据的背景下，消息队列还与实时处理架构整合，为数据处理提供性能支持
    * 流量疯涨时把请求放在队列里， 然后至于每秒消费多少请求，就看自己的服务器处理能力，你能处理5000QPS你就消费这么多，可能会比正常的慢一点，但是不至于打挂服务器，等流量高峰下去了，你的服务也就没压力了。

#### MQ缺点
- 增加系统复杂性
    * 加入中间件之后，使用的过程中要考虑消息重复消费、消息丢失、消息的顺序消费等等
- 数据一致性
    * 自己管自己是很渣男的一句话，成功发送了消息之后，后续系统如果失败怎么办，怎么保证数据的一致性
- 可用性
    * 搞个系统没问题，中间件也没问题，但是万一中间件挂了，后续全会出现问题，怎么保证中间件的高可用

#### MQ应用场景
- 异步通信
    * 有些业务不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们
- 解耦
    * 降低工程间的强依赖程度，针对异构系统进行适配。在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。通过消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，当应用发生变化时，可以独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。
- 冗余
    * 有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。
- 扩展性
    * 因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。便于分布式扩容。
- 过载保护
    * 在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量无法提取预知；如果以为了能处理这类瞬间峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。
- 可恢复性
    * 系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。
- 顺序保证
    * 在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。
- 缓冲
    * 在任何重要的系统中，都会有需要不同的处理时间的元素。消息队列通过一个缓冲层来帮助任务最高效率的执行，该缓冲有助于控制和优化数据流经过系统的速度。以调节系统响应时间。
- 数据流处理
    * 分布式系统产生的海量数据流，如：业务日志、监控数据、用户行为等，针对这些数据流进行实时或批量采集汇总，然后进行大数据分析是当前互联网的必备技术，通过消息队列完成此类数据收集是最好的选择。

#### MQ的组成
- Broker: 消息服务器，作为server提供消息核心服务
- Producer: 消息生产者，业务的发起方，负责生产消息传输给broker，
- Consumer: 消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理
- Topic: 主题，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的广播
- Queue: 队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收
- Message: 消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输

####  MQ常用协议
- AMQP协议: AMQP即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同开发语言等条件的限制。优点: 可靠、通用
- MQTT协议: MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）是IBM开发的一个即时通讯协议，有可能成为物联网的重要组成部分。该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当做传感器和致动器（比如通过Twitter让房屋联网）的通信协议。 优点: 格式简洁、占用带宽小、移动端通信、PUSH、嵌入式系统
- STOMP协议: STOMP（Streaming Text Orientated Message Protocol）是流文本定向消息协议，是一种为MOM(Message Oriented Middleware，面向消息的中间件)设计的简单文本协议。STOMP提供一个可互操作的连接格式，允许客户端与任意STOMP消息代理（Broker）进行交互。 优点: 命令模式（非topic\queue模式）
- XMPP协议: XMPP（可扩展消息处理现场协议，Extensible Messaging and Presence Protocol）是基于可扩展标记语言（XML）的协议，多用于即时消息（IM）以及在线现场探测。适用于服务器之间的准即时操作。核心是基于XML流传输，这个协议可能最终允许因特网用户向因特网上的其他任何人发送即时消息，即使其操作系统和浏览器不同。 优点: 通用公开、兼容性强、可扩展、安全性高，但XML编码格式占用带宽大
- 其他基于TCP/IP自定义的协议 有些特殊框架（如: redis、kafka、zeroMq等）根据自身需要未严格遵循MQ规范，而是基于TCP\IP自行封装了一套协议，通过网络socket接口进行传输，实现了MQ的功能。

#### MQ模式分类
1. 发布/订阅: Pub/Sub发布订阅（广播）: 使用topic作为通信载体
    * ![发布/订阅](/img/20210719_3.png)
    * 消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。
    * topic实现了发布和订阅，当你发布一个消息，所有订阅这个topic的服务都能得到这个消息，所以从1到N个订阅者都能得到一个消息的拷贝。
2. 点对点: PTP点对点: 使用queue作为通信载体
    * ![点对点](/img/20210719_4.png)
    * 消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息。 
    * 消息被消费以后，queue中不再存储，所以消息消费者不可能消费到已经被消费的消息。
    * queue实现了负载均衡，将producer生产的消息发送到消息队列中，由多个消费者消费。但一个消息只能被一个消费者接受，当没有消费者可用时，这个消息会被保存直到有一个可用的消费者。 

#### MQ特性
![MQ特性](/img/20210719_5.png)


