---
title: Interview_总结 (141)
date: 2021-09-29
tags: Interview
toc: true
---

### 面试题
    别看了 这就是你的题

<!-- more -->

#### 网络编程和并发
1. 简述 OSI 七层协议
    ```
        物理层: 主要基于电器特性发送高低电压(1、0), 设备有集线器、中继器、双绞线等, 单位: bit
        数据链路层: 定义了电信号的分组方式, 设备: 交换机、网卡、网桥, 单位: 帧
        网络层: 主要功能是将网络地址翻译成对应屋里地址, 设备: 路由
        传输层: 建立端口之间的通信, tcp、udp协议
        会话层: 建立客户端与服务端连接
        表示层: 对来自应用层的命令和数据进行解释, 按照一定格式传给会话层.如编码、数据格式转换、加密解密、压缩解压
        应用层: 规定应用程序的数据格式
    ```
2. IO多路复用的作用
    ```
        # IO多路复用分为时间上的复用和空间上的复用, 
        # 空间上的复用是指将内存分为几部分, 每一部分放一个程序, 这样同一时间内存中就有多道程序；
        # 时间上的复用是指多个程序需要在一个cpu上运行, 不同的程序轮流使用cpu, 
        # 当某个程序运行的时间过长或者遇到I/O阻塞, 操作系统会把cpu分配给下一个程序, 
        # 保证cpu处于高使用率, 实现伪并发.
    ```
3. select、poll、epoll 模型的区别
    ```
        # select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理.这样所带来的缺点是: 
        # 1.单个进程可监视的fd数量被限制
        # 2.需要维护一个用来存放大量fd的数据结构
        #   这样会使得用户空间和内核空间在传递该结构时复制开销大
        # 3.对socket进行扫描时是线性扫描

        # poll本质上和select没有区别, 它将用户传入的数组拷贝到内核空间, 
        # 它没有最大连接数的限制, 原因是它是基于链表来存储的但是同样有一个缺点: 
        # 大量的fd的数组被整体复制于用户态和内核地址空间之间, 而不管这样的复制是不是有意义.
        # epoll支持水平触发和边缘触发, 最大的特点在于边缘触发, 
        # 它只告诉进程哪些fd刚刚变为就需态, 并且只会通知一次.
    ```
4. 简述 进程、线程、协程的区别 以及应用场景
    ```
        # 进程
        进程拥有自己独立的堆和栈, 既不共享堆, 亦不共享栈, 进程由操作系统调度.
        # 线程
        线程拥有自己独立的栈和共享的堆, 共享堆, 不共享栈, 线程亦由操作系统调度
        # 协程和线程的区别
        协程避免了无意义的调度, 由此可以提高性能；但同时协程也失去了线程使用多CPU的能力.
    ```
5. 进程之间如何进行通信
    ```
        进程间通讯有多种方式, 包括信号, 管道, 消息队列, 信号量, 共享内存, socket等
    ```
6. 什么是并发和并行
    ```
        # 并发: 同一时刻只能处理一个任务, 但一个时段内可以对多个任务进行交替处理(一个处理器同时处理多个任务)
        # 并行: 同一时刻可以处理多个任务(多个处理器或者是多核的处理器同时处理多个不同的任务)
        # 类比: 并发是一个人同时吃三个馒头, 而并行是三个人同时吃三个馒头.
    ```
7. 进程锁和线程锁的作用
    ```
        线程锁: 大家都不陌生, 主要用来给方法、代码块加锁.当某个方法或者代码块使用锁时, 那么在同一时刻至多仅有有一个线程在执行该段代码.当有多个线程访问同一对象的加锁方法 / 代码块时, 同一时间只有一个线程在执行, 其余线程必须要等待当前线程执行完之后才能执行该代码段.但是, 其余线程是可以访问该对象中的非加锁代码块的.

        进程锁: 也是为了控制同一操作系统中多个进程访问一个共享资源, 只是因为程序的独立性, 各个进程是无法控制其他进程对资源的访问的, 但是可以使用本地系统的信号量控制(操作系统基本知识).

        分布式锁: 当多个进程不在同一个系统之中时, 使用分布式锁控制多个进程对资源的访问.
    ```
8. 解释什么是异步非阻塞
    ```
        '非阻塞': 
            遇到IO阻塞不等待(setblooking=False),(可能会报错->捕捉异常)
                - sk=socket.socket()
                - sk.setblooking(False)
        '异步': 
            回调(ajax), 当达到某个指定状态之后, 自动调用特定函数
    ```

#### 数据库和缓存
1. 列举创建索引但是无法命中索引的8种情况
    ```sql
        # 使用'like ‘%xx’'
            select * from tb1 where name like '%cn';
        # 使用'函数'
            select * from tb1 where reverse(name)='zgc';
        # 使用'or'
            select * from tb1 where nid=1 or  email='zgc@gmial.com';
            特别的: 当or条件中有未建立索引的列才失效, 一下会走索引
                    # select * from tb1 where nid=1 or name='zgc';
                    # select * from tb1 where nid=1 or email='zgc@gmial.com' and name='zgc';
        # '类型不一致'
            如果列是字符串类型, 传入条件是必须用引号引起来, 不然则可能会无法命中
            select * from tb1 where name=666；
        # 含有'!= '
            select * from tb1 where name != 'zgc';
            特别的: 如果是主键, 还是会走索引
                    # select * from tb1 where nid != 123;
        # 含有'>'
            select * from tb1 where name > 'zgc';
            特别的: 如果是主键或者索引是整数类型, 则还是会走索引
                    # select * from tb1 where nid > 123;
                    # select * from tb1 where name > 123;
        # 含有'order by'
            select email from tb1 order by name desc;
            当根据索引排序时, 选择的映射如果不是索引, 则不走索引
            特别的: 如果对主键排序, 则还是走索引: 
                    # select * from tb1 order by nid desc;

        # 组合索引最左前缀
            如果组合索引为: (name, email)
            name and email #使用索引
            name           #使用索引
            email          #不使用索引
    ```
2. 数据库优化方案
    ```
        1、创建数据表时把固定长度的放在前面
        2、将固定数据放入内存: choice字段(django中用到, 1,2,3对应相应内容)
        3、char不可变, varchar可变
        4、联合索引遵循最左前缀(从最左侧开始检索)
        5、避免使用 select *
        6、读写分离: 
            #利用数据库的主从分离: 主, 用于删除、修改、更新；从, 用于查
            #实现: 两台服务器同步数据
            \原生SQL:select * from db.tb
            \ORM: model.User.object.all().using('default')
            \路由: db router
        7、分库
            # 当数据库中的表太多, 将某些表分到不同数据库, 例如: 1W张表时
            # 代价: 连表查询跨数据库, 代码变多
        8、分表
            # 水平分表: 将某些列拆分到另一张表, 例如: 博客+博客详情
            # 垂直分表: 将某些历史信息, 分到另外一张表中, 例如: 支付宝账单
        9、加缓存
            # 利用redis、memcache(常用数据放到缓存里, 提高取数据速度)
            # 缓存不够可能会造成雪崩现象
        10、如果只想获取一条数据
        select password from tb where name = 'zgc' limit 1;
    ```
3. char和varchar的区别
    ```
        # char类型: 定长不可变
        存入字符长度大于设置长度时报错；
        存入字符串长度小于设置长度时, 用空格填充以达到设置字符串长度；
        简单粗暴, 浪费空间, 存取速度快.
        # varchar类型: 可变
        存储数据真实内容, 不使用空格填充；
        会在真实数据前加1-2Bytes的前缀, 用来表示真实数据的bytes字节数；
        边长、精准、节省空间、存取速度慢.
    ```
4. redis如何实现主从复制？以及数据同步机制
    ```
        # 实现主从复制
            '创建6379和6380配置文件'
            redis.conf: 6379为默认配置文件, 作为Master服务配置；
            redis_6380.conf: 6380为同步配置, 作为Slave服务配置；
            '配置slaveof同步指令'
            在Slave对应的conf配置文件中, 添加以下内容: 
            slaveof 127.0.0.1 6379
        # 数据同步步骤: 
            (1)Slave服务器连接到Master服务器.
            (2)Slave服务器发送同步(SYCN)命令.
            (3)Master服务器备份数据库到文件.
            (4)Master服务器把备份文件传输给Slave服务器.
            (5)Slave服务器把备份文件数据导入到数据库中.
    ```
5. 如何实现redis集群
    ```
        # 基于【分片】来完成.
            - 集群是将你的数据拆分到多个Redis实例的过程
            - 可以使用很多电脑的内存总和来支持更大的数据库.
            - 没有分片, 你就被局限于单机能支持的内存容量.
        # redis将所有能放置数据的地方创建了 16384 个哈希槽.
        #如果设置集群的话, 就可以为每个实例分配哈希槽: 
            - 192.168.1.20【0-5000】
            - 192.168.1.21【5001-10000】
            - 192.168.1.22【10001-16384】
        # 以后想要在redis中写值时: set k1 123 
            - 将k1通过crc16的算法转换成一个数字, 然后再将该数字和16384求余, 
            - 如果得到的余数 3000, 那么就将该值写入到 192.168.1.20 实例中.
        # 集群方案: 
            - redis cluster: 官方提供的集群方案.
            - codis: 豌豆荚技术团队.
            - tweproxy: Twiter技术团队.
    ```
6. 简述redis的有哪几种持久化策略及比较
    ```
        # RDB: 每隔一段时间对redis进行一次持久化.
            - 缺点: 数据不完整
            - 优点: 速度快
        # AOF: 把所有命令保存起来, 如果想重新生成到redis, 那么就要把命令重新执行一次.
            - 缺点: 速度慢, 文件比较大
            - 优点: 数据完整
    ```
7. 什么是一致性哈希？Python中是否有相应模块
    ```
        #  一致性哈希
        一致性hash算法(DHT)可以通过减少影响范围的方式, 解决增减服务器导致的数据散列问题, 从而解决了分布式环境下负载均衡问题；
        如果存在热点数据, 可以通过增添节点的方式, 对热点区间进行划分, 将压力分配至其他服务器, 重新达到负载均衡的状态.
        # 模块: hash_ring
    ```












