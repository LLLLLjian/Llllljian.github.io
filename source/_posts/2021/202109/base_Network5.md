---
title: network_基础 (5)
date: 2021-09-17
tags: Network
toc: true
---

### 网络相关(1)--五层网络协议
    网络相关(1)-- 五层网络协议

<!-- more -->

#### 引子

![网络协议](/img/20210917_1.png)

##### 原理体系结构
- 应用层
    * 为特定应用程序提供数据传输服务, 例如 HTTP、DNS 等.数据单位为报文
- 传输层
    * 为进程提供通用数据传输服务.由于应用层协议很多, 定义通用的传输层协议就可以支持不断增多的应用层协议.运输层包括两种协议: 传输控制协议 TCP, 提供面向连接、可靠的数据传输服务, 数据单位为报文段；用户数据报协议 UDP, 提供无连接、尽最大努力的数据传输服务, 数据单位为用户数据报.TCP 主要提供完整性服务, UDP 主要提供及时性服务.
- 网络层
    * 为主机提供数据传输服务.而传输层协议是为主机中的进程提供数据传输服务.网络层把传输层传递下来的报文段或者用户数据报封装成分组
- 数据链路层
    * 网络层针对的还是主机之间的数据传输服务, 而主机之间可以有很多链路, 链路层协议就是为同一链路的主机提供数据传输服务.数据链路层把网络层传下来的分组封装成帧.
- 物理层
    * 考虑的是怎样在传输媒体上传输数据比特流, 而不是指具体的传输媒体.物理层的作用是尽可能屏蔽传输媒体和通信手段的差异, 使数据链路层感觉不到这些差异

##### OSI
- 表示层
    * 数据压缩、加密以及数据描述, 这使得应用程序不必关心在各台主机中数据内部格式不同的问题
- 会话层
    * 建立及管理会话

##### TCP/IP
> 相当于五层协议中数据链路层和物理层合并为网络接口层.

##### 传输层详解
- 传输控制协议TCP(Transmisson Control Protocol)
    * 提供面向连接的, 可靠的数据传输服务
    * TCP是面向连接的.(就好像打电话一样, 通话前需要先拨号建立连接, 通话结束后要挂机释放连接)
    * 每一条TCP连接只能有两个端点, 每一条TCP连接只能是点对点的(一对一)
    * TCP提供可靠交付的服务.通过TCP连接传送的数据, 无差错、不丢失、不重复、并且按序到达
    * TCP提供全双工通信.TCP允许通信双方的应用进程在任何时候都能发送数据.TCP连接的两端都设有发送缓存和接收缓存, 用来临时存放双方通信的数据
    * 面向字节流.TCP中的“流”(stream)指的是流入进程或从进程流出的字节序列.“面向字节流”的含义是: 虽然应用程序和TCP的交互是一次一个数据块(大小不等), 但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流
- 用户数据协议UDP(User Datagram Protocol)
    * 提供无连接的, 尽最大努力的数据传输服务(不保证数据传输的可靠性)
    * UDP是无连接的；
    * UDP使用尽最大努力交付, 即不保证可靠交付, 因此主机不需要维持复杂的链接状态(这里面有许多参数)
    * UDP是面向报文的
    * UDP没有拥塞控制, 因此网络出现拥塞不会使源主机的发送速率降低(对实时应用很有用, 如IP电话, 实时视频会议等)
    * UDP支持一对一、一对多、多对一和多对多的交互通信
    * UDP的首部开销小, 只有8个字节, 比TCP的20个字节的首部要短

##### TCP协议如何来保证传输的可靠性

TCP提供一种面向连接的、可靠的字节流服务.其中, 面向连接意味着两个使用TCP的应用(通常是一个客户和一个服务器)在彼此交换数据之前必须先建立一个TCP连接.在一个TCP连接中, 仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流, TCP不在字节流中插入记录标识符.

1. 数据包校验: 目的是检测数据在传输过程中的任何变化, 若校验出包有错, 则丢弃报文段并且不给出响应, 这时TCP发送数据端超时后会重发数据；
2. 对失序数据包重排序: 既然TCP报文段作为IP数据报来传输, 而IP数据报的到达可能会失序, 因此TCP报文段的到达也可能会失序.TCP将对失序数据进行重新排序, 然后才交给应用层；
3. 丢弃重复数据: 对于重复数据, 能够丢弃重复数据；
4. 应答机制: 当TCP收到发自TCP连接另一端的数据, 它将发送一个确认.这个确认不是立即发送, 通常将推迟几分之一秒；
5. 超时重发: 当TCP发出一个段后, 它启动一个定时器, 等待目的端确认收到这个报文段.如果不能及时收到一个确认, 将重发这个报文段；
6. 流量控制: TCP连接的每一方都有固定大小的缓冲空间.TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据, 这可以防止较快主机致使较慢主机的缓冲区溢出, 这就是流量控制.TCP使用的流量控制协议是可变大小的滑动窗口协议.

##### TCP三次握手
- 第一次握手: Client向Server发送请求报文, SYN=1, ACK=0, 随机产生一个值seq=x, Client进入SYN_SENT状态, 等待Server确认
- 第二次握手: Server收到请求报文后, 如果同意建立连接, 则向Client发送连接确认报文, SYN=1, ACK=1, ack=x+1, 并随机产生一个值seq=y, Server进入SYN_RCVD状态
- 第三次握手: Client收到确认后, 检查ack是否为x+1, ACK是否为1, 如果正确则向Server发送确认报文, ACK=1, ack=y+1, seq=x+1, Server检查ack是否为x+1, ACK是否为1, 如果正确则连接建立成功, Client和Server进入ESTABLISHED状态, 完成三次握手, 随后Client与Server之间可以开始传输数据了
- Q: 为什么要三次握手, 两次不可以吗
    * 第三次握手就是为了防止失效的连接请求到达服务器, 让服务器错误打开连接, 造成资源的浪费


##### TCP四次挥手
1. 第一次挥手: Client发送一个FIN=1, seq=u用来关闭Client到Server的数据传送, Client进入FIN_WAIT_1状态
2. 第二次挥手: Server收到FIN后, 发送确认报文给Client, ACK=1, seq=v, ack=u+1(与SYN相同, 一个FIN占用一个序号), Server进入CLOSE_WAIT状态.此时TCP链接处于半关闭状态, 即客户端已经没有要发送的数据了, 但服务端若发送数据, 则客户端仍要接收
3. 第三次挥手: Server发送一个FIN, 用来关闭Server到Client的数据传送, Server进入LAST_ACK状态
4. 第四次挥手: Client收到FIN后, Client进入TIME_WAIT状态, 接着发送一个ACK给Server, 确认序号为收到序号+1, 等待2MSL(最大报文存活时间)后进入CLOSED状态.Server收到Client的ACK后进入CLOSED状态, 完成四次挥手
- Q:为什么要四次挥手, 而不是两次, 三次?
    * A :首先, 由于TCP的全双工通信, 双方都能作为数据发送方. A想要关闭连接, 必须要等数据都发送完毕, 才发送FIN给B.(此时A处于半关闭状态)然后, B发送确认ACK, 并且B此时如果要发送数据, 就发送(例如做一些释放前的处理)再者, B发送完数据之后, 发送FIN给A. (此时B处于半关闭状态)然后, A发送ACK, 进入TIME-WAIT状态最后, 经过2MSL时间后没有收到B传来的报文, 则确定B收到了ACK了.(此时A, B才算是处于完全关闭状态)
- Q : 为什么要等待2MSL(Maximum Segment Lifetime)时间, 才从TIME_WAIT到CLOSED？
    * A : 在Client发送出最后的ACK回复, 但该ACK可能丢失.Server如果没有收到ACK, 将不断重复发送FIN片段.所以Client不能立即关闭, 它必须确认Server接收到了该ACK.Client会在发送出ACK之后进入到TIME_WAIT状态.Client会设置一个计时器, 等待2MSL的时间.如果在该时间内再次收到FIN, 那么Client会重发ACK并再次等待2MSL.MSL指一个片段在网络中最大的存活时间, 2MSL就是一个发送和一个回复所需的最大时间.如果直到2MSL, Client都没有再次收到FIN, 那么Client推断ACK已经被成功接收, 则结束TCP连接

##### 应用层
- DNS查询例子
    * 域名为x.tom.com的主机想知道y.jerry.com的IP地址
    1. 主机x.tom.com先向本地域名服务器dns.tom.com进行递归查询
    2. 本地域名服务器采用迭代查询. 它先问一个根域名服务器
    3. 根域名服务器告诉它, 你去问顶级域名服务器dns.com
    4. 本地域名服务器问顶级域名服务器dns.com
    5. 顶级域名服务器告诉它, 你去问权限域名服务器dns.jerry.com
    6. 本地域名服务器问权限域名服务器dns.jerry.com
    7. 权限域名服务器dns.jerry.com告诉它所查询的主机的IP地址
    8. 本地域名服务器把查询结果告诉主机x.tom.com



