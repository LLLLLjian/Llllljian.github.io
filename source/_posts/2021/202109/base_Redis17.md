---
title: Redis_基础 (17)
date: 2021-09-16
tags: 
    - Redis
    - Interview
toc: true
---

### 常见问题
    别看了 你的题

<!-- more -->

#### 为什么使用redis
- 性能
    * 碰到需要执行耗时特别久, 且结果不频繁变动的SQL, 就特别适合将运行结果放入缓存.这样, 后面的请求就去缓存中读取, 使得请求能够迅速响应
    ![性能](/img/20210916_1.png)
- 并发
    * 在大并发的情况下, 所有的请求直接访问数据库, 数据库会出现连接异常.这个时候, 就需要使用redis做一个缓冲操作, 让请求先访问到redis, 而不是直接访问数据库
    ![并发](/img/20210916_2.png)

#### 使用redis有什么缺点
1. 缓存和数据库双写一致性问题
2. 缓存雪崩问题
3. 缓存击穿问题
4. 缓存的并发竞争问题


#### 单线程的redis为什么这么快
> Redis采用的是基于内存的单进程单线程模型的 KV 数据库, 由C语言编写, 官方提供的数据是可以达到100000+的QPS(每秒内查询次数)
- 纯内存操作
    * 这里我们一直在强调的单线程, 只是在处理我们的网络请求的时候只有一个线程来处理, 一个正式的Redis Server运行的时候肯定是不止一个线程的, 这里需要大家明确的注意一下！例如Redis进行持久化的时候会以子进程或者子线程的方式执行(具体是子线程还是子进程待读者深入研究)
- 单线程操作, 避免了频繁的上下文切换和各种锁的问题
- 采用了非阻塞I/O多路复用机制
    * 多路I/O复用模型是利用 select、poll、epoll可以同时监察多个流的 I/O 事件的能力, 在空闲的时候, 会把当前线程阻塞掉, 当有一个或多个流有 I/O 事件时, 就从阻塞态中唤醒, 于是程序就会轮询一遍所有的流(epoll 是只轮询那些真正发出了事件的流), 并且只依次顺序的处理就绪的流, 这种做法就避免了大量的无用操作
    * 这里“多路”指的是多个网络连接, “复用”指的是复用同一个线程.采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求(尽量减少网络 IO 的时间消耗), 且 Redis 在内存中操作数据的速度非常快, 也就是说内存内的操作不会成为影响Redis性能的瓶颈, 主要由以上几点造就了 Redis 具有很高的吞吐量.
- 底层模型不同, Redis直接自己构建了VM 机制 , 因为一般的系统调用系统函数的话, 会浪费一定的时间去移动和请求
- 扩展
    1. 单进程多线程模型: MySQL、Memcached、Oracle(Windows版本)
    2. 多进程模型: Oracle(Linux版本)
    3. Nginx有两类进程, 一类称为Master进程(相当于管理进程), 另一类称为Worker进程(实际工作进程).启动方式有两种: 
        * 单进程启动: 此时系统中仅有一个进程, 该进程既充当Master进程的角色, 也充当Worker进程的角色.
        * 多进程启动: 此时系统有且仅有一个Master进程, 至少有一个Worker进程工作.
        * Master进程主要进行一些全局性的初始化工作和管理Worker的工作；事件处理是在Worker中进行的.

#### Redis的过期策略和内存淘汰机制

这个问题其实相当重要, 到底redis有没用到家, 这个问题就可以看出来.比如你redis只能存5G数据, 可是你写了10G, 那会删5G的数据.怎么删的, 这个问题思考过么？还有, 你的数据已经设置了过期时间, 但是时间到了, 内存占用率还是比较高, 有思考过原因么?

redis采用的是定期删除+惰性删除策略.

为什么不用定时删除策略?

定时删除,用一个定时器来负责监视key,过期则自动删除.虽然内存及时释放, 但是十分消耗CPU资源.在大并发请求下, CPU要将时间应用在处理请求, 而不是删除key,因此没有采用这一策略.

定期删除+惰性删除是如何工作的呢?

定期删除, redis默认每个100ms检查, 是否有过期的key,有过期key则删除.需要说明的是, redis不是每个100ms将所有的key检查一次, 而是随机抽取进行检查(如果每隔100ms,全部key进行检查, redis岂不是卡死).因此, 如果只采用定期删除策略, 会导致很多key到时间没有删除.

于是, 惰性删除派上用场.也就是说在你获取某个key的时候, redis会检查一下, 这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除.

采用定期删除+惰性删除就没其他问题了么?

不是的, 如果定期删除没删除key.然后你也没及时去请求key, 也就是说惰性删除也没生效.这样, redis的内存会越来越高.那么就应该采用内存淘汰机制.

在redis.conf中有一行配置 #maxmemory-policy volatile-lru

该配置就是配内存淘汰策略的(什么, 你没配过？好好反省一下自己)

1)noeviction: 当内存不足以容纳新写入数据时, 新写入操作会报错.应该没人用吧.

2)allkeys-lru: 当内存不足以容纳新写入数据时, 在键空间中, 移除最近最少使用的key.推荐使用, 目前项目在用这种.

3)allkeys-random: 当内存不足以容纳新写入数据时, 在键空间中, 随机移除某个key.应该也没人用吧, 你不删最少使用Key, 去随机删.

4)volatile-lru: 当内存不足以容纳新写入数据时, 在设置了过期时间的键空间中, 移除最近最少使用的key.这种情况一般是把redis既当缓存, 又做持久化存储的时候才用.不推荐

5)volatile-random: 当内存不足以容纳新写入数据时, 在设置了过期时间的键空间中, 随机移除某个key.依然不推荐

6)volatile-ttl: 当内存不足以容纳新写入数据时, 在设置了过期时间的键空间中, 有更早过期时间的key优先移除.不推荐

ps: 如果没有设置expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和noeviction(不删除) 基本上一致.

过期策略对应的面试题比如: mySQL里有2000w数据, redis中只存20w的数据, 如何保证redis中的数据都是热点数据

作者: 脆皮鸡大虾
链接: https://www.jianshu.com/p/3101b45eb999
来源: 简书
著作权归作者所有.商业转载请联系作者获得授权, 非商业转载请注明出处.

#### Redis和数据库双写一致性问题

解决方案大概有以下几种: 

1. 对删除缓存进行重试, 数据的一致性要求越高, 我越是重试得快.

2. 定期全量更新, 简单地说, 就是我定期把缓存全部清掉, 然后再全量加载.

3. 给所有的缓存一个失效期.

第三种方案可以说是一个大杀器, 任何不一致, 都可以靠失效期解决, 失效期越短, 数据一致性越高.但是失效期越短, 查数据库就会越频繁.因此失效期应该根据业务来定.

并发不高的情况: 

读:读redis->没有, 读mysql->把mysql数据写回redis, 有的话直接从redis中取；

写:写mysql->成功, 再写redis；

并发高的情况: 

读:读redis->没有, 读mysql->把mysql数据写回redis, 有的话直接从redis中取；

写: 异步话, 先写入redis的缓存, 就直接返回；定期或特定动作将数据保存到mysql, 可以做到多次更新, 一次保存；

#### 如何应对缓存穿透和缓存雪崩问题

- 缓存穿透

缓存穿透是指用户查询数据, 在数据库没有, 自然在缓存中也不会有.这样就导致用户查询的时候, 在缓存中找不到, 每次都要去数据库再查询一遍, 然后返回空(相当于进行了两次无用的查询).这样请求就绕过缓存直接查数据库, 这也是经常提的缓存命中率问题.

解决方案:

1. 布隆过滤

有很多种方法可以有效地解决缓存穿透问题, 最常见的则是采用布隆过滤器, 将所有可能存在的数据哈希到一个足够大的bitmap中, 一个一定不存在的数据会被这个bitmap拦截掉, 从而避免了对底层存储系统的查询压力.

2. 缓存空对象.将 null 变成一个值.

也可以采用一个更为简单粗暴的方法, 如果一个查询返回的数据为空(不管是数 据不存在, 还是系统故障), 我们仍然把这个空结果进行缓存, 但它的过期时间会很短, 最长不超过五分钟.

通过这个直接设置的默认值存放到缓存, 这样第二次到缓冲中获取就有值了, 而不会继续访问数据库, 这种办法最简单粗暴！

缓存空对象会有两个问题: 

第一, 空值做了缓存, 意味着缓存层中存了更多的键, 需要更多的内存空间 ( 如果是攻击, 问题更严重), 比较有效的方法是针对这类数据设置一个较短的过期时间, 让其自动剔除.

第二, 缓存层和存储层的数据会有一段时间窗口的不一致, 可能会对业务有一定影响.例如过期时间设置为 5分钟, 如果此时存储层添加了这个数据, 那此段时间就会出现缓存层和存储层数据的不一致, 此时可以利用消息系统或者其他方式清除掉缓存层中的空对象

- 缓存雪崩

缓存雪崩我们可以简单的理解为: 由于原有缓存失效, 新缓存未到期间(例如: 我们设置缓存时采用了相同的过期时间, 在同一时刻出现大面积的缓存过期), 所有原本应该访问缓存的请求都去查询数据库了, 而对数据库CPU和内存造成巨大压力, 严重的会造成数据库宕机.从而形成一系列连锁反应, 造成整个系统崩溃.

解决方案:

(1)给缓存的失效时间, 加上一个随机值, 避免集体失效.

(2)加锁排队, 在缓存失效后, 通过加锁或者队列来控制读数据库写缓存的线程数量.比如对某个key只允许一个线程查询数据和写缓存, 其他线程等待.

加锁排队只是为了减轻数据库的压力, 并没有提高系统吞吐量.假设在高并发下, 缓存重建期间key是锁着的, 这是过来1000个请求999个都在阻塞的.同样会导致用户等待超时, 这是个治标不治本的方法！

(3)双缓存.我们有两个缓存, 缓存A和缓存B.缓存A的失效时间为20分钟, 缓存B不设失效时间.自己做缓存预热操作.然后细分以下几个小点

I 从缓存A读数据库, 有则直接返回

II A没有数据, 直接从B读数据, 直接返回, 并且异步启动一个更新线程.

III 更新线程同时更新缓存A和缓存B.

(4)还有一个解决办法解决方案是: 给每一个缓存数据增加相应的缓存标记, 记录缓存的是否失效, 如果缓存标记失效, 则更新数据缓存.

解释说明: 

1、缓存标记: 记录缓存数据是否过期, 如果过期会触发通知另外的线程在后台去更新实际key的缓存；

2、缓存数据: 它的过期时间比缓存标记的时间延长1倍, 例: 标记缓存时间30分钟, 数据缓存设置为60分钟.这样, 当缓存标记key过期后, 实际缓存还能把旧数据返回给调用端, 直到另外的线程在后台更新完成后, 才会返回新缓存

- 缓存降级

就是在高并发高负载情况下, 选择动态的关闭一下不重要的服务, 拒绝访问等, 来为重要的服务节省资源, 比如电商平台秒杀当天可关闭推荐等功能.

当访问量剧增、服务出现问题(如响应时间慢或不响应)或非核心服务影响到核心流程的性能时, 仍然需要保证服务还是可用的, 即使是有损服务.系统可以根据一些关键数据进行自动降级, 也可以配置开关实现人工降级.

降级的最终目的是保证核心服务可用, 即使是有损的.而且有些服务是无法降级的(如加入购物车、结算).

在进行降级之前要对系统进行梳理, 看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护, 哪些可降级；比如可以参考日志级别设置预案: 

(1)一般: 比如有些服务偶尔因为网络抖动或者服务正在上线而超时, 可以自动降级

(2)警告: 有些服务在一段时间内成功率有波动(如在95~100%之间), 可以自动降级或人工降级, 并发送告警

(3)错误: 比如可用率低于90%, 或者数据库连接池被打爆了, 或者访问量突然猛增到系统能承受的最大阀值, 此时可以根据情况自动降级或者人工降级

(4)严重错误: 比如因为特殊原因数据错误了, 此时需要紧急人工降级

#### 如何解决redis并发竞争key问题

这个问题大致就是, 同时有多个子系统去set一个key.这个时候要注意什么呢？大家思考过么.需要说明一下, 博主提前百度了一下, 发现答案基本都是推荐用redis事务机制.博主不推荐使用redis的事务机制.因为我们的生产环境, 基本都是redis集群环境, 做了数据分片操作.你一个事务中有涉及到多个key操作的时候, 这多个key不一定都存储在同一个redis-server上.因此, redis的事务机制, 十分鸡肋.

(1)如果对这个key操作, 不要求顺序

这种情况下, 准备一个分布式锁, 大家去抢锁, 抢到锁就做set操作即可, 比较简单.

(2)如果对这个key操作, 要求顺序

假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.

期望按照key1的value值按照valueA–>valueB–>valueC的顺序变化.这种时候我们在数据写入数据库的时候, 需要保存一个时间戳.假设时间戳如下

系统Akey 1 {valueA  3:00}

系统Bkey 1 {valueB  3:05}

系统Ckey 1 {valueC  3:10}

那么, 假设这会系统B先抢到锁, 将key1设置为{valueB  3:05}.接下来系统A抢到锁, 发现自己的valueA的时间戳早于缓存中的时间戳, 那就不做set操作了.以此类推.

其他方法, 比如利用队列, 将set方法变成串行访问也可以.总之, 灵活变通.