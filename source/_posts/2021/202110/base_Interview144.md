---
title: Interview_总结 (144)
date: 2021-10-22
tags: Interview
toc: true
---

### 面试题
    别看了 这就是你的题

<!-- more -->

#### 输入url到页面展示发生了什么
1. DNS 域名解析
2. 建立 TCP 连接(三次握手)
3. 发送 HTTP 请求
4. 服务器处理请求
5. 返回响应结果
6. 关闭 TCP 连接(四次握手)
7. 浏览器解析 HTML
8. 浏览器布局渲染

##### DNS 域名解析
- 域名的结构
    ```
        网址: https://www.baidu.com/
        完整域名: www.baidu.com.root
        省略域名: www.baidu.com
    ```
- 为什么需要 DNS 解析域名为 IP 地址
    * 网络通讯需要相应的网络协议, 大部分是基于 TCP/IP 协议, 而 TCP/IP 协议是基于 IP 地址, 所以计算机网络通讯时只能识别 IP 地址. 由于用户很难记住每一个网站的 IP 地址, 所以就出现了“DNS服务器”
- 什么是 DNS
    * DNS 域名系统就是将域名 (例如: www.baidu.com) 转换为 IP 地址. 域名和 IP 地址是一一对应的
- DNS 解析方式
    * 正向解析: 将域名转换成对应的 IP地址的过程, 它应用于在浏览器地址栏中输入网站域名时的情形. 
    * 反向解析: 根据IP地址查找对应的注册域名, 经常被一些后台程序使用, 用户看不到. 
- DNS 查询方式
    * 客户端和浏览器, 本地 DNS之间的查询方式是递归查询. 
    * 本地 DNS 服务器与根域及其子域之间的查询方式是迭代查询. 
- DNS解析过程
    * **检查浏览器缓存**: 用户通过浏览器浏览某网站后, 浏览器会自动缓存该网站域名对应的 IP 地址, 当用户再次访问的时候, 浏览器会从缓存中查找该域名对应的 IP 地址, 如果有, 完成域名解析, 如果没有, 进行下一步
    * **查找本机host文件**: 如果用户的浏览器中缓存中没有, 系统会去查找自己本地的 hosts 文件是否有这个域名与 IP 的映射关系, 如果有, 完成域名解析, 如果没有, 进行下一步
    * **向 本地域名解析服务器 发起域名解析请求**: 如果在本机上没有完成域名解析, 系统会请求本地域名解析服务器进行解析,  如果有, 完成域名解析, 如果没有, 进行下一步
    * **向 根域名解析服务器 发起域名解析请求**: 从本地域名解析服务器获取到根域名服务器对应的主机名, 然后向根域名服务器发起解析请求. 根域名服务器接收请求, 返回所查域的顶级域名(gtld 域名)服务器地址
    * **向 顶级域名服务器 发起解析请求**: 本地域名解析服务器向顶级域名服务器发起解析请求, 顶级域名服务器接收请求, 返回二级域名服务器地址
    * **向 二级域名服务器 发起解析请求**: 本地域名解析服务器向二级域名服务器发起请求, 二级域名服务器接收请求, 返回 IP 地址给本地域名服务器. 
    * **本地域名服务器缓存结果**: 本地域名服务器缓存解析后的结果, 缓存时间由时间来控制. 
    * **返回解析结果给用户**: 解析结果将直接返回给用户, 用户系统将缓存该地址, 缓存时间由来控制, 至此, 解析过程结束

##### 建立 TCP 连接
- 什么是TCP
    * 传输控制协议(Transmission Control Protocol)
- 什么是UDP
    * 用户数据报协议(User Datagram Protocol)
- 三次握手
    * SYN: 是否是连接请求/接收报文段
    * seq: 发送的第一个字节的序号
    * ACK: 是否是确认报文段
    * ack: 确认号. 希望收到的下一个数据的第一个字节的序号
    * **第一次握手**: 客户端向服务端发送 SYN=1, seq=x
    * **第二次握手**: 服务端接收到客户端请求, 往回发送一个 SYN=1, ACK=1, seq=y, ack=x+1
    * **第三次握手**: 客户端接收到服务端的请求, 往回发一个ACK=1, seq=x+1, ack=y+1 
- 三次握手中通信双方状态
    * CLOSED: 没有连接状态. 初始客户端和服务器都是处于CLOSED状态. 
    * LISTEN: 收听状态, 侦听来自远方 TCP 端口的连接请求. 
    * SYN-SENT: 同步已发送, 在发送连接请求后等待匹配的连接请求. 
    * SYN-RCVD: 同步收到. 服务端被动打开后, 接收到了客户端的 SYN 并且发送了 ACK 时的状态. 
    * ESTABLISHED: 连接已建立, 可以数据传输. 
- 三次握手生活版
    * 客户端: “你好, 在家不？” -- SYN
    * 服务端: “在的, 你来吧. ” -- SYN + ACK
    * 客户端: “好嘞. ” -- ACK

##### 发送HTTP请求
- HTTP
    * 超文本传输协议(HyperText Transfer Protocol)
- 常见的Request Header
    * GET(请求的方式) /newcoder/hello.html(请求的目标资源) HTTP/1.1(请求采用的协议和版本号)  
    * Accept: \*/*(客户端能接收的资源类型)  
    * Accept-Language: en-us(客户端接收的语言类型)  
    * Connection: Keep-Alive(维护客户端和服务端的连接关系)  
    * Host: localhost:8080(连接的目标主机和端口号)  
    * Referer: http://localhost/links.asp(告诉服务器我来自于哪里)  
    * User-Agent: Mozilla/4.0(客户端版本号的名字)  
    * Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型)  
    * If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT(缓存时间)   
    Cookie(客户端暂存服务端的信息)  
    * Date: Tue, 11 Jul 2000 18:23:51 GMT(客户端请求服务端的时间)

##### 服务器处理请求
> 服务器接受到请求, 解析请求头. 如果头部有缓存相关信息如 if-none-match与 if-modified-since, 则验证缓存是否有效, 若有效则返回状态码为304, 若无效则重新返回资源, 状态码为200. 如果没有缓存, 直接返回资

##### 返回响应结果
- 常见的Response Header
    * HTTP/1.1(响应采用的协议和版本号) 200(状态码) OK(描述信息)
    * Location: http://www.baidu.com(服务端需要客户端访问的页面路径) 
    * Server:apache tomcat(服务端的Web服务端名)
    * Content-Encoding: gzip(服务端能够发送压缩编码类型) 
    * Content-Length: 80(服务端发送的压缩数据的长度) 
    * Content-Language: zh-cn(服务端发送的语言类型) 
    * Content-Type: text/html; charset=GB2312(服务端发送的类型及采用的编码方式)
    * Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT(服务端对该资源最后修改的时间)
    * Refresh: 1;url=http://www.it315.org(服务端要求客户端1秒钟后, 刷新, 然后访问指定的页面路径)
    * Content-Disposition: attachment; filename=aaa.zip(服务端要求客户端以下载文件的方式打开该文件)
    * Transfer-Encoding: chunked(分块传递数据到客户端)  
    * Set-Cookie:SS=Q0=5Lb_nQ; path=/search(服务端发送到客户端的暂存数据)
    * Expires: -1//3种(服务端禁止客户端缓存页面数据)
    * Cache-Control: no-cache(服务端禁止客户端缓存页面数据)  
    * Pragma: no-cache(服务端禁止客户端缓存页面数据)   
    * Connection: close(1.0)/(1.1)Keep-Alive(维护客户端和服务端的连接关系)  
    * sDate: Tue, 11 Jul 2000 18:23:51 GMT(服务端响应客户端的时间)
- 响应状态码
    * 1xx(信息)- 收到请求, 继续处理
    * 2xx(成功)- 请求已成功接收与处理
    * 3xx(重定向)- 需要采取进一步措施才能完成请求
    * 4xx(客户端错误)- 请求包含错误的语法或无法满足
    * 5xx(服务器错误)- 服务器无法满足明显有效的请求
- 502和504的区别
    * 502: 作为网关或者代理工作的服务器尝试执行请求时, 从上游服务器接收到无效的响应
    * 504: 作为网关或者代理工作的服务器尝试执行请求时, 未能及时从上游服务器(URI标识出的服务器, 例如HTTP、FTP、LDAP)或者辅助服务器(例如DNS)收到响应
    * 通俗的来说, nginx作为一个代理服务器, 将请求转发到其他服务器或者php-cgi来处理, 当nginx收到了无法理解的响应时, 就返回502. 当nginx超过自己配置的超时时间还没有收到请求时, 就返回504错误
    * 打个比喻, 502是你呼叫对方要东西, 联系上了对方, 但东西不能及时给你504是你呼叫对方要东西, 联系不上对方

##### 关闭TCP连接
- 四次挥手
    * FIN: 是否是终止报文段
    * seq: 发送的第一个字节的序号
    * ACK: 是否是确认报文段
    * ack: 确认号. 希望收到的下一个数据的第一个字节的序号
    * **第一次挥手**: 客户端向服务端发送FIN=1, seq=u
    * **第二次挥手**: 服务端向客户端发送ACK=1, seq=v, ack=u+1
    * **第三次挥手**: 服务端向客户端发送FIN=1, ACK=1, seq=w, ack=u+1
    * **第四次挥手**: 客户端向服务端发送ACK=1, seq=u+1, ack=w+1
- 四次挥手中通信双方状态
    * FIN-WAIT-1: 等待远程TCP的连接中断请求, 或先前的连接中断请求的确认
    * CLOSE-WAIT: 等待从本地用户发来的连接中断请求
    * FIN-WAIT-2: 从远程TCP等待连接中断请求
    * LAST-ACK: 等待原来发向远程TCP的连接中断请求的确认
    * TIME-WAIT: 等待足够的时间以确保远程TCP接收到连接中断请求的确认
- 四次挥手生活版
    * 客户端: “兄弟, 我这边没数据要传了, 咱关闭连接吧. ” -- FIN + seq
    * 服务端: “收到, 我看看我这边有木有数据了. ” -- ACK + seq + ack
    * 服务端: “兄弟, 我这边也没数据要传你了, 咱可以关闭连接了. ” - FIN + ACK + seq + ack
    * 客户端: “好嘞. ” -- ACK + seq + ack

##### 浏览器解析HTML
> 服务器返回 HTML--响应头和数据后, 浏览器的渲染引擎开始解析 HTML

##### 浏览器渲染页面
> 渲染树构建完成后, 进入布局阶段, 布局为每个节点分配一个应出现在屏幕上的确切坐标, 决定了每个元素的宽和高, 以及节点之间的相关性


