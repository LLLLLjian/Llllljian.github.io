---
title: Redis_基础 (18)
date: 2021-10-26
tags: Redis
toc: true
---

### 复习之redis
    从头再看一遍redis

<!-- more -->

#### Redis-唯快不破的秘密
- 引子
    * redis为什么快
    * 因为它是基于内存和单线程模型
    * 还有么
    * emmmmmm 没了
1. 基于内存实现
2. 使用I/O多路复用模型, 非阻塞I/O
3. 单线程模型: 避免了不必要的上下文和竞争条件
4. 高效的数据结构
5. 根据实际数据类型选择合适的数据编码

##### 基于内存实现
> redis是基于内存的数据库, 相比于磁盘型数据库, 少了一步将数据通过IO操作读取到内存的操作, redis将数据存储在内存中, 读写操作不会因为磁盘的IO限制, 所以速度飞一般的感觉

##### IO多路复用
> IO多路复用是一种同步IO模型,实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪,就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序,交出cpu.多路是指网络连接,复用指的是同一个线程

##### 单线程模型
> Redis 的单线程指的是 Redis 的网络 IO 以及键值对指令读写是由一个线程来执行的.  对于 Redis 的持久化、集群数据同步、异步删除等都是其他线程执行
- 多线程的弊端
    * 多线程的优势在于增加系统吞吐量, 充分利用 CPU 资源
    * 弊端在于需要频繁切换上下文, 以及在操作共享数据时为了保证数据的准确性需要加锁带来额外的消耗
- 单线程好处
    * 不会因为线程创建导致的性能消耗；
    * 避免上下文切换引起的 CPU 消耗, 没有多线程切换的开销；
    * 避免了线程之间的竞争问题, 比如添加锁、释放锁、死锁等, 不需要考虑各种锁问题. 
    * 代码更清晰, 处理逻辑简单. 
- 单线程是否没有充分利用CPU资源呢
    * 因为 Redis 是基于内存的操作, CPU 不是 Redis 的瓶颈, Redis 的瓶颈最有可能是机器内存的大小或者网络带宽. 既然单线程容易实现, 而且 CPU 不会成为瓶颈, 那就顺理成章地采用单线程的方案了

##### 高效数据结构
- 常见的数据结构及应用场景
    * String:  缓存、计数器、分布式锁等. 
    * List:  链表、队列、微博关注人时间轴列表等. 
    * Hash:  用户信息、Hash 表等. 
    * Set:  去重、赞、踩、共同好友等. 
    * Zset:  访问量排行榜、点击量排行榜等
- redis整体介绍
    ![Redis全局哈希表](/img/20211026_1.png)
    * Redis 整体就是一个 哈希表来保存所有的键值对, 无论数据类型是 5 种的任意一种. 哈希表, 本质就是一个数组, 每个元素被叫做哈希桶, 不管什么数据类型, 每个桶里面的 entry 保存着实际具体值的指针. 
    * 整个数据库就是一个全局哈希表, 而哈希表的时间复杂度是 O(1), 只需要计算每个键的哈希值, 便知道对应的哈希桶位置, 定位桶里面的 entry 找到对应数据, 这个也是 Redis 快的原因之一
    * redis是怎么解决hash冲突的
        * Redis 通过链式哈希解决冲突: 也就是同一个 桶里面的元素使用链表保存. 但是当链表过长就会导致查找性能变差可能, 所以 Redis 为了追求快, 使用了两个全局哈希表. 用于 rehash 操作, 增加现有的哈希桶数量, 减少哈希冲突. 
        * 开始默认使用 hash 表 1 保存键值对数据, 哈希表 2 此刻没有分配空间. 当数据越来多触发 rehash 操作, 则执行以下操作: 
        * 给 hash 表 2 分配更大的空间；
        * 将 hash 表 1 的数据重新映射拷贝到 hash 表 2 中；
        * 释放 hash 表 1 的空间. 
        * 值得注意的是, 将 hash 表 1 的数据重新映射到 hash 表 2 的过程中并不是一次性的, 这样会造成 Redis 阻塞, 无法提供服务. 
        * 而是采用了渐进式 rehash, 每次处理客户端请求的时候, 先从 hash 表 1 中第一个索引开始, 将这个位置的 所有数据拷贝到 hash 表 2 中, 就这样将 rehash 分散到多次请求过程中, 避免耗时阻塞. 
- redis数据类型和底层数据结构关系
    ![redis数据类型和底层数据结构关系](/img/20211026_2.png)
- SDS简单动态字符
    * redis是使用C语言开发的, 那SDS字符串和C语言字符串结构差别在哪
    ![C语言字符串和SDS简单动态字符](/img/20211026_3.png)
    * O(1) 时间复杂度获取字符串长度
        * C 语言字符串布吉路长度信息, 需要遍历整个字符串时间复杂度为 O(n), C 字符串遍历时遇到 '\0' 时结束. 
        * SDS 中 len 保存这字符串的长度, O(1) 时间复杂度. 
    * 空间预分配
        * SDS 被修改后, 程序不仅会为 SDS 分配所需要的必须空间, 还会分配额外的未使用空间. 分配规则如下: 如果对 SDS 修改后, len 的长度小于 1M, 那么程序将分配和 len 相同长度的未使用空间. 举个例子, 如果 len=10, 重新分配后, buf 的实际长度会变为 10(已使用空间)+10(额外空间)+1(空字符)=21. 如果对 SDS 修改后 len 长度大于 1M, 那么程序将分配 1M 的未使用空间. 
    * 惰性空间释放
        * 当对 SDS 进行缩短操作时, 程序并不会回收多余的内存空间, 而是使用 free 字段将这些字节数量记录下来不释放, 后面如果需要 append 操作, 则直接使用 free 中未使用的空间, 减少了内存的分配. 
    * 二进制安全
        * 在 Redis 中不仅可以存储 String 类型的数据, 也可能存储一些二进制数据. 二进制数据并不是规则的字符串格式, 其中会包含一些特殊的字符如 '\0', 在 C 中遇到 '\0' 则表示字符串的结束, 但在 SDS 中, 标志字符串结束的是 len 属性. 
- linkedList双端列表
    * 双端: 链表节点带有 prev 和 next 指针, 获取某个节点的前置节点和后置节点的复杂度都是 O(1). 
    * 无环: 表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL, 对链表的访问以 NULL 为终点. 
    * 带表头指针和表尾指针: 通过 list 结构的 head 指针和 tail 指针, 程序获取链表的表头节点和表尾节点的复杂度为 O(1). 
    * 带链表长度计数器: 程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数, 程序获取链表中节点数量的复杂度为 O(1). 
    * 多态: 链表节点使用 void* 指针来保存节点值, 并且可以通过 list 结构的 dup、free、match 三个属性为节点值设置类型特定函数, 所以链表可以用于保存各种不同类型的值
    ```bash
        typedef struct list {
            // 表头节点
            listNode * head;
            // 表尾节点
            listNode * tail;
            // 链表所包含的节点数量
            unsigned long len;
            // 节点值复制函数
            void *(*dup)(void *ptr);
            // 节点值释放函数
            void (*free)(void *ptr);
            // 节点值对比函数
            int (*match)(void *ptr,void *key)
        } list;
    ```
- zipList压缩列表
    * 当一个列表只有少量数据的时候, 并且每个列表项要么就是小整数值, 要么就是长度比较短的字符串, 那么 Redis 就会使用压缩列表来做列表键的底层实现. 
    * ziplist 是由一系列特殊编码的连续内存块组成的顺序型的数据结构, ziplist 中可以包含多个 entry 节点, 每个节点可以存放整数或者字符串. 
    * ziplist 在表头有三个字段 zlbytes、zltail 和 zllen, 分别表示列表占用字节数、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend, 表示列表结束
    ```bash
        struct ziplist<T> {
            int32 zlbytes; // 整个压缩列表占用字节数
            int32 zltail_offset; // 最后一个元素距离压缩列表起始位置的偏移量, 用于快速定位到最后一个节点
            int16 zllength; // 元素个数
            T[] entries; // 元素内容列表, 挨个挨个紧凑存储
            int8 zlend; // 标志压缩列表的结束, 值恒为 0xFF
        }
    ```
- intset整数数组
    * 当一个集合只包含整数值元素, 并且这个集合的元素数量不多时, Redis 就会使用整数集合作为集合键的底层实现
    * contents 数组是整数集合的底层实现: 整数集合的每个元素都是 contents 数组的一个数组项(item), 各个项在数组中按值的大小从小到大有序地排列, 并且数组中不包含任何重复项. length 属性记录了整数集合包含的元素数量, 也即是 contents 数组的长度
    ```bash
        typedef struct intset{
            //编码方式
            uint32_t encoding;
            //集合包含的元素数量
            uint32_t length;
            //保存元素的数组
            int8_t contents[];
        }intset;
    ```
- skipList跳跃表
    * sorted set 类型的排序功能便是通过「跳跃列表」数据结构来实现. 跳跃表(skiplist)是一种有序数据结构, 它通过在每个节点中维持多个指向其他节点的指针, 从而达到快速访问节点的目的. 跳跃表支持平均 O(logN)、最坏 O(N)复杂度的节点查找, 还可以通过顺序性操作来批量处理节点. 跳表在链表的基础上, 增加了多层级索引, 通过索引位置的几个跳转, 实现数据的快速定位

##### 合理的数据编码
- Redis 使用对象(redisObject)来表示数据库中的键值
    ```bash
        typedef struct redisObject{
            //类型
            unsigned type:4;
            //编码
            unsigned encoding:4;
            //指向底层数据结构的指针
            void *ptr;
            //...
        }robj;
    ```
- 对于每一种数据类型来说, 底层的支持可能是多种数据结构, 什么时候用哪种数据结构就涉及到了编码转换的问题
    * **String**: 存储数字的话, 采用 int 类型的编码, 如果是非数字的话, 采用 raw 编码；
    * **List**: List 对象的编码可以是 ziplist 或 linkedlist, 字符串长度 < 64 字节且元素个数 < 512 使用 ziplist 编码, 否则转化为 linkedlist 编码；
    * **Hash**: Hash 对象的编码可以是 ziplist 或 hashtable. 当 Hash 对象同时满足以下两个条件时, Hash 对象采用 ziplist 编码: Hash 对象保存的所有键值对的键和值的字符串长度均小于 64 字节. Hash 对象保存的键值对数量小于 512 个. 否则就是 hashtable 编码. 
    * **Set**: Set 对象的编码可以是 intset 或 hashtable, intset 编码的对象使用整数集合作为底层实现, 把所有元素都保存在一个整数集合里面. 保存元素为整数且元素个数小于一定范围使用 intset 编码, 任意条件不满足, 则使用 hashtable 编码
    * **Zset**: Zset 对象的编码可以是 ziplist 或 zkiplist, 当采用 ziplist 编码存储时, 每个集合元素使用两个紧挨在一起的压缩列表来存储. Ziplist 压缩列表第一个节点存储元素的成员, 第二个节点存储元素的分值, 并且按分值大小从小到大有序排列. 当 Zset 对象同时满足一下两个条件时, 采用 ziplist 编码: Zset 保存的元素个数小于 128. Zset 元素的成员长度都小于 64 字节. 如果不满足以上条件的任意一个, ziplist 就会转化为 zkiplist 编码

##### 总结
1. 纯内存操作, 一般都是简单的存取操作, 线程占用的时间很多, 时间的花费主要集中在 IO 上, 所以读取速度快. 
2. 整个 Redis 就是一个全局 哈希表, 他的时间复杂度是 O(1), 而且为了防止哈希冲突导致链表过长, Redis 会执行 rehash 操作, 扩充 哈希桶数量, 减少哈希冲突. 并且防止一次性 重新映射数据过大导致线程阻塞, 采用 渐进式 rehash. 巧妙的将一次性拷贝分摊到多次请求过程后总, 避免阻塞. 
3. Redis 使用的是非阻塞 IO: IO 多路复用, 使用了单线程来轮询描述符, 将数据库的开、关、读、写都转换成了事件, Redis 采用自己实现的事件分离器, 效率比较高. 
4. 采用单线程模型, 保证了每个操作的原子性, 也减少了线程的上下文切换和竞争. 
5. Redis 全程使用 hash 结构, 读取速度快, 还有一些特殊的数据结构, 对数据存储进行了优化, 如压缩表, 对短数据进行压缩存储, 再如, 跳表, 使用有序的数据结构加快读取的速度. 
6. 根据实际存储的数据类型选择不同编码








