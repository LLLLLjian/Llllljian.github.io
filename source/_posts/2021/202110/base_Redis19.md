---
title: Redis_基础 (19)
date: 2021-10-27
tags: Redis
toc: true
---

### 复习之redis
    从头再看一遍redis

<!-- more -->

#### 无畏宕机快速恢复的杀手锏

##### RDB内存快照
> 在 Redis 执行「写」指令过程中, 内存数据会一直变化. 所谓的内存快照, 指的就是 Redis 内存中的数据在某一刻的状态数据. 好比时间定格在某一刻, 当我们拍照的, 通过照片就能把某一刻的瞬间画面完全记录下来. Redis 跟这个类似, 就是把某一刻的数据以文件的形式拍下来, 写到磁盘上. 这个快照文件叫做 RDB 文件, RDB 就是 Redis DataBase 的缩写. Redis 通过定时执行 RDB 内存快照, 这样就不必每次执行「写」指令都写磁盘, 只需要在执行内存快照的时候写磁盘. 既保证了唯快不破, 还实现了持久化, 宕机快速恢复. 

![RDB内存快照](/img/20211027_1.png)
- 生成RDB策略
    * save: 主线程执行, 会阻塞；
    * bgsave: 调用 glibc 的函数fork产生一个子进程用于写入 RDB 文件, 快照持久化完全交给子进程来处理, 父进程继续处理客户端请求, 生成 RDB 文件的默认配置
    * 虽然主线程没有阻塞, 到那时为了保证快照的数据的一致性, 只能处理读操作, 不能修改正在执行快照的数据, Redis 使用操作系统的多进程***写时复制技术 COW(Copy On Write) ***来实现快照持久化
        * bgsave 子进程可以共享主线程的所有内存数据, 读取主线程的数据并写入到 RDB 文件. 在执行 SAVE 命令或者BGSAVE命令创建一个新的 RDB 文件时, 程序会对数据库中的键进行检查, 已过期的键不会被保存到新创建的 RDB 文件中. 当主线程执行写指令修改数据的时候, 这个数据就会复制一份副本,  bgsave 子进程读取这个副本数据写到 RDB 文件, 所以主线程就可以直接修改原来的数据. 这既保证了快照的完整性, 也允许主线程同时对数据进行修改, 避免了对正常业务的影响. Redis 会使用 bgsave 对当前内存中的所有数据做快照, 这个操作是子进程在后台完成的, 这就允许主线程同时可以修改数据. 
        ![写时复制技术](/img/20211027_2.png)
- 但是
    * 过于频繁的执行全量数据快照, 有两个严重性能开销: 1. 频繁生成 RDB 文件写入磁盘, 磁盘压力过大. 会出现上一个 RDB 还未执行完, 下一个又开始生成, 陷入死循环. 2. fork 出 bgsave 子进程会阻塞主线程, 主线程的内存越大, 阻塞时间越长
- 优缺点
    * 快照的恢复速度快, 但是生成 RDB 文件频率不好把握, 频率过低宕机丢失的数据就会比较多；太快, 又会消耗额外开销. 
    * RDB 采用二进制 + 数据压缩的方式写磁盘, 文件体积小, 数据恢复速度快. 

##### AOF写后日志
> AOF 日志存储的是 Redis 服务器的顺序指令序列, AOF 日志只记录对内存进行修改的指令记录. 假设 AOF 日志记录了自 Redis 实例创建以来所有的修改性指令序列, 那么就可以通过对一个空的 Redis 实例顺序执行所有的指令, 也就是「重放」, 来恢复 Redis 当前实例的内存数据结构的状态. 
- 写前与写后日志对比
    * 写前日志(Write Ahead Log, WAL):  在实际写数据之前, 将修改的数据写到日志文件中, 故障恢复得以保证
    * 写后日志:  先执行「写」指令请求, 将数据写入内存, 再记录日志(redis用的这种)
        * 写后日志避免了额外的检查开销, 不需要对执行的命令进行语法检查. 如果使用写前日志的话, 就需要先检查语法是否有误, 否则日志记录了错误的命令, 在使用日志恢复的时候就会出错
        * 写后才记录日志, 不会阻塞当前的「写」指令执行
- AOF写回策略
    * 为了提高文件的写入效率, 当用户调用 write 函数, 将一些数据写入到文件的时候, 操作系统通常会将写入数据暂时保存在一个内存缓冲区里面, 等到缓冲区的空间被填满、或者超过了指定的时限之后, 才真正地将缓冲区中的数据写入到磁盘里面, 这种做法虽然提高了效率, 但也为写入数据带来了安全问题, 因为如果计算机发生停机, 那么保存在内存缓冲区里面的写入数据将会丢失. 为此, 系统提供了fsync和fdatasync两个同步函数, 它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面, 从而确保写入数据的安全性
    * Redis 提供的 AOF 配置项appendfsync写回策略直接决定 AOF 持久化功能的效率和安全性
        * always: 同步写回, 写指令执行完毕立马将 aof_buf缓冲区中的内容刷写到 AOF 文件. 
        * everysec: 每秒写回, 写指令执行完, 日志只会写到 AOF 文件缓冲区, 每隔一秒就把缓冲区内容同步到磁盘. 
        * no:  操作系统控制, 写执行执行完毕, 把日志写到 AOF 文件内存缓冲区, 由操作系统决定何时刷写到磁盘. 
        * 想要获得高性能, 就选择 No 策略
        * 如果想要得到高可靠性保证, 就选择 Always 策略
        * 如果允许数据有一点丢失, 又希望性能别受太大影响的话, 那么就选择 Everysec 策略
- 优缺点
    * 优点: 执行成功才记录日志, 避免了指令语法检查开销. 同时, 不会阻塞当前「写」指令. 
    * 缺点: 由于 AOF 记录的是一个个指令内容, 具体格式请看上面的日志格式. 故障恢复的时候需要执行每一个指令, 如果日志文件太大, 整个恢复过程就会非常缓慢. 
- AOF重写机制
    * Redis 提供了 bgrewriteaof指令用于对 AOF 日志进行瘦身. 其原理就是开辟一个子进程对内存进行遍历转换成一系列 Redis 的操作指令, 序列化到一个新的 AOF 日志文件中. 序列化完毕后再将操作期间发生的增量 AOF 日志追加到这个新的 AOF 日志文件中, 追加完毕后就立即替代旧的 AOF 日志文件了, 瘦身工作就完成了. 
    ![AOF重写机制](/img/20211027_3.png)
    * Q: AOF为什么要重写一个日志而不是共享AOF本身的日志
        * 一个原因是父子进程写同一个文件必然会产生竞争问题, 控制竞争就意味着会影响父进程的性能. 
        * 如果 AOF 重写过程中失败了, 那么原本的 AOF 文件相当于被污染了, 无法做恢复使用. 所以 Redis AOF 重写一个新文件, 重写失败的话, 直接删除这个文件就好了, 不会对原先的 AOF 文件产生影响. 等重写完成之后, 直接替换旧文件即可. 


