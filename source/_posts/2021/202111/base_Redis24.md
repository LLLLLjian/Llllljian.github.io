---
title: Redis_基础 (24)
date: 2021-11-03
tags: Redis
toc: true
---

### 复习之redis
    从面试看redis

<!-- more -->

#### 问题1
- Q
    * redis为什么这么快
- A
    * 基于内存实现
        * Redis是基于内存的数据库, 跟磁盘数据库相比减少了磁盘IO操作
    * 高效的数据结构
        * redis数据类型: String、List、Hash、Set、SortedSet
        * redis底层数据结构: SDS简单动态字符串、linkedlist双端列表、ziplist压缩列表、哈希表、整型数组、skiplist跳表
        * SDS简单动态字符串优势
            * SDS 中 len 保存这字符串的长度, O(1) 时间复杂度查询字符串长度信息. 
            * 空间预分配: SDS 被修改后, 程序不仅会为 SDS 分配所需要的必须空间, 还会分配额外的未使用空间. 
            * 惰性空间释放: 当对 SDS 进行缩短操作时, 程序并不会回收多余的内存空间, 而是使用 free 字段将这些字节数量记录下来不释放, 后面如果需要 append 操作, 则直接使用 free 中未使用的空间, 减少了内存的分配. 
        * zipList 压缩列表
            * 当一个列表只有少量数据的时候, 并且每个列表项要么就是小整数值, 要么就是长度比较短的字符串, 那么 Redis 就会使用压缩列表来做列表键的底层实现
        * skipList 跳跃表
            * 跳跃表(skiplist)是一种有序数据结构, 它通过在每个节点中维持多个指向其他节点的指针, 从而达到快速访问节点的目的. 跳表在链表的基础上, 增加了多层级索引, 通过索引位置的几个跳转, 实现数据的快速定位
        * 整数数组(intset)
            * 当一个集合只包含整数值元素, 并且这个集合的元素数量不多时, Redis 就会使用整数集合作为集合键的底层实现, 节省内存
    * 单线程模型
        * Redis 的单线程指的是 Redis 的网络 IO以及键值对指令读写是由一个线程来执行的
        * Redis 是基于内存的操作, CPU 不是 Redis 的瓶颈, Redis 的瓶颈最有可能是机器内存的大小或者网络带宽. 既然单线程容易实现, 而且 CPU 不会成为瓶颈, 那就顺理成章地采用单线程的方案了
        * 单线程的好处
            * 不会因为线程创建导致的性能消耗；
            * 避免上下文切换引起的 CPU 消耗, 没有多线程切换的开销；
            * 避免了线程之间的竞争问题, 比如添加锁、释放锁、死锁等, 不需要考虑各种锁问题. 
            * 代码更清晰, 处理逻辑简单. 
    * I/O多路复用模型
        * Redis 采用 I/O 多路复用技术, 并发处理连接. 采用了 epoll + 自己实现的简单的事件框架. epoll 中的读、写、关闭、连接都转化成了事件, 然后利用 epoll 的多路复用特性, 绝不在 IO 上浪费一点时间. Redis 线程不会阻塞在某一个特定的监听或已连接套接字上, 也就是说, 不会阻塞在某一个特定的客户端请求处理上. 正因为此, Redis 可以同时和多个客户端连接并处理请求, 从而提升并发性
    * Redis全局hash字典
        * Redis 整体就是一个 哈希表来保存所有的键值对, 无论数据类型是 5 种的任意一种. 哈希表, 本质就是一个数组, 每个元素被叫做哈希桶, 不管什么数据类型, 每个桶里面的 entry 保存着实际具体值的指针. 而哈希表的时间复杂度是 O(1), 只需要计算每个键的哈希值, 便知道对应的哈希桶位置, 定位桶里面的 entry 找到对应数据, 这个也是 Redis 快的原因之一. 

#### 问题2
- Q
    * redis持久化之RDB
- A
    * 内存快照 Redis DataBase
    * 在 Redis 执行「写」指令过程中, 内存数据会一直变化. 所谓的内存快照, 指的就是 Redis 内存中的数据在某一刻的状态数据. RDB就是把某一刻的数据以文件的形式拍下来, 写到磁盘上
    * 优势
        * 数据完整性强, 方便数据恢复
    * 劣势
        * 频繁生成 RDB 文件写入磁盘, 磁盘压力过大. 会出现上一个 RDB 还未执行完, 下一个又开始生成, 陷入死循环. 
        * fork 出 bgsave 子进程会阻塞主线程, 主线程的内存越大, 阻塞时间越长. 

#### 问题3
- Q
    * 在生成 RDB 期间, Redis 可以同时处理写请求么
- A
    * 可以的, Redis 使用操作系统的多进程写时复制技术 COW(Copy On Write) 来实现快照持久化, 保证数据一致性. Redis 在持久化时会调用 glibc 的函数fork产生一个子进程, 快照持久化完全交给子进程来处理, 父进程继续处理客户端请求. 当主线程执行写指令修改数据的时候, 这个数据就会复制一份副本,  bgsave 子进程读取这个副本数据写到 RDB 文件. 这既保证了快照的完整性, 也允许主线程同时对数据进行修改, 避免了对正常业务的影响. 

#### 问题4
- Q
    * redis持久化之AOF
- A
    * AOF 日志记录了自 Redis 实例创建以来所有的修改性指令序列, 那么就可以通过对一个空的 Redis 实例顺序执行所有的指令, 也就是「重放」, 来恢复 Redis 当前实例的内存数据结构的状态. 
    * Redis 提供的 AOF 配置项appendfsync写回策略直接决定 AOF 持久化功能的效率和安全性
        * always: 同步写回, 写指令执行完毕立马将 aof_buf缓冲区中的内容刷写到 AOF 文件. 
        * everysec: 每秒写回, 写指令执行完, 日志只会写到 AOF 文件缓冲区, 每隔一秒就把缓冲区内容同步到磁盘. 
        * no:  操作系统控制, 写执行执行完毕, 把日志写到 AOF 文件内存缓冲区, 由操作系统决定何时刷写到磁盘. 

#### 问题5
- Q
    * 既然 RDB有性能问题, 那为何不用AOF
- A
    * AOF 写前日志, 记录的是每个「写」指令操作. 不会像 RDB 全量快照导致性能损耗, 但是执行速度没有 RDB 快, 同时日志文件过大也会造成性能问题. 所以, Redis 设计了一个杀手锏「AOF 重写机制」, Redis 提供了 bgrewriteaof指令用于对 AOF 日志进行瘦身. 其原理就是开辟一个子进程对内存进行遍历转换成一系列 Redis 的操作指令, 序列化到一个新的 AOF 日志文件中. 序列化完毕后再将操作期间发生的增量 AOF 日志追加到这个新的 AOF 日志文件中, 追加完毕后就立即替代旧的 AOF 日志文件了, 瘦身工作就完成了. 

#### 问题6
- Q
    * 如何实现数据尽可能少丢失又能兼顾性能呢
- A
    * 混合持久化, 重启的时候, 可以先加载 rdb 的内容, 然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放, 重启效率因此大幅得到提升

#### 问题7
- Q
    * 主从之间数据如何保证一致性
- A
    * 为了保证副本数据的一致性, 主从架构采用了读写分离的方式
    * 读操作: 主、从库都可以执行；
    * 写操作: 主库先执行, 之后将写操作同步到从库；

#### 问题8
- Q
    * 主从复制还有其他作用么
- A
    * 故障恢复: 当主节点宕机, 其他节点依然可以提供服务；
    * 负载均衡: Master 节点提供写服务, Slave 节点提供读服务, 分担压力；
    * 高可用基石: 是哨兵和 cluster 实施的基础, 是高可用的基石. 

#### 问题9
- Q
    * 主从复制如何实现的
- A
    * 第一次主从库全量复制；
    * 主从正常运行期间的同步；
    * 主从库间网络断开重连同步. 

#### 问题10
- Q
    * 第一次同步怎么实现
- A
    * 建立连接: 从库会和主库建立连接, 从库执行 replicaof 并发送 psync 命令并告诉主库即将进行同步, 主库确认回复后, 主从库间就开始同步了. 
    * 主库同步数据给从库: master 执行 bgsave命令生成 RDB 文件, 并将文件发送给从库, 同时主库为每一个 slave 开辟一块 replication buffer 缓冲区记录从生成 RDB 文件开始收到的所有写命令. 从库保存 RDB 并清空数据库再加载 RDB 数据到内存中. 
    * 发送 RDB 之后接收到的新写命令到从库: 在生成 RDB 文件之后的写操作并没有记录到刚刚的 RDB 文件中, 为了保证主从库数据的一致性, 所以主库会在内存中使用一个叫 replication buffer 记录 RDB 文件生成后的所有写操作. 并将里面的数据发送到 slave. 

#### 问题11
- Q
    * 主从库间的网络断了咋办？断开后要重新全量复制么
- A
    * 网络断了之后, 主从库会采用增量复制的方式继续同步
    * 增量复制: 用于网络中断等情况后的复制, 只将中断期间主节点执行的写命令发送给从节点, 与全量复制相比更加高效

#### 问题12
- Q
    * 那完成全量同步后, 正常运行过程中如何同步数据呢
- A
    * 当主从库完成了全量复制, 它们之间就会一直维护一个网络连接, 主库会通过这个连接将后续陆续收到的命令操作再同步给从库, 这个过程也称为基于长连接的命令传播, 使用长连接的目的就是避免频繁建立连接导致的开销

#### 问题13
- Q
    * 哨兵集群原理
- A
    * 哨兵是 Redis 的一种运行模式, 它专注于对 Redis 实例(主节点、从节点)运行状态的监控, 并能够在主节点发生故障时通过一系列的机制实现选主及主从切换, 实现故障转移, 确保整个 Redis 系统的可用性. 
    * 哨兵实现的功能
        * 监控: 持续监控 master 、slave 是否处于预期工作状态. 
        * 自动切换主库: 当 Master 运行故障, 哨兵启动自动故障恢复流程: 从 slave 中选择一台作为新 master. 
        * 通知: 让 slave 执行 replicaof , 与新的 master 同步；并且通知客户端与新 master 建立连接. 

#### 问题14
- Q
    * 哨兵之间是如何知道彼此的
- A
    * 哨兵与 master 建立通信, 利用 master 提供发布/订阅机制发布自己的信息

#### 问题15
- Q
    * 哨兵是如何知道 slave 并监控他们的
- A
    * 关键还是利用 master 来实现, 哨兵向 master 发送 INFO 命令,  master 掌门自然是知道自己门下所有的 salve 小弟的. 所以 master 接收到命令后, 便将 slave 列表告诉哨兵. 哨兵根据 master 响应的 slave 名单信息与每一个 salve 建立连接, 并且根据这个连接持续监控哨兵. 

