---
title: Redis_基础 (26)
date: 2021-11-10
tags: Redis
toc: true
---

### 实用之redis
    redis之一致性Hash详解

<!-- more -->

#### 使用场景
> 以Redis为例, 当系统需要缓存的内容超过单机内存大小时, 例如要缓存100G数据, 单机内存仅有16G时. 这时候就需要考虑进行缓存数据分片, 也即是把100G的数据拆分成多块小于单机内存的数据. 例如以10G为单位, 拆分10份, 存储到多台机器节点上.  但是数据怎么个分法更合理呢？ 、f(key)%n这里配置n=10, 不同的key根据数值余数映射到对应的机器.  很简单的办法就解决了多台节点key分法的问题. 然而数据大小的增长和缩减是很难预知的,  如果需要增加一台缓存服务器.  配置n=11, 会发现之前根据余数建立的映射关系发生混乱. 映射错乱后, 就会发生大量key无法命中正确的节点, 需要全部重新进行映射.   如果以后再添加节点, 同样会遇到这样问题
- code
    ```bash
        servers = ['redis:6379', 'redis:6380', 'redis:6381']
        server =  servers[f(key) % servers.length]
    ```

#### 算法原理
- 空间归属
    * 我们在脑中假想下: 每台节点以CHash(ip)形式计算出一个数值, n台机器有n个数值.  把数值首尾相连, 形成一个虚拟圆环的数值空间. 
    ```bash
        servers =['redis:6379', 'redis:6380', 'redis:6381']. 
        CHash(server[0])==100
        Chash(server[1])==200
        CHash(server[2])==300

        # 100~200空间属于6379管
        # 200~300空间属于6380管
        # 300+,100-空间属于6381管
    ```
- key坐标
    ```bash
        # 这时有3个key要存储到redis, 分别是key1—key3.  通过CHash函数计算出3个key的数值坐标: 
        CHash(key1)=102
        CHash(key2)=240
        CHash(key3)=350
    ```
- 空间映射
    * 求出key的数值坐标后, 就知道key与机器节点的映射关系.  即key1应存储在6379, key3存储到6381
- 添加节点
    ```bash
        # 由于缓存数据的增加, 需要添加一台新节点6382. 计算出空间数值
        CHash(6382)==250

        # 100~200空间属于6379管
        # 200~250空间属于6382管
        # 250~300空间属于6380管
        # 300+,100-空间属于6381管
    ```
    * 优势
        * 对现有缓存的命中影响较小
        * 实现对数据的分片
- 移除节点
    * 与添加节点同理. 比如拿掉新加的6382, 250~300区域还管原来的6380管, 当然6382这部分缓存也就丢了

#### 虚拟节点
> 一致性Hash虽然实现了数据分片, 但由于节点较少, key有可能会大量集中到某一台上面, 导致缓存分布不均匀.  特别是在只有几台或十几台机器节点时. 为了降低这种影响, 一致性hash算法提出虚拟节点的解决方案.  即一个物理机器节点对应着多个虚拟节点. 
- code
    ```bash
        6379={6379A, 6379B}
        6380={6380A, 6380B}
        6381={6381A, 6381B}

        CHash(6379A) = 100
        CHash(6379B) = 150
        ......
    ```
- 虚拟节点使key分布的更加均衡, 但不能解决添加机、删除节点带来的影响



