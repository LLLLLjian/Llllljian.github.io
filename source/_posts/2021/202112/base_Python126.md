---
title: Python_基础 (126)
date: 2021-12-10
tags: Python
toc: true
---

### python垃圾回收
    写代码不注意, 导致内存老超, 得看看垃圾回收

<!-- more -->

#### 概述
> 无论何种垃圾收集机制, 一般都是两阶段: 垃圾检测和垃圾回收.

##### 引用计数(主要)

Python主要依靠gc(garbage collector)模块的引用计数技术来进行垃圾回收.
引用计数, 就是考虑到Python中变量的本质不是内存中一块存储数据的区域, 而是对一块内存数据区域的引用.

python给所有的对象(内存中的区域)维护一个引用计数的属性, 在一个引用被创建或复制的时候, 让python把相关对象的引用计数+1；相反当引用被销毁的时候就把相关对象的引用计数-1.

当对象的引用计数减到0时, 认为整个python中不会再有变量引用这个对象, 就把这个对象所占据的内存空间释放出来.

通过sys.getrefcount(obj)对象可以获得一个对象的引用数目.


##### 标记清除

“标记-清除”是为了解决循环引用的问题.可以包含其他对象引用的容器对象(比如：list, set, dict, class, instance)都可能产生循环引用.

##### 分代收集(辅助)

将系统中的所有内存块根据其存活时间划分为不同的集合, 每一个集合就成为一个“代”, 垃圾收集的频率随着“代”的存活时间的增大而减小.也就是说, 活得越长的对象, 就越不可能是垃圾, 就应该减少对它的垃圾收集频率.

##### 常用函数

这里的gc(garbage collector)是Python 标准库, 通过这个module, 可以开关gc、调整垃圾回收的频率、输出调试信息.gc模块是很多其他模块(比如objgraph)封装的基础, 在这里先介绍gc的核心API.

gc.enable(); gc.disable(); gc.isenabled()
开启gc(默认情况下是开启的)；关闭gc；判断gc是否开启

gc.collection()
执行一次垃圾回收, 不管gc是否处于开启状态都能使用

gc.set_threshold(t0, t1, t2); gc.get_threshold()
设置垃圾回收阈值； 获得当前的垃圾回收阈值

注意：gc.set_threshold(0)也有禁用gc的效果

gc.get_objects()
返回所有被垃圾回收器(collector)管理的对象.这个函数非常基础！只要python解释器运行起来, 就有大量的对象被collector管理, 因此, 该函数的调用比较耗时！

gc.get_referents(*obj)
返回obj对象直接指向的对象

gc.get_referrers(*obj)
返回所有直接指向obj的对象

gc.set_debug(flags)
设置调试选项, 非常有用, 常用的flag组合包含以下

gc.DEBUG_COLLETABLE： 打印可以被垃圾回收器回收的对象

gc.DEBUG_UNCOLLETABLE： 打印无法被垃圾回收器回收的对象, 即定义了__del__的对象

gc.DEBUG_SAVEALL：当设置了这个选项, 可以被拉起回收的对象不会被真正销毁(free), 而是放到gc.garbage这个列表里面, 利于在线上查找问题

##### 优缺点

引用计数技术在每次引用创建和销毁时都要多做一些操作, 这可能是一个小缺点, 当创建和销毁很频繁的时候难免带来一些效率上的不足.但是其最大的好处就是实时性, 其他语言当中, 垃圾回收可能只能在一些固定的时间点上进行, 比如当内存分配失败的时候进行垃圾回收, 而引用计数技术可以动态地进行内存的管理.

