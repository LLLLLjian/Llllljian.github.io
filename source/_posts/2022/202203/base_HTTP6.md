---
title: HTTP基础 (6)
date: 2022-03-11
tags: HTTP
toc: true
---

### 图解网络读书笔记
    记录一下看书的笔记 

<!-- more -->

#### 带着问题来看书
> TCP 三次握手和四次挥手
TCP 的重传机制、滑动窗口、流量控制、拥塞控制

#### TCP的基本认识
- 为什么需要TCP协议, TCP工作在哪一层
    * IP 层是「不可靠」的,它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据 的完整性.
    * 如果需要保障网络数据包的可靠性,那么就需要由上层(传输层)的 TCP 协议来负责.
    * 引入一下 TCP/IP四层
        * 应用层
        * 传输层
        * 网络层
        * 网络接口层
    * 引入一下 OSI七层
        * 应用层
        * 表示层
        * 会话层
        * 传输层
        * 网络层
        * 数据链路层
        * 物理层
- 什么是TCP
    * TCP 是面向连接的、可靠的、基于字节流的传输层通信协议.
    * **面向连接**:一定是「一对一」才能连接,不能像 UDP 协议可以一个主机同时向多个主机发送消 息,也就是一对多是无法做到的;
    * **可靠的**:无论的网络链路中出现了怎样的链路变化,TCP 都可以保证一个报文一定能够到达接收 端;
    * **字节流**:消息是「没有边界」的,所以无论我们消息有多大都可以进行传输.并且消息是「有序 的」,当「前一个」消息没有收到的时候,即使它先收到了后面的字节,那么也不能扔给应用层 去处理,同时对「重复」的报文会自动丢弃.
- 什么是TCP连接
    * 用于保证可靠性和流量控制维护的某些状态信息,这些信息的组合,包括Socket、序列 号和窗口大小称为连接.
- TCP和UDP区别
    * 连接
        * TCP是面向连接的传输层协议,传输数据前先要建立连接.
        * UDP是不需要连接,即刻传输数据
    * 服务对象
        * TCP 是一对一的两点服务,即一条连接只有两个端点.
        * UDP 支持一对一、一对多、多对多的交互通信
    * 可靠性
        * TCP是可靠交付数据的,数据可以无差错、不丢失、不重复、按需到达
        * UDP是尽最大努力交付,不保证可靠交付数据
    * 拥塞控制、流量控制
        * TCP有拥塞控制和流量控制机制,保证数据传输的安全性
        * UDP则没有,即使网络非常拥堵了,也不会影响 UDP 的发送速率
    * 首部开销
        * TCP 首部长度较长,会有一定的开销,首部在没有使用「选项」字段时是 用了「选项」字段则会变长的
        * UDP 首部只有 8 个字节,并且是固定不变的,开销较小
    * 传输方式
        * TCP 是流式传输,没有边界,但保证顺序和可靠
        * UDP 是一个包一个包的发送,是有边界的,但可能会丢包和乱序
    * 分片不同
        * TCP 的数据大小如果大于 MSS 大小,则会在传输层进行分片,目标主机收到后,也同样在传输 层组装 TCP 数据包,如果中途丢失了一个分片,只需要传输丢失的这个分片.
        * UDP 的数据大小如果大于 MTU 大小,则会在 IP 层进行分片,目标主机收到后,在 IP 层组装完 数据,接着再传给传输层,但是如果中途丢了一个分片,则就需要重传所有的数据包,这样传输 效率非常差,所以通常 UDP 的报文应该小于 MTU.
- TCP和UDP应用场景
    * TCP
        * FTP 文件传输
        * HTTP / HTTPS
    * UDP
        * 包总量较少的通信,如 DNS 、 SNMP 等
        * 视频、音频等多媒体通信
        * 广播通信

#### TCP连接建立
- TCP三次握手过程
    * 一开始,客户端和服务端都处于 CLOSED 状态.先是服务端主动监听某个端口,处于 LISTEN 状态
    * 客户端会随机初始化序号( client_isn ),将此序号置于 TCP 首部的「序号」字段中,同时把 SYN 标志位置为 1 ,表示 SYN 报文.接着把第一个 SYN 报文发送给服务端,表示向服务端发起连接,该报文不包含应用层数据,之后客户端处于 SYN-SENT 状态.
    * 服务端收到客户端的 SYN 报文后,首先服务端也随机初始化自己的序号( ),将此 序号填入 TCP 首部的「序号」字段中,其次把 TCP 首部的「确认应答号」字段填入1 , 接着把 SYN 和 ACK 标志位置为 1 .最后把该报文发给客户端,该报文也不包含应用层 数据,之后服务端处于 SYN-RCVD 状态.
    * 客户端收到服务端报文后,还要向服务端回应最后一个应答报文,首先该应答报文 TCP 首部 ACK 标志位置为 1 ,其次「确认应答号」字段填入 ,最后把报文发送给服务端,这次报文可以携带客户到服务器的数据,之后客户端处于 状态.
    * 服务器收到客户端的应答报文后,也进入 ESTABLISHED 状态.
- 为什么是三次握手
    * 三次握手才可以阻止重复历史连接的初始化(主要原因)
    * 三次握手才可以同步双方的初始序列号
    * 三次握手才可以避免资源浪费
- 不使用「两次握手」和「四次握手」的原因:
    * 「两次握手」:无法防止历史连接的建立,会造成双方资源的浪费,也无法可靠的同步双方序列号;
    * 「四次握手」:三次握手就已经理论上最少可靠连接建立,所以不需要使用更多的通信次数.

#### TCP连接断开
- TCP四次挥手过程
    * 客户端打算关闭连接,此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文,也即 FIN报文,之后客户端进入 FIN_WAIT_1 状态.
    * 服务端收到该报文后,就向客户端发送 ACK 应答报文,接着服务端进入 CLOSED_WAIT 状 态.
    * 客户端收到服务端的 ACK 应答报文后,之后进入 FIN_WAIT_2 状态
    * 等待服务端处理完数据后,也向客户端发送 FIN 报文,之后服务端进入 LAST_ACK 状态
    * 客户端收到服务端的 FIN 报文后,回一个 ACK 应答报文,之后进入 TIME_WAIT 状态
    * 服务器收到了 ACK 应答报文后,就进入了 CLOSED 状态,至此服务端已经完成连接的关闭
    * 客户端在经过 2MSL 一段时间后,自动进入 CLOSED 状态,至此客户端也完成连接的关闭.
- 为什么是四次挥手
    * 关闭连接时,客户端向服务端发送 FIN 时,仅仅表示客户端不再发送数据了但是还能接收数 据.
    * 服务器收到客户端的 FIN 报文时,先回一个 ACK 应答报文,而服务端可能还有数据需要处理 和发送,等服务端不再发送数据时,才发送 FIN 报文给客户端来表示同意现在关闭连接.
- 为什么TIME_WAIT等待的时间是2MSL
    * MSL 是 Maximum Segment Lifetime,报文最大生存时间
    * 2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的.如果在 TIME-WAIT 时间内,因为客 户端的 ACK 没有传输到服务端,客户端又接收到了服务端重发的 FIN 报文,那么 2MSL 时间将重新计时.
- 为什么需要TIME_WAIT状态
    * 防止具有相同「四元组」的「旧」数据包被收到;
    * 保证「被动关闭连接」的一方能被正确的关闭,即保证最后的 ACK 能让被动关闭方接收,从而帮 助其正常关闭;

#### 重传机制
- 超时重传
    * 在发送数据时,设定一个定时器,当超过指定的时间后,没有收到对方 的 ACK 确认应答报文,就会重发该数据
- 快速重传
    * 当收到三个相同的 ACK 报文时,会在定时器过期之前,重传丢失的报文段.
- SACK
    * 在 TCP 头部「选项」字段里加一个 SACK 的东西,它可以将缓存的地图发送给发送 方,这样发送方就可以知道哪些数据收到了,哪些数据没收到,知道了这些信息,就可以只重传丢失的 数据.
- D-SACK
    * 使用了 SACK 来告诉「发送方」有哪些数据被重复接收了

#### 滑动窗口
> 窗口大小就是指无需等待确认应答,而可以继续发送数据的最大值.
通常窗口的大小是由接收方的窗口大小来决定的
- 发送窗口
    * ![发送窗口](/img/20220314_1.png)
    * #1 是已发送并收到 ACK确认的数据:1~31 字节
    * #2 是已发送但未收到 ACK确认的数据:32~45 字节
    * #3 是未发送但总大小在接收方处理范围内(接收方还有空间):46~51字节
    * #4 是未发送但总大小超过接收方处理范围(接收方没有空间):52字节以后
- 接收窗口
    * ![接收窗口](/img/20220314_2.png)
    * #1 + #2 是已成功接收并确认的数据(等待应用进程读取)
    * #3 是未收到数据但可以接收的数据
    * #4 未收到数据并不可以接收的数据

#### 流量控制
> 避免「发送方」的数据填满「接收方」的缓存
- 操作系统缓冲区与滑动窗口的关系
    * 为了防止这种情况发生,TCP 规定是不允许同时减少缓存又收缩窗口的,而是采用先收缩窗口,过段时 间再减少缓存,这样就可以避免了丢包情况.
- 窗口关闭
    * 如果窗口大小为 0 时,就会阻止发送方给接收方传递数据,直到窗口变为非 0 为止,这就是窗口关闭
- 糊涂窗口综合症
    * 如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口,而发送方会义无反顾地发送这
几个字节,这就是糊涂窗口综合症

#### 拥塞控制
> 避免「发送方」的数据填满整个网络
- 慢启动
    * 当发送方每收到一个 ACK,拥塞窗口 cwnd 的大小就会加 1
- 拥塞避免
    * 每当收到一个 ACK 时,cwnd 增加 1/cwnd
- 拥塞发生
- 快速恢复
