---
title: Interview_总结 (146)
date: 2022-03-25
tags: Interview
toc: true
---

### 面试题
    别看了 这就是你的题

<!-- more -->

#### 进程/线程/协程
- 进程
    * 进程(Process)是计算机中的程序关于某数据集合上的一次运行活动,是系统进行资源分配和调度的基本单位,是操作系统结构的基础.进程是一个“执行中的程序”
- 线程
    * 有时被称为轻量进程(lightweight processes),是程序执行流的最小单元.线程是独立调度和分派的基本单位.一个进程可以有很多线程,每条线程并行执行不同的任务.
- 线程与进程的区别
    1. 进程是资源分配的最小单位,线程是程序执行的最小单位(资源调度的最小单位)
    2. 进程有自己的独立地址空间,每启动一个进程,系统就会为它分配地址空间,建立数据表来维护代码段、堆栈段和数据段,这种操作非常昂贵.而线程是共享进程中的数据的,使用相同的地址空间,因此CPU切换一个线程的花费远比进程要小很多,同时创建一个线程的开销也比进程要小很多.
    3. 线程之间的通信更方便,同一进程下的线程共享全局变量、静态变量等数据,而进程之间的通信需要以通信的方式(IPC)进行.不过如何处理好同步与互斥是编写多线程程序的难点.
    4. 但是多进程程序更健壮,多线程程序只要有一个线程死掉,整个进程也死掉了,而一个进程死掉并不会对另外一个进程造成影响,因为进程有自己独立的地址空间.
- 线程与协程的区别
    1. 一个线程可以多个协程,一个进程也可以单独拥有多个协程
    2. 线程进程都是同步机制,而协程则是异步
    3. 协程能保留上一次调用的状态,每次过程重入时,就相当于进入上一次调用的状态

#### 问题1
- Q
    * 什么是四次挥手
- A
    * ![四次挥手](/img/20191120_1.png)
    * 我要和你断开链接；好的, 断吧.我也要和你断开链接；好的, 断吧
    * 第一次挥手: Client将FIN置为1, 发送一个序列号seq给Server；进入FIN_WAIT_1状态；
    * 第二次挥手: Server收到FIN之后, 发送一个ACK=1, acknowledge number=收到的序列号+1；进入CLOSE_WAIT状态.此时客户端已经没有要发送的数据了, 但仍可以接受服务器发来的数据.
    * 第三次挥手: Server将FIN置1, 发送一个序列号给Client；进入LAST_ACK状态；
    * 第四次挥手: Client收到服务器的FIN后, 进入TIME_WAIT状态；接着将ACK置1, 发送一个acknowledge number=序列号+1给服务器；服务器收到后, 确认acknowledge number后, 变为CLOSED状态, 不再向客户端发送数据.客户端等待2*MSL(报文段最长寿命)时间后, 也进入CLOSED状态.完成四次挥手.

#### 问题2
- Q
    * 问题1扩展, 为什么不能把服务器发送的ACK和FIN合并起来, 变成三次挥手(CLOSE_WAIT状态意义是什么)
- A
    * 因为服务器收到客户端断开连接的请求时, 可能还有一些数据没有发完, 这时先回复ACK, 表示接收到了断开连接的请求.等到数据发完之后再发FIN, 断开服务器到客户端的数据传送.

#### 问题3
- Q
    * 问题1扩展, 如果第二次挥手时服务器的ACK没有送达客户端, 会怎样
- A
    * 客户端没有收到ACK确认, 会重新发送FIN请求.

#### 问题4
- Q
    * 客户端TIME_WAIT状态的意义是什么
- A
    * 第四次挥手时, 客户端发送给服务器的ACK有可能丢失, TIME_WAIT状态就是用来重发可能丢失的ACK报文.如果Server没有收到ACK, 就会重发FIN, 如果Client在2*MSL的时间内收到了FIN, 就会重新发送ACK并再次等待2MSL, 防止Server没有收到ACK而不断重发FIN.

#### 问题5
- Q
    * 什么是三次握手
- A
    * ![三次握手](/img/20191119_1.png)
    * 我要和你建立链接, 你真的要和我建立链接么, 我真的要和你建立链接, 成功
    * 第一次握手: Client将SYN置1, 随机产生一个初始序列号seq发送给Server, 进入SYN_SENT状态；
    * 第二次握手: Server收到Client的SYN=1之后, 知道客户端请求建立连接, 将自己的SYN置1, ACK置1, 产生一个acknowledge number=sequence number+1, 并随机产生一个自己的初始序列号, 发送给客户端；进入SYN_RCVD状态；
    * 第三次握手: 客户端检查acknowledge number是否为序列号+1, ACK是否为1, 检查正确之后将自己的ACK置为1, 产生一个acknowledge number=服务器发的序列号+1, 发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后, 也进入ESTABLISHED状态；完成三次握手, 连接建立.

#### 问题6
- Q
    * 扩展问题1, TCP建立连接可以两次握手吗 为什么
- A
    * 不可以.可能会出现以下情况: 已失效的连接请求报文段又传到了服务器端.
    * client 发出的第一个连接请求报文段并没有丢失, 而是在某个网络结点长时间的滞留了, 以致延误到连接释放以后的某个时间才到达 server.本来这是一个早已失效的报文段.但 server 收到此失效的连接请求报文段后, 就误认为是 client 再次发出的一个新的连接请求.于是就向 client 发出确认报文段, 同意建立连接.假设不采用 “三次握手”, 那么只要 server 发出确认, 新的连接就建立了.由于现在 client 并没有发出建立连接的请求, 因此不会理睬 server 的确认, 也不会向 server 发送数据.但 server 却以为新的运输连接已经建立, 并一直等待 client 发来数据.这样, server 的很多资源就白白浪费掉了.采用 “三次握手” 的办法可以防止上述现象发生.例如刚才那种情况, client 不会向 server 的确认发出确认.server 由于收不到确认, 就知道 client 并没有要求建立连接.

#### 问题7
- Q
    * 扩展问题1, TCP建立连接可以采用四次握手吗？为什么？
- A
    * 可以.但是会降低传输的效率.
    * 四次握手是指: 第二次握手: Server只发送ACK和acknowledge number；而Server的SYN和初始序列号在第三次握手时发送；原来协议中的第三次握手变为第四次握手.出于优化目的, 四次握手中的二、三可以合并.

#### 问题8
- Q
    * 第三次握手中, 如果客户端的ACK未送达服务器, 会怎样
- A
    * 由于Server没有收到ACK确认, 因此会重发之前的SYN+ACK(默认重发五次, 之后自动关闭连接), Client收到后会重新传ACK给Server.如果Client向服务器发送数据, 服务器会以RST包响应.

#### PHP依赖注入原理与用法
> 处理类与类之间的依赖关系
- 方案1
    ```php
        <?php
        class A
        {
            public function __construct()
            {
                $b = new B();
            }
        }
    ```
- 方案2
    ```php
        <?php
        class A
        {
            public function __construct(B $b)
            {
            }
        }
    ```
- 方案3
    ```php
        <?php
        class A
        {
            public function setB(B $b)
            {
                $this->b = $b;
            }
        }
    ```
- 一个简单的依赖注入的例子
    ```php
        <?php
        class Container {
            private $s=array();
            function __set($k, $c)
            {
                $this->s[$k]=$c;
            }
            function __get($k)
            {
                return $this->s[$k]($this);
            }
        }

        $c = new Container();
        $c->setB(new B());
    ```





