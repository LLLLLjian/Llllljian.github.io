---
title: Interview_总结 (148)
date: 2022-04-11
tags: Interview
toc: true
---

### 面试题
    别看了 这就是你的题
    操作系统

<!-- more -->

#### 进程和线程有什么区别
1. 进程(Process)是系统进行资源分配和调度的基本单位,线程(Thread)是CPU调度和分派的基本单位；
2. 线程依赖于进程而存在,一个进程至少有一个线程；
3. 进程有自己的独立地址空间,线程共享所属进程的地址空间；
4. 进程是拥有系统资源的一个独立单位,而线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),和其他线程共享本进程的相关资源如内存、I/O、cpu等；
5. 在进程切换时,涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置,而线程切换只需保存和设置少量的寄存器的内容,并不涉及存储器管理方面的操作,可见,进程切换的开销远大于线程切换的开销；
6. 线程之间的通信更方便,同一进程下的线程共享全局变量等数据,而进程之间的通信需要以进程间通信(IPC)的方式进行；
7. 多线程程序只要有一个线程崩溃,整个程序就崩溃了,但多进程程序中一个进程崩溃并不会对其它进程造成影响,因为进程有自己的独立地址空间,因此多进程更加健壮

#### 同一进程中的线程可以共享哪些数据
1. 进程代码段
2. 进程的公有数据(全局变量、静态变量...)
3. 进程打开的文件描述符
4. 进程的当前目录
5. 信号处理器/信号处理函数：对收到的信号的处理方式
6. 进程ID与进程组ID

#### 线程独占哪些资源
1. 线程ID
2. 一组寄存器的值
3. 线程自身的栈(堆是共享的)
4. 错误返回码：线程可能会产生不同的错误返回码,一个线程的错误返回码不应该被其它线程修改；
5. 信号掩码/信号屏蔽字(Signal mask)：表示是否屏蔽/阻塞相应的信号(SIGKILL,SIGSTOP除外)

#### 进程间通信有哪些方式
1. 管道(Pipe)
2. 命名管道
3. 消息队列
4. 信号(Signal)
5. 共享内存
6. 信号量(Semaphore)：初始化操作、P操作、V操作；P操作：信号量-1,检测是否小于0,小于则进程进入阻塞状态；V操作：信号量+1,若小于等于0,则从队列中唤醒一个等待的进程进入就绪态
7. 套接字(Socket)

#### 什么是协程？

协程是一种用户态的轻量级线程,协程的调度完全由用户控制.协程拥有自己的寄存器上下文和栈.协程调度切换时,将寄存器上下文和栈保存到其他地方,在切回来的时候,恢复先前保存的寄存器上下文和栈,直接操作栈则基本没有内核切换的开销,可以不加锁的访问全局变量,所以上下文的切换非常快.

#### 什么是IO多路复用？怎么实现
> IO多路复用(IO Multiplexing)是指单个进程/线程就可以同时处理多个IO请求
- 实现原理
    * 用户将想要监视的文件描述符(File Descriptor)添加到select/poll/epoll函数中,由内核监视,函数阻塞.一旦有文件描述符就绪(读就绪或写就绪),或者超时(设置timeout),函数就会返回,然后该进程可以进行相应的读/写操作.

#### select/poll/epoll三者的区别
- select
    * 将文件描述符放入一个集合中,调用select时,将这个集合从用户空间拷贝到内核空间(缺点1：每次都要复制,开销大),由内核根据就绪状态修改该集合的内容.(缺点2)集合大小有限制,32位机默认是1024(64位：2048)；采用水平触发机制.select函数返回后,需要通过遍历这个集合,找到就绪的文件描述符(缺点3：轮询的方式效率较低),当文件描述符的数量增加时,效率会线性下降；
- poll
    * 和select几乎没有区别,区别在于文件描述符的存储方式不同,poll采用链表的方式存储,没有最大存储数量的限制；
- epoll
    * 通过内核和用户空间共享内存,避免了不断复制的问题；支持的同时连接数上限很高(1G左右的内存支持10W左右的连接数)；文件描述符就绪时,采用回调机制,避免了轮询(回调函数将就绪的描述符添加到一个链表中,执行epoll_wait时,返回这个链表)；支持水平触发和边缘触发,采用边缘触发机制时,只有活跃的描述符才会触发回调函数.

#### IO多路复用的三种实现方式
1. select
    * 单个进程所打开的FD是有限制的,通过FD_SETSIZE设置,默认1024
    * 每次调用select,都需要把fd集合从用户态拷贝到内核态,这个开销在fd很多时会很大
    * 对socket扫描时是线性扫描,采用轮询的方法,效率较低(高并发时)
2. poll
    * poll与select相比,只是没有fd的限制,其它基本一样
3. epoll
    * 只能运行在linux系统下

#### 什么是用户态和内核态？

为了限制不同程序的访问能力,防止一些程序访问其它程序的内存数据,CPU划分了用户态和内核态两个权限等级.

用户态只能受限地访问内存,且不允许访问外围设备,没有占用CPU的能力,CPU资源可以被其它程序获取；

内核态可以访问内存所有数据以及外围设备,也可以进行程序的切换.
所有用户程序都运行在用户态,但有时需要进行一些内核态的操作,比如从硬盘或者键盘读数据,这时就需要进行系统调用,使用陷阱指令,CPU切换到内核态,执行相应的服务,再切换为用户态并返回系统调用的结果.

#### 为什么要分用户态和内核态？
- 安全性
    * 防止用户程序恶意或者不小心破坏系统/内存/硬件资源；
- 封装性
    * 用户程序不需要实现更加底层的代码；
- 利于调度
    * 如果多个用户程序都在等待键盘输入,这时就需要进行调度；统一交给操作系统调度更加方便.

#### 如何从用户态切换到内核态
- 系统调用
    * 比如读取命令行输入.本质上还是通过中断实现
- 用户程序发生异常时
    * 比如缺页异常
- 外围设备的中断
    * 外围设备完成用户请求的操作之后,会向CPU发出中断信号,这时CPU会转去处理对应的中断处理程序

#### 什么是死锁？

在两个或者多个并发进程中,每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源,在未改变这种状态之前都不能向前推进,称这一组进程产生了死锁(deadlock).

#### 死锁产生的必要条件？
- 互斥
    * 一个资源一次只能被一个进程使用；
- 占有并等待
    * 一个进程至少占有一个资源,并在等待另一个被其它进程占用的资源；
- 非抢占
    * 已经分配给一个进程的资源不能被强制性抢占,只能由进程完成任务之后自愿释放；
- 循环等待
    * 若干进程之间形成一种头尾相接的环形等待资源关系,该环路中的每个进程都在等待下一个进程所占有的资源.

#### 破坏死锁
- 破坏互斥条件
    * 允许某些资源同时被多个进程访问.但是有些资源本身并不具有这种属性,因此这种方案实用性有限；
- 破坏占有并等待条件：
    * 实行资源预先分配策略(当一个进程开始运行之前,必须一次性向系统申请它所需要的全部资源,否则不运行)；
    * 或者只允许进程在没有占用资源的时候才能申请资源(申请资源前先释放占有的资源)；
    * 缺点：很多时候无法预知一个进程所需的全部资源；同时,会降低资源利用率,降低系统的并发性；
- 破坏非抢占条件
    * 允许进程强行抢占被其它进程占有的资源.会降低系统性能；
- 破坏循环等待条件
    * 对所有资源统一编号,所有进程对资源的请求必须按照序号递增的顺序提出,即只有占有了编号较小的资源才能申请编号较大的资源.这样避免了占有大号资源的进程去申请小号资源.


