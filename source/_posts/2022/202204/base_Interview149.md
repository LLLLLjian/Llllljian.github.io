---
title: Interview_总结 (149)
date: 2022-04-12
tags: Interview
toc: true
---

### 面试题
    别看了 这就是你的题
    数据库

<!-- more -->

#### 事务的概念和特性
- 概念
    * 事务(Transaction)是一个操作序列,不可分割的工作单位,以BEGIN TRANSACTION开始,以ROLLBACK/COMMIT结束
    * 通俗来说, 要么都成功,要么都不成功
- 特性
    * 原子性(Atomicity)
        * 逻辑上是不可分割的操作单元,事务的所有操作要么全部提交成功,要么全部失败回滚(用回滚日志实现,反向执行日志中的操作)；
    * 一致性(Consistency)
        * 事务的执行必须使数据库保持一致性状态.在一致性状态下,所有事务对一个数据的读取结果都是相同的；
    * 隔离性(Isolation)
        * 一个事务所做的修改在最终提交以前,对其它事务是不可见的(并发执行的事务之间不能相互影响)；
    * 持久性(Durability)
        * 一旦事务提交成功,对数据的修改是永久性的

#### 会出现哪些并发一致性问题
- 丢失修改
    * 一个事务对数据进行了修改,在事务提交之前,另一个事务对同一个数据进行了修改,覆盖了之前的修改；
- 脏读(Dirty Read)
    * 一个事务读取了被另一个事务修改、但未提交(进行了回滚)的数据,造成两个事务得到的数据不一致；
- 不可重复读(Nonrepeatable Read)
    * 在同一个事务中,某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据,发现数据已经发生修改(针对update操作)；
- 幻读(Phantom Read)
    * 当同一查询多次执行时,由于其它事务在这个数据范围内执行了插入操作,会导致每次返回不同的结果集(和不可重复读的区别：针对的是一个数据整体/范围；并且针对insert操作)

#### 数据库的四种隔离级别
- 未提交读(Read Uncommited)
    * 在一个事务提交之前,它的执行结果对其它事务也是可见的.会导致脏读、不可重复读、幻读；
- 提交读(Read Commited)
    * 一个事务只能看见已经提交的事务所作的改变.可避免脏读问题；
- 可重复读(Repeatable Read)
    * 可以确保同一个事务在多次读取同样的数据时得到相同的结果.(MySQL的默认隔离级别).可避免不可重复读；
- 可串行化(Serializable)
    * 强制事务串行执行,使之不可能相互冲突,从而解决幻读问题.可能导致大量的超时现象和锁竞争,实际很少使用.

#### 锁
- 悲观锁
    * 认为数据随时会被修改,因此每次读取数据之前都会上锁,防止其它事务读取或修改数据；应用于数据更新比较频繁的场景；
- 乐观锁
    * 操作数据时不会上锁,但是更新时会判断在此期间有没有别的事务更新这个数据,若被更新过,则失败重试；适用于读多写少的场景.乐观锁的实现方式有：
        * 加一个版本号或者时间戳字段,每次数据更新时同时更新这个字段；
        * 先读取想要更新的字段或者所有字段,更新的时候比较一下,只有字段没有变化才进行更新
- 排它锁(Exclusive Lock)/ X锁
    * 事务对数据加上X锁时,只允许此事务读取和修改此数据,并且其它事务不能对该数据加任何锁；
- 共享锁(Shared Lock)/ S锁
    * 加了S锁后,该事务只能对数据进行读取而不能修改,并且其它事务只能加S锁,不能加X锁

#### 什么是 MVCC？
> 多版本并发控制(Multi-Version Concurrency Control, MVCC),MVCC在每行记录后面都保存有两个隐藏的列,用来存储创建版本号和删除版本号.
- 创建版本号
    * 创建一个数据行时的事务版本号(事务版本号：事务开始时的系统版本号；系统版本号：每开始一个新的事务,系统版本号就会自动递增)；
- 删除版本号
    * 删除操作时的事务版本号；
- 各种操作
    * 插入操作时,记录创建版本号；
    * 删除操作时,记录删除版本号；
    * 更新操作时,先记录删除版本号,再新增一行记录创建版本号；
    * 查询操作时,要符合以下条件才能被查询出来：删除版本号未定义或大于当前事务版本号(删除操作是在当前事务启动之后做的)；创建版本号小于或等于当前事务版本号(创建操作是事务完成或者在事务启动之前完成)

#### 数据库索引的实现原理(B+树)
- 使用B树和B+树的比较
    * IO次数少：B+树的中间结点只存放索引,数据都存在叶结点中,因此中间结点可以存更多的数据,让索引树更加矮胖；
    * 范围查询效率更高：B树需要中序遍历整个树,只B+树需要遍历叶结点中的链表；
    * 查询效率更加稳定：每次查询都需要从根结点到叶结点,路径长度相同,所以每次查询的效率都差不多
- 使用B树索引和哈希索引的比较
    * 哈希索引能以 O(1) 时间进行查找,但是只支持精确查找,无法用于部分查找和范围查找,无法用于排序与分组；B树索引支持大于小于等于查找,范围查找.哈希索引遇到大量哈希值相等的情况后查找效率会降低.哈希索引不支持数据的排序.

#### 使用索引的优点
1. 大大加快了数据的检索速度；
2. 可以显著减少查询中分组和排序的时间；
3. 通过创建唯一性索引,可以保证数据库表中每一行数据的唯一性；
4. 将随机 I/O 变为顺序 I/O(B+Tree 索引是有序的,会将相邻的数据都存储在一起)

#### 哪些情况下索引会失效？
1. 以“%(表示任意0个或多个字符)”开头的LIKE语句；
2. OR语句前后没有同时使用索引；
3. 数据类型出现隐式转化(如varchar不加单引号的话可能会自动转换为int型)；
4. 对于多列索引,必须满足 最左匹配原则/最左前缀原则 (最左优先,eg：多列索引col1、col2和col3,则 索引生效的情形包括 col1或col1,col2或col1,col2,col3)；
5. 如果MySQL估计全表扫描比索引快,则不使用索引(比如非常小的表)

#### 在哪些地方适合创建索引？
1. 某列经常作为最大最小值；
2. 经常被查询的字段；
3. 经常用作表连接的字段；
4. 经常出现在ORDER BY/GROUP BY/DISDINCT后面的字段
- 创建索引时需要注意什么
    * 只应建立在小字段上,而不要对大文本或图片建立索引(一页存储的数据越多一次IO操作获取的数据越大效率越高)；
    * 建立索引的字段应该非空,在MySQL中,含有空值的列很难进行查询优化,因为它们使得索引、索引的统计信息以及比较运算更加复杂.应该用0、一个特殊的值或者一个空串代替NULL；
    * 选择数据密度大(唯一值占总数的百分比很大)的字段作索引

#### 索引的分类
- 普通索引
- 唯一索引 UNIQUE
    * 索引列的值必须唯一,但允许有空值；
- 主键索引 PRIMARY KEY
    * 必须唯一,不允许空值(是一种特殊的唯一索引；MySQL创建主键时默认为聚集索引,但主键也可以是非聚集索引)；
- 单列索引和多列索引/复合索引(Composite)
    * 索引的列数；
- 覆盖(Covering)索引
    * 索引包含了所有满足查询所需要的数据,查询的时候只需要读取索引而不需要回表读取数据；
- 聚集(Clustered)索引/非聚集索引
    * 对磁盘上存放数据的物理地址重新组织以使这些数据按照指定规则排序的一种索引(数据的物理排列顺序和索引排列顺序一致).因此每张表只能创建一个聚集索引(因为要改变物理存储顺序).优点是查询速度快,因为可以直接按照顺序得到需要数据的物理地址.缺点是进行修改的速度较慢.对于需要经常搜索范围的值很有效.非聚集索引只记录逻辑顺序,并不改变物理顺序；

#### 如何优化数据库
- SQL 语句的优化
    * 分析慢查询日志：记录了在MySQL中响应时间超过阀值long_query_time的SQL语句,通过日志去找出IO大的SQL以及发现未命中索引的SQL
    * 使用 Explain 进行分析：通过explain命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、哪些索引被实际使用、表之间的引用以及被扫描的行数等问题；
- 索引的优化
    * 注意会引起索引失效的情况,以及在适合的地方建立索引
- 数据库表结构的优化
    * 选择合适的数据类型：尽可能不要存储NULL字段；使用简单的数据类型(int, varchar/ text)
    * 分库分表

#### 什么是主从复制？实现原理是什么
> 主从复制(Replication)是指数据可以从一个MySQL数据库主服务器复制到一个或多个从服务器,从服务器可以复制主服务器中的所有数据库或者特定的数据库,或者特定的表.默认采用异步模式.
- 实现原理
    * 主服务器 binary log dump 线程：将主服务器中的数据更改(增删改)日志写入 Binary log 中；
    * 从服务器 I/O 线程：负责从主服务器读取binary log,并写入本地的 Relay log；
    * 从服务器 SQL 线程：负责读取 Relay log,解析出主服务器已经执行的数据更改,并在从服务器中重新执行(Replay),保证主从数据的一致性

#### 为什么要主从复制？
- 读写分离: 主服务器负责写,从服务器负责读
    * 缓解了锁的争用,即使主服务器中加了锁,依然可以进行读操作；
    * 从服务器可以使用 MyISAM,提升查询性能以及节约系统开销；
    * 增加冗余,提高可用性
- 数据实时备份,当系统中某个节点发生故障时,可以方便的故障切换
- 降低单个服务器磁盘I/O访问的频率,提高单个机器的I/O性能





