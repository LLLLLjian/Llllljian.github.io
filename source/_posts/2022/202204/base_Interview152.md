---
title: Interview_总结 (152)
date: 2022-04-14
tags: Interview
toc: true
---

### 面试题
    别看了 这就是你的题
    python

<!-- more -->

#### GIL锁
> 计算机有4核,代表着同一时间,可以干4个任务.如果单核cpu的话,我启动10个线程,我看上去也是并发的,因为是执行了上下文的切换,让看上去是并发的.但是单核永远肯定时串行的,它肯定是串行的,cpu真正执行的时候,因为一会执行1,一会执行2.....正常的线程就是这个样子的.但是,在python中,无论有多少核,永远都是假象.无论是4核,8核,还是16核.......不好意思,同一时间执行的线程只有一个(线程),它就是这个样子的.这个是python的一个开发时候,设计的一个缺陷,所以说python中的线程是假线程.
- 全局解释器锁(GIL)
    * 无论你启多少个线程,你有多少个cpu, Python在执行的时候会淡定的在同一时刻只允许一个线程运行
- GIL存在的意义
    * 因为python的线程是调用操作系统的原生线程,这个原生线程就是C语言写的原生线程.因为python是用C写的,启动的时候就是调用的C语言的接口.因为启动的C语言的远程线程,那它要调这个线程去执行任务就必须知道上下文,所以python要去调C语言的接口的线程,必须要把这个上限问关系传给python,那就变成了一个我在加减的时候要让程序串行才能一次计算.就是先让线程1,再让线程2
    * 每个线程在执行的过程中,python解释器是控制不了的,因为是调的C语言的接口,超出了python的控制范围,python的控制范围是只在python解释器这一层,所以python控制不了C接口,它只能等结果.所以它不能控制让哪个线程先执行,因为是一块调用的,只要一执行,就是等结果,这个时候4个线程独自执行,所以结果就不一定正确了.有了GIL,就可以在同一时间只有一个线程能够工作.虽然这4个线程都启动了,但是同一时间我只能让一个线程拿到这个数据.其他的几个都干等.python启动的4个线程确确实实落到了这4个cpu上,但是为了避免出错.这也是Cpython的一个缺陷,其他语言没有,仅仅只是Cpython有.
- GIL锁关系图
    * ![GIL锁关系图](/img/20220414_1.png)
    * 如上图,为什么GIL锁要加在python解释器这一层,而却不加在其他地方
        * 因为你python调用的所有线程都是原生线程.原生线程是通过C语言提供原生接口,相当于C语言的一个函数.你一调它,你就控制不了了它了,就必须等它给你返回结果.只要已通过python虚拟机,再往下就不受python控制了,就是C语言自己控制了.你加在python虚拟机以下,你是加不上去的.同一时间,只有一个线程穿过这个锁去真正执行.其他的线程,只能在python虚拟机这边等待.
-  总结
    * 需要明确的一点是GIL并不是Python的特性,它是在实现Python解析器(CPython)时所引入的一个概念.就好比C++是一套语言(语法)标准,但是可以用不同的编译器来编译成可执行代码.有名的编译器例如GCC,INTEL C++,Visual C++等.Python也一样,同样一段代码可以通过CPython,PyPy,Psyco等不同的Python执行环境来执行.像其中的JPython就没有GIL.然而因为CPython是大部分环境下默认的Python执行环境.所以在很多人的概念里CPython就是Python,也就想当然的把GIL归结为Python语言的缺陷.所以这里要先明确一点：GIL并不是Python的特性,Python完全可以不依赖于GIL.
