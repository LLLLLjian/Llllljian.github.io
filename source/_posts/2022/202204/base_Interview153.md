---
title: Interview_总结 (153)
date: 2022-04-15
tags: Interview
toc: true
---

### 面试题
    别看了 这就是你的题
    python

<!-- more -->

#### 垃圾回收机制
> python采用的是引用计数机制为主,标记-清除和分代收集两种机制为辅的策略
- 引用计数
    * ython 语言默认采用的垃圾收集机制是『引用计数法 Reference Counting』,该算法最早 George E. Collins 在 1960 的时候首次提出,50 年后的今天,该算法依然被很多编程语言使用.
    * 『引用计数法』的原理是：每个对象维护一个ob_ref字段,用来记录该对象当前被引用的次数,每当新的引用指向该对象时,它的引用计数ob_ref加1,每当该对象的引用失效时计数ob_ref减1,一旦对象的引用计数为0,该对象立即被回收,对象占用的内存空间将被释放.
    * 它的缺点是需要额外的空间维护引用计数,这个问题是其次的,不过最主要的问题是它不能解决对象的 “循环引用”,因此,也有很多语言比如 Java 并没有采用该算法做来垃圾的收集机制.
    * 引用计数案例
        ```python
            import sys
            class A():
                def __init__(self):
                    '''初始化对象'''
                    print('object born id:%s' %str(hex(id(self))))

            def f1():
                '''循环引用变量与删除变量'''
                while True:
                    c1=A()
                    del c1

            def func(c):
                print('obejct refcount is: ',sys.getrefcount(c)) #getrefcount()方法用于返回对象的引用计数


            if __name__ == '__main__':
            #生成对象
                a=A()
                func(a)

                #增加引用
                b=a
                func(a)

                #销毁引用对象b
                del b
                func(a)
            # 执行结果
            object born id:0x265c56a56d8
            obejct refcount is:  4
            obejct refcount is:  5
            obejct refcount is:  4
        ```
    * 导致引用计数 +1 的情况
        * 对象被创建,例如 a=23
        * 对象被引用,例如 b=a
        * 对象被作为参数,传入到一个函数中,例如func(a)
        * 对象作为一个元素,存储在容器中,例如list1=[a,a]
    * 导致引用计数-1 的情况
        * 对象的别名被显式销毁,例如del a
        * 对象的别名被赋予新的对象,例如a=24
        * 一个对象离开它的作用域,例如 f 函数执行完毕时,func函数中的局部变量(全局变量不会)
        * 对象所在的容器被销毁,或从容器中删除对象
    * 循环引用导致内存泄露
        ```python
            def f2():
                '''循环引用'''
                while True:
                    c1=A()
                    c2=A()
                    c1.t=c2
                    c2.t=c1
                    del c1
                    del c2
            # 执行结果
            id:0x1feb9f691d0
            object born id:0x1feb9f69438
            object born id:0x1feb9f690b8
            object born id:0x1feb9f69d68
            object born id:0x1feb9f690f0
            object born id:0x1feb9f694e0
            object born id:0x1feb9f69f60
            ...
            # 创建了c1,c2后,这两个对象的引用计数都是1,执行c1.t=c2和c2.t=c1后,引用计数变成2.
            # 在del c1后,内存c1的对象的引用计数变为1,由于不是为0,所以c1的对象不会被销毁,同理,在del c2后也是一样的.
            # 虽然它们两个的对象都是可以被销毁的,但是由于循环引用,导致垃圾回收器都不会回收它们,所以就会导致内存泄露.
        ```
- 分代回收
    * 分代回收是一种以空间换时间的操作方式,Python 将内存根据对象的存活时间划分为不同的集合,每个集合称为一个代,Python 将内存分为了 3“代”,分别为年轻代(第 0 代)、中年代(第 1 代)、老年代(第 2 代),他们对应的是 3 个链表,它们的垃圾收集频率与对象的存活时间的增大而减小.
    * 新创建的对象都会分配在年轻代,年轻代链表的总数达到上限时,Python 垃圾收集机制就会被触发,把那些可以被回收的对象回收掉,而那些不会回收的对象就会被移到中年代去,依此类推,老年代中的对象是存活时间最久的对象,甚至是存活于整个系统的生命周期内.
    * 同时,分代回收是建立在标记清除技术基础之上.分代回收同样作为 Python 的辅助垃圾收集技术处理那些容器对象
- 垃圾回收
    * 调用gc.collect(),需要先导入gc模块
    * 当gc模块的计数器达到阀值的时候
    * 程序退出的时候
- 标记清除
    * 标记清除(Mark—Sweep)』算法是一种基于追踪回收(tracing GC)技术实现的垃圾回收算法.它分为两个阶段：第一阶段是标记阶段,GC 会把所有的『活动对象』打上标记,第二阶段是把那些没有标记的对象『非活动对象』进行回收.那么 GC 又是如何判断哪些是活动对象哪些是非活动对象的呢？
    * 对象之间通过引用(指针)连在一起,构成一个有向图,对象构成这个有向图的节点,而引用关系构成这个有向图的边.从根对象(root object)出发,沿着有向边遍历对象,可达的(reachable)对象标记为活动对象,不可达的对象就是要被清除的非活动对象.根对象就是全局变量、调用栈、寄存器. mark-sweepg 在上图中,我们把小黑圈视为全局变量,也就是把它作为 root object,从小黑圈出发,对象 1 可直达,那么它将被标记,对象 2、3 可间接到达也会被标记,而 4 和 5 不可达,那么 1、2、3 就是活动对象,4 和 5 是非活动对象会被 GC 回收.
    * 标记清除算法作为 Python 的辅助垃圾收集技术主要处理的是一些容器对象,比如 list、dict、tuple,instance 等,因为对于字符串、数值对象是不可能造成循环引用问题.Python 使用一个双向链表将这些容器对象组织起来.不过,这种简单粗暴的标记清除算法也有明显的缺点：清除非活动的对象前它必须顺序扫描整个堆内存,哪怕只剩下小部分活动对象也要扫描所有对象.
