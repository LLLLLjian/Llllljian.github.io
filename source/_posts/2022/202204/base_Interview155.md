---
title: Interview_总结 (155)
date: 2022-04-19
tags: Interview
toc: true
---

### 面试题
    别看了 这就是你的题

<!-- more -->

#### 三握四挥状态
- SYN_SENT
    * 当客户端SOCKET执行CONNECT连接时,它首先发送SYN报文,因此也随即它会进入到了SYN_SENT状态,并等待服务端的发送三次握手中的第2个报文.SYN_SENT状态表示客户端已发送SYN报文.
- SYN_RCVD
    * 这个状态表示接受到了SYN报文,在正常情况下,这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态,很短暂,基本上用netstat你是很难看到这种状态的,除非你特意写了一个客户端测试程序,故意将三次TCP握手过程中最后一个ACK报文不予发送.因此这种状态时,当收到客户端的ACK报文后,它会进入到ESTABLISHED状态
- ESTABLISHED
    * 这个容易理解了,表示连接已经建立了.
- FIN_WAIT_1
    * FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时,它想主动关闭连接,向对方发送了FIN报文,此时该SOCKET即进入到FIN_WAIT_1状态
- CLOSE_WAIT
    * 这种状态的含义其实是表示在等待关闭.怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己,你系统毫无疑问地会回应一个ACK报文给对方,此时则进入到CLOSE_WAIT状态.接下来呢,实际上你真正需要考虑的事情是察看你是否还有数据发送给对方,如果没有的话,那么你也就可以close这个SOCKET,发送FIN报文给对方,也即关闭连接.所以你在CLOSE_WAIT状态下,需要完成的事情是等待你去关闭连接.
- LAST_ACK
    * 这个状态还是比较容易好理解的,它是被动关闭一方在发送FIN报文后,最后等待对方的ACK报文.当收到ACK报文后,也即可以进入到CLOSED可用状态了.
- TIME_WAIT
    * 表示收到了对方的FIN报文,并发送出了ACK报文,就等2MSL后即可回到CLOSED可用状态了.
- CLOSED
    * 正常情况下,当你发送FIN报文后,按理来说是应该先收到(或同时收到)对方的ACK报文,再收到对方的FIN报文

#### time_wait状态如何产生

由上面的变迁图,首先调用close()发起主动关闭的一方,在发送最后一个ACK之后会进入time_wait的状态,也就说该发送方会保持2MSL时间之后才会回到初始状态.MSL值得是数据包在网络中的最大生存时间.产生这种结果使得这个TCP连接在2MSL连接等待期间,定义这个连接的四元组(客户端IP地址和端口,服务端IP地址和端口号)不能被使用.

#### time_wait状态产生的原因
1. 为实现TCP全双工连接的可靠释放
2. 为使旧的数据包在网络因过期而消失


