---
title: Interview_总结 (167)
date: 2022-05-10
tags: Interview
toc: true
---

### 面试题
    别看了 这就是你的题

<!-- more -->

#### 计算机网络
- OSI七层网络
    * ~~应用层/传输层/网络层/数据链路层~~
    * 应用层/表示层/会话层/传输层/网络层/数据链路层/物理层
- 应用层有哪些协议
    * ~~HTTP~~
    * DNS域名系统/FTP文件传输协议/HTTP超文本传送协议/SMTP电子邮件协议/POP3邮件读取协议/SNMP简单网络管理协议/TFTP简单文件传送协议
- TCP在哪层
    * 传输层
- 与UDP区别
    * ~~TCP需要三次握手/四次挥手, UDP不用; TCP是可靠的, UDP是不可靠的; TCP是面向报文的, UDP是面向字节的; ~~
    - TCP和UDP区别
        * 连接
            * TCP是面向连接的传输层协议,传输数据前先要建立连接.
            * UDP是不需要连接,即刻传输数据
        * 服务对象
            * TCP 是一对一的两点服务,即一条连接只有两个端点.
            * UDP 支持一对一、一对多、多对多的交互通信
        * 可靠性
            * TCP是可靠交付数据的,数据可以无差错、不丢失、不重复、按需到达
            * UDP是尽最大努力交付,不保证可靠交付数据
        * 拥塞控制、流量控制
            * TCP有拥塞控制和流量控制机制,保证数据传输的安全性
            * UDP则没有,即使网络非常拥堵了,也不会影响 UDP 的发送速率
        * 首部开销
            * TCP 首部长度较长,会有一定的开销,首部在没有使用「选项」字段时是 用了「选项」字段则会变长的
            * UDP 首部只有 8 个字节,并且是固定不变的,开销较小
        * 传输方式
            * TCP 是流式传输,没有边界,但保证顺序和可靠
            * UDP 是一个包一个包的发送,是有边界的,但可能会丢包和乱序
        * 分片不同
            * TCP 的数据大小如果大于 MSS 大小,则会在传输层进行分片,目标主机收到后,也同样在传输 层组装 TCP 数据包,如果中途丢失了一个分片,只需要传输丢失的这个分片.
            * UDP 的数据大小如果大于 MTU 大小,则会在 IP 层进行分片,目标主机收到后,在 IP 层组装完 数据,接着再传给传输层,但是如果中途丢了一个分片,则就需要重传所有的数据包,这样传输 效率非常差,所以通常 UDP 的报文应该小于 MTU.
- http常见状态码
    * 2xx:成功; 301:永久重定向; 302:临时重定向; 400:缺少参数; 401:未登录; 403:没权限; 404:没找到资源; 405:请求方法不允许; 500:服务器内部错误; 502:返回了nginx解析不了的响应; 504:nginx响应超时
    - 502和504的区别
        * 502: 作为网关或者代理工作的服务器尝试执行请求时, 从上游服务器接收到无效的响应
        * 504: 作为网关或者代理工作的服务器尝试执行请求时, 未能及时从上游服务器(URI标识出的服务器, 例如HTTP、FTP、LDAP)或者辅助服务器(例如DNS)收到响应
        * 通俗的来说, nginx作为一个代理服务器, 将请求转发到其他服务器或者php-cgi来处理, 当nginx收到了无法理解的响应时, 就返回502. 当nginx超过自己配置的超时时间还没有收到请求时, 就返回504错误
        * 打个比喻, 502是你呼叫对方要东西, 联系上了对方, 但东西不能及时给你504是你呼叫对方要东西, 联系不上对方
- HTTP请求方式
    * GET:获取资源; POST:新增资源; PUT:修改资源; DELETE:删除资源; OPTIONS:
- 三握四挥
    * 三握
        * 客户端向服务端发送SYN, 进入SYN_SENT状态(寻址请求)
        * 服务端向客户端发送SYN+ACK, 进入SYN-RCVD状态(确认请求)
        * 客户端向服务端发送ACK, 进入ESTABLISHED, 开始连接
    * 四挥
        * 客户端向服务端发送FIN, 进入FIN_WAIT_1状态
        * 服务端向客户端发送ACK, 进入CLOSE_WAIT状态
        * 服务端向客户端发送FIN+ACK, 进入状态LAST_ACK
        * 客户端向服务端发送ACK, 进入TIME_WAIT状态
- TCP怎么保证可靠性
    * 数据包校验
    * 对失序数据包重新排序(TCP报文具有序列号)
    * 丢弃重复数据
    * 应答机制: 接收方收到数据之后, 会发送一个确认(通常延迟几分之一秒)；
    * 超时重发: 发送方发出数据之后, 启动一个定时器, 超时未收到接收方的确认, 则重新发送这个数据；
    * 流量控制: 确保接收端能够接收发送方的数据而不会缓冲区溢出
- TCP流量控制与拥塞控制
    * 拥塞控制是因为网络拥塞采取的手段,是发送方自己感知的
    * 流量控制是因为接收方接收缓存受限制,是接收方告诉发送方的
- TCP为什么存在TIME_WAIT状态
    * 第四次挥手时,客户端发送给服务器的ACK有可能丢失,TIME_WAIT状态就是用来重发可能丢失的ACK报文.如果Server没有收到ACK,就会重发FIN,如果Client在2*MSL的时间内收到了FIN,就会重新发送ACK并再次等待2MSL,防止Server没有收到ACK而不断重发FIN.
    * MSL(Maximum Segment Lifetime),指一个片段在网络中最大的存活时间,2MSL就是一个发送和一个回复所需的最大时间.如果直到2MSL,Client都没有再次收到FIN,那么Client推断ACK已经被成功接收,则结束TCP连接.

#### mysql
- 事务的四种隔离级别
    * 读未提交/读已提交/可重复读/串行化
- 索引的数据结构
    * B+数, 只有叶子结点才会储存相关数据, 更矮胖, 查询更稳定; 叶子结点之间有关联, 利于范围查询

#### linux
- 进程线程区别
    * 进程是资源调度的最小单位, 线程是程序执行的最小单位; 每个进程都有自己单独的虚拟内存空间, 线程之间会共享一个内存空间, 所以线程切换比进程切换更快; 多进程比多线程更稳定, 多进程不会因为单个进程挂掉影响其他进程, 但多线程中有一个线程挂掉, 其它线程也会挂掉
- 并行和并发
    * 并发: 同一时刻只能处理一个任务, 但一个时段内可以对多个任务进行交替处理(一个处理器同时处理多个任务)
    * 并行: 同一时刻可以处理多个任务(多个处理器或者是多核的处理器同时处理多个不同的任务)
    * 类比: 并发是一个人同时吃三个馒头, 而并行是三个人同时吃三个馒头.
- crontab定时任务
    * 分时日月周
- 日志文件中访问量前10的IP,第2列是ip,分隔符是空格
    * cat access.log | awk awk '{ print $2}'| uniq -c | sort | head -10
- 找到进程并杀掉
    * ps aux | grep "进程" | awk awk '{ print $2}' | xarg kill -9
- 进程间通信方式
    * 进程间通讯有多种方式, 包括信号, 管道, 消息队列, 信号量, 共享内存, socket等
- IO多路复用
    * IO多路复用是一种同步IO模型,实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪,就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序,交出cpu.多路是指网络连接,复用指的是同一个线程
    * select: 有最大连接数的限制
    * poll: 没有最大连接数的限制
    * epoll: 只能在linux下使用
- 什么是内核态,用户态
    * 为了限制不同程序的访问能力,防止一些程序访问其它程序的内存数据,CPU划分了用户态和内核态两个权限等级.
    * 用户态只能受限地访问内存,且不允许访问外围设备,没有占用CPU的能力,CPU资源可以被其它程序获取；
    * 内核态可以访问内存所有数据以及外围设备,也可以进行程序的切换.
    * 所有用户程序都运行在用户态,但有时需要进行一些内核态的操作,比如从硬盘或者键盘读数据,这时就需要进行系统调用,使用陷阱指令,CPU切换到内核态,执行相应的服务,再切换为用户态并返回系统调用的结果.
- 为什么要分用户态和内核态？
    * 安全性
        * 防止用户程序恶意或者不小心破坏系统/内存/硬件资源；
    * 封装性
        * 用户程序不需要实现更加底层的代码；
    * 利于调度
        * 如果多个用户程序都在等待键盘输入,这时就需要进行调度；统一交给操作系统调度更加方便.

- 如何从用户态切换到内核态
    * 系统调用
        * 比如读取命令行输入.本质上还是通过中断实现
    * 用户程序发生异常时
        * 比如缺页异常
    * 外围设备的中断
        * 外围设备完成用户请求的操作之后,会向CPU发出中断信号,这时CPU会转去处理对应的中断处理程序

#### python
- 装饰器
    * 用过, 代码中的处理请求参数/返回响应参数/权限检查都用的是装饰器, 好用但难写
- GIL锁
    * 全局解释器锁, 无论你启多少个线程,你有多少个cpu, Python在执行的时候会淡定的在同一时刻只允许一个线程运行
- with
    * with 语句实质是上下文管理. 
    * 上下文管理协议. 包含方法__enter__() 和 __exit__(), 支持该协议对象要实现这两个方法
    * 上下文管理器, 定义执行with语句时要建立的运行时上下文, 负责执行with语句块上下文中的进入与退出操作
    * 进入上下文的时候执行__enter__方法, 如果设置as var语句, var变量接受__enter__()方法返回值
    * 如果运行时发生了异常, 就退出上下文管理器. 调用管理器__exit__方法
- 深浅拷贝
    * 赋值(=),就是创建了对象的一个新的引用,修改其中任意一个变量都会影响到另一个.
    * 浅拷贝 copy.copy：创建一个新的对象,但它包含的是对原始对象中包含项的引用(如果用引用的方式修改其中一个对象,另外一个也会修改改变)
    * 深拷贝：创建一个新的对象,并且递归的复制它所包含的对象(修改其中一个,另外一个不会改变){copy模块的copy.deepcopy()函数}
- 垃圾回收
    * 引用计数为主, 标记清除和分代清除为辅
- 什么是lambda函数
    * 简单来说,lambda表达式通常是当你需要使用一个函数,但是又不想费脑袋去命名一个函数的时候使用,也就是通常所说的匿名函数.
    * lambda表达式一般的形式是：关键词lambda后面紧接一个或多个参数,紧接一个冒号“：”,紧接一个表达式
- yield关键字
    * 生成器, 节省大量的内存, 比较适合计算大量的数据
- python 里元组与列表的区别,怎么转换
    * 由于元组的不可更改性,决定了元组不能像列表一样,进行添加、删除等操作
    * list()
    * tuple()
- python2和python3区别
    * print "" => print()
    * xrange() => range()

#### 哈希冲突
> 再好的散列函数都无法避免散列冲突
> 抽屉原理: 桌上有十个苹果, 要把这十个苹果放到九个抽屉里, 无论怎样放, 我们会发现至少会有一个抽屉里面至少放两个苹果.这一现象就是我们所说的“抽屉原理”
- 解决哈希冲突的方法
    * 开放寻址法
        * 当我们往散列表中插入数据时, 如果某个数据经过散列函数散列之后, 存储位置已经被占用了, 我们就从当前位置开始, 依次往后查找, 看是否有空闲位置, 直到找到为止
        * 弊端就是当散列表中插入的数据越来越多时, 散列冲突发生的可能性就会越来越大, 空闲位置会越来越少, 线性探测的时间就会越来越久.极端情况下, 需要从头到尾探测整个散列表, 所以最坏情况下的时间复杂度为 O(n)
    * 链表法
        * 在散列表中, 每个位置对应一条链表, 所有散列值相同的元素都放到相同位置对应的链表中

