---
title: Go_基础 (18)
date: 2022-06-28
tags: Go
toc: true
---

### Go语言核心36讲
    Go语言基础-GO语句执行规则(上)

<!-- more -->

#### 进程和线程
- 进程
    * 进程, 描述的就是程序的执行过程, 是运行着的程序的代表.换句话说, 一个进程其实就是某个程序运行时的一个产物.如果说静静地躺在那里的代码就是程序的话, 那么奔跑着的、正在发挥着既有功能的代码就可以被称为进程.
- 线程
    * 线程总是在进程之内的, 它可以被视为进程中运行着的控制流(或者说代码执行的流程).一个进程至少会包含一个线程.如果一个进程只包含了一个线程, 那么它里面的所有代码都只会被串行地执行.每个进程的第一个线程都会随着该进程的启动而被创建, 它们可以被称为其所属进程的主线程.相对应的, 如果一个进程中包含了多个线程, 那么其中的代码就可以被并发地执行.除了进程的第一个线程之外, 其他的线程都是由进程中已存在的线程创建出来的.也就是说, 主线程之外的其他线程都只能由代码显式地创建和销毁.这需要我们在编写程序的时候进行手动控制, 操作系统以及进程本身并不会帮我们下达这样的指令, 它们只会忠实地执行我们的指令.
- 调度器统筹调配的三要素
    * G(goroutine 的缩写)
    * P(processor 的缩写), 是一种可以承载若干个 G, 且能够使这些 G 适时地与 M 进行对接, 并得到真正运行的中介.
    * M(machine 的缩写), 系统级线程

![调度器](/img/20220628_1.jpg)

- 什么是主 goroutine, 它与我们启用的其他 goroutine 有什么不同
    * 代码
        ```go
            package main

            import "fmt"

            func main() {
            for i := 0; i < 10; i++ {
                go func() {
                fmt.Println(i)
                }()
            }
            }
        ```
    * 先说结论
        * 结论就是这段代码什么都不会输出, 不会输出的原因是因为for语句会以很快的速度执行完毕.当它执行完毕时, 那10个包装了go函数的goroutine往往还没有获得运行的机会
    * 问题解析
        * 与一个进程总会有一个主线程类似, 每一个独立的 Go 程序在运行时也总会有一个主 goroutine.这个主 goroutine 会在 Go 程序的运行准备工作完成后被自动地启用, 并不需要我们做任何手动的操作.
        * 这个主 goroutine 会在 Go 程序的运行准备工作完成后被自动地启用, 并不需要我们做任何手动的操作.
        * 主 goroutine 的go函数就是那个作为程序入口的main函数
        * 一定要注意, go函数真正被执行的时间, 总会与其所属的go语句被执行的时间不同.当程序执行到一条go语句的时候, Go 语言的运行时系统, 会先试图从某个存放空闲的 G 的队列中获取一个 G(也就是 goroutine), 它只有在找不到空闲 G 的情况下才会去创建一个新的 G.
        * 在拿到了一个空闲的 G 之后, Go 语言运行时系统会用这个 G 去包装当前的那个go函数(或者说该函数中的那些代码), 然后再把这个 G 追加到某个存放可运行的 G 的队列中.这类队列中的 G 总是会按照先入先出的顺序, 很快地由运行时系统内部的调度器安排运行.虽然这会很快, 但是由于上面所说的那些准备工作还是不可避免的, 所以耗时还是存在的.
        * 因此, go函数的执行时间总是会明显滞后于它所属的go语句的执行时间.当然了, 这里所说的“明显滞后”是对于计算机的 CPU 时钟和 Go 程序来说的.我们在大多数时候都不会有明显的感觉.
        * go函数中的那个对fmt.Println函数的调用是以for语句中的变量i作为参数的.你可以想象一下, 如果当for语句执行完毕的时候, 这些go函数都还没有执行, 那么它们引用的变量i的值将会是什么？10个10或者乱序的0-9