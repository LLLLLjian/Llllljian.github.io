---
title: Interview_总结 (175)
date: 2022-06-01
tags: Interview
toc: true
---

### 面试题
    别看了 这就是你的题

<!-- more -->

#### TCP的基本认识
- 为什么需要TCP协议, TCP工作在哪一层
    * IP 层是「不可靠」的,它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据 的完整性.
    * 如果需要保障网络数据包的可靠性,那么就需要由上层(传输层)的 TCP 协议来负责.
    * 引入一下 TCP/IP四层
        * 应用层
        * 传输层
        * 网络层
        * 网络接口层
    * 引入一下 OSI七层
        * 应用层
        * 表示层
        * 会话层
        * 传输层
        * 网络层
        * 数据链路层
        * 物理层
- 什么是TCP
    * TCP 是面向连接的、可靠的、基于字节流的传输层通信协议.
    * **面向连接**:一定是「一对一」才能连接,不能像 UDP 协议可以一个主机同时向多个主机发送消 息,也就是一对多是无法做到的;
    * **可靠的**:无论的网络链路中出现了怎样的链路变化,TCP 都可以保证一个报文一定能够到达接收 端;
    * **字节流**:消息是「没有边界」的,所以无论我们消息有多大都可以进行传输.并且消息是「有序 的」,当「前一个」消息没有收到的时候,即使它先收到了后面的字节,那么也不能扔给应用层 去处理,同时对「重复」的报文会自动丢弃.
- 什么是TCP连接
    * 用于保证可靠性和流量控制维护的某些状态信息,这些信息的组合,包括Socket、序列 号和窗口大小称为连接.
- TCP和UDP区别
    * 连接
        * TCP是面向连接的传输层协议,传输数据前先要建立连接.
        * UDP是不需要连接,即刻传输数据
    * 服务对象
        * TCP 是一对一的两点服务,即一条连接只有两个端点.
        * UDP 支持一对一、一对多、多对多的交互通信
    * 可靠性
        * TCP是可靠交付数据的,数据可以无差错、不丢失、不重复、按需到达
        * UDP是尽最大努力交付,不保证可靠交付数据
    * 拥塞控制、流量控制
        * TCP有拥塞控制和流量控制机制,保证数据传输的安全性
        * UDP则没有,即使网络非常拥堵了,也不会影响 UDP 的发送速率
    * 首部开销
        * TCP 首部长度较长,会有一定的开销,首部在没有使用「选项」字段时是 用了「选项」字段则会变长的
        * UDP 首部只有 8 个字节,并且是固定不变的,开销较小
    * 传输方式
        * TCP 是流式传输,没有边界,但保证顺序和可靠
        * UDP 是一个包一个包的发送,是有边界的,但可能会丢包和乱序
    * 分片不同
        * TCP 的数据大小如果大于 MSS 大小,则会在传输层进行分片,目标主机收到后,也同样在传输 层组装 TCP 数据包,如果中途丢失了一个分片,只需要传输丢失的这个分片.
        * UDP 的数据大小如果大于 MTU 大小,则会在 IP 层进行分片,目标主机收到后,在 IP 层组装完 数据,接着再传给传输层,但是如果中途丢了一个分片,则就需要重传所有的数据包,这样传输 效率非常差,所以通常 UDP 的报文应该小于 MTU.
- TCP和UDP应用场景
    * TCP
        * FTP 文件传输
        * HTTP / HTTPS
    * UDP
        * 包总量较少的通信,如 DNS 、 SNMP 等
        * 视频、音频等多媒体通信
        * 广播通信

#### TCP连接建立
- TCP三次握手过程
    * 一开始,客户端和服务端都处于 CLOSED 状态.先是服务端主动监听某个端口,处于 LISTEN 状态
    * 客户端会随机初始化序号( client_isn ),将此序号置于 TCP 首部的「序号」字段中,同时把 SYN 标志位置为 1 ,表示 SYN 报文.接着把第一个 SYN 报文发送给服务端,表示向服务端发起连接,该报文不包含应用层数据,之后客户端处于 SYN-SENT 状态.
    * 服务端收到客户端的 SYN 报文后,首先服务端也随机初始化自己的序号( ),将此 序号填入 TCP 首部的「序号」字段中,其次把 TCP 首部的「确认应答号」字段填入1 , 接着把 SYN 和 ACK 标志位置为 1 .最后把该报文发给客户端,该报文也不包含应用层 数据,之后服务端处于 SYN-RCVD 状态.
    * 客户端收到服务端报文后,还要向服务端回应最后一个应答报文,首先该应答报文 TCP 首部 ACK 标志位置为 1 ,其次「确认应答号」字段填入 ,最后把报文发送给服务端,这次报文可以携带客户到服务器的数据,之后客户端处于 状态.
    * 服务器收到客户端的应答报文后,也进入 ESTABLISHED 状态.
- 为什么是三次握手
    * 三次握手才可以阻止重复历史连接的初始化(主要原因)
    * 三次握手才可以同步双方的初始序列号
    * 三次握手才可以避免资源浪费
- 不使用「两次握手」和「四次握手」的原因:
    * 「两次握手」:无法防止历史连接的建立,会造成双方资源的浪费,也无法可靠的同步双方序列号;
    * 「四次握手」:三次握手就已经理论上最少可靠连接建立,所以不需要使用更多的通信次数.

#### TCP连接断开
- TCP四次挥手过程
    * 客户端打算关闭连接,此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文,也即 FIN报文,之后客户端进入 FIN_WAIT_1 状态.
    * 服务端收到该报文后,就向客户端发送 ACK 应答报文,接着服务端进入 CLOSED_WAIT 状 态.
    * 客户端收到服务端的 ACK 应答报文后,之后进入 FIN_WAIT_2 状态
    * 等待服务端处理完数据后,也向客户端发送 FIN 报文,之后服务端进入 LAST_ACK 状态
    * 客户端收到服务端的 FIN 报文后,回一个 ACK 应答报文,之后进入 TIME_WAIT 状态
    * 服务器收到了 ACK 应答报文后,就进入了 CLOSED 状态,至此服务端已经完成连接的关闭
    * 客户端在经过 2MSL 一段时间后,自动进入 CLOSED 状态,至此客户端也完成连接的关闭.
- 为什么是四次挥手
    * 关闭连接时,客户端向服务端发送 FIN 时,仅仅表示客户端不再发送数据了但是还能接收数 据.
    * 服务器收到客户端的 FIN 报文时,先回一个 ACK 应答报文,而服务端可能还有数据需要处理 和发送,等服务端不再发送数据时,才发送 FIN 报文给客户端来表示同意现在关闭连接.
- 为什么TIME_WAIT等待的时间是2MSL
    * MSL 是 Maximum Segment Lifetime,报文最大生存时间
    * 2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的.如果在 TIME-WAIT 时间内,因为客 户端的 ACK 没有传输到服务端,客户端又接收到了服务端重发的 FIN 报文,那么 2MSL 时间将重新计时.
- 为什么需要TIME_WAIT状态
    * 防止具有相同「四元组」的「旧」数据包被收到;
    * 保证「被动关闭连接」的一方能被正确的关闭,即保证最后的 ACK 能让被动关闭方接收,从而帮 助其正常关闭;
- 大量连接处于CLOSE_WAIT是什么原因
    * 表示说要么是你的应用程序写的有问题,没有合适的关闭socket；要么是说,你的服务器CPU处理不过来(CPU太忙)或者你的应用程序一直睡眠到其它地方(锁,或者文件I/O等等),你的应用程序获得不到合适的调度时间,造成你的程序没法真正的执行close操作.

#### HTTP常见出状态码
- 1xx
    * 状态码属于提示信息, 是协议处理中的一种中间状态, 实际用到的比较少
- 2xx
    * 状态码表示服务器成功处理了客户端的请求, 也是我们最愿意看到的状态
    * 「200 OK」是最常见的成功状态码, 表示一切正常.如果是非 HEAD 请求, 服务器返回的响应头都会有 body 数据.
    * 「204 No Content」也是常见的成功状态码, 与 200 OK 基本相同, 但响应头没有 body 数据.
    * 「206 Partial Content」是应用于 HTTP 分块下载或断点续传, 表示响应返回的 body 数据并不是资源 的全部, 而是其中的一部分, 也是服务器处理成功的状态.
- 3xx
    * 状态码表示客户端请求的资源发送了变动, 需要客户端用新的 URL 重新发送请求获取资源,  也就是重定向
    * 「301 Moved Permanently」表示永久重定向, 说明请求的资源已经不存在了, 需改用新的 URL 再次 访问.
    * 「302 Found」表示临时重定向, 说明请求的资源还在, 但暂时需要用另一个 URL 来访问.
    * 301 和 302 都会在响应头里使用字段 Location , 指明后续要跳转的 URL, 浏览器会自动重定向新的URL.
    * 「304 Not Modified」不具有跳转的含义, 表示资源未修改, 重定向已存在的缓冲文件, 也称缓存重定向, 用于缓存控制.
- 4xx
    * 状态码表示客户端发送的报文有误, 服务器无法处理, 也就是错误码的含义
    * 「400 Bad Request」表示客户端请求的报文有错误, 但只是个笼统的错误.
    * 「403 Forbidden」表示服务器禁止访问资源, 并不是客户端的请求出错.
    * 「404 Not Found」表示请求的资源在服务器上不存在或未找到, 所以无法提供给客户端
- 5xx
    * 状态码表示客户端请求报文正确, 但是服务器处理时内部发生了错误, 属于服务器端的错误 码.
    * 「500 Internal Server Error」与 400 类型, 是个笼统通用的错误码, 服务器发生了什么错误, 我们并不知道.
    * 「501 Not Implemented」表示客户端请求的功能还不支持, 类似“即将开业, 敬请期待”的意思.
    * 「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码, 表示服务器自身工作正常, 访问后端服务器发生了错误.
    * 「503 Service Unavailable」表示服务器当前很忙, 暂时无法响应服务器, 类似“网络服务正忙, 请稍后重试”的意思.

#### HTTP常见字段有哪些
- Host
    * 客户端发送请求时, 用来指定服务器的域名
- Content-Length
    * 服务器在返回数据时, 会有 Content-Length 字段, 表明本次回应的数据长度.
- Connection
    * Connection 字段最常用于客户端要求服务器使用 TCP 持久连接, 以便其他请求复用
- Content-Type
    * Content-Type 字段用于服务器回应时, 告诉客户端, 本次数据是什么格式
- Content-Encoding
    * Content-Encoding 字段说明数据的压缩方法.表示服务器返回的数据使用了什么压缩格式

#### 说一下 GET 和 POST 的区别
- Get 方法的含义是请求从服务器获取资源
- POST 方法则是相反操作, 它向 URI 指定的资源提交数据, 数据就放在报文的 body 里
- 是否安全和幂等
    * 在 HTTP 协议里, 所谓的「安全」是指请求方法不会「破坏」服务器上的资源
    * 所谓的「幂等」, 意思是多次执行相同的操作, 结果都是「相同」的
    * GET 安全且幂等
    * POST 不安全且不幂等

#### HTTP(1.1) 的优点
- 简单
    * HTTP 基本的报文格式就是 header + body ,头部信息也是 key-value 简单文本的形式,易于理解, 降低了学习和使用的门槛.
- 灵活和易于扩展
    * HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死,都允许开 发人员自定义和扩充.
- 应用广泛和跨平台
    * HTTP 的应用片地开花,同时天然具有跨平台的优越性

#### HTTP(1.1) 的缺点
- 无状态
    * 无状态的好处,因为服务器不会去记忆 HTTP 的状态,所以不需要额外的资源来记录状态信息,这能减 轻服务器的负担,能够把更多的 CPU 和内存用来对外提供服务.
    * 无状态的坏处,既然服务器没有记忆能力,它在完成有关联性的操作时会非常麻烦.
- 明文传输
    * 信息裸奔
- 不安全
    * 通信使用明文(不加密),内容可能会被窃听.比如,账号信息容易泄漏,那你号没了
    * 不验证通信方的身份,因此有可能遭遇伪装.比如,访问假的淘宝、拼多多,那你钱没了
    * 无法证明报文的完整性,所以有可能已遭篡改.比如,网页上植入垃圾广告,视觉污染,眼没 了

#### HTTP(1.1) 的性能
- 长连接
    * 减少了 TCP 连接的重复建立和断开所造成的额外开销,减轻了服务器端的负载
- 管道网络传输
    * 在同一个 TCP 连接里面,客户端可以发起多个请求,可以减少整体的响应时间
- 队头阻塞
    * 因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时,在后面排队的所有请求也一同被阻塞 了,会招致客户端一直请求不到数据

#### HTTP与HTTPS有哪些区别
1. HTTP 是超文本传输协议,信息是明文传输,存在安全风险的问题.HTTPS 则解决 HTTP 不安全 的缺陷,在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议,使得报文能够加密传输.
2. HTTP 连接建立相对简单, TCP 三次握手之后便可进行 HTTP 的报文传输.而 HTTPS 在 TCP 三次握手之后,还需进行 SSL/TLS 的握手过程,才可进入加密报文传输.
3. HTTP 的端口号是 80,HTTPS 的端口号是 443.
4. HTTPS 协议需要向 CA(证书权威机构)申请数字证书,来保证服务器的身份是可信的.

#### HTTPS解决了HTTP的哪些问题
- 三危险
    * 窃听风险,比如通信链路上可以获取通信内容,用户号容易没
    * 篡改风险,比如强制植入垃圾广告,视觉污染,用户眼容易瞎
    * 冒充风险,比如冒充淘宝网站,用户钱容易没
- 三解决
    * 信息加密:交互信息无法被窃取,但你的号会因为「自身忘记」账号而没
        * 混合加密
    * 校验机制:无法篡改通信内容,篡改了就不能正常显示,但百度「竞价排名」依然可以搜索垃圾广告
        * 客户端在发送明文之前会通过摘要算法算出明文的「指纹」,发送的时候把「指纹 + 明文」一同加密成 密文后,发送给服务器,服务器解密后,用相同的摘要算法算出发送过来的明文,通过比较客户端携带 的「指纹」和当前算出的「指纹」做比较,若「指纹」相同,说明数据是完整的.
    * 身份证书:证明淘宝是真的淘宝网,但你的钱还是会因为「剁手」而没
        * 将服务器公钥放在数字证书(由数 字证书认证机构颁发)中,只要证书是可信的,公钥就是可信的.

#### 进程和线程有什么区别
1. 进程(Process)是系统进行资源分配和调度的基本单位,线程(Thread)是CPU调度和分派的基本单位；
2. 线程依赖于进程而存在,一个进程至少有一个线程；
3. 进程有自己的独立地址空间,线程共享所属进程的地址空间；
4. 进程是拥有系统资源的一个独立单位,而线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),和其他线程共享本进程的相关资源如内存、I/O、cpu等；
5. 在进程切换时,涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置,而线程切换只需保存和设置少量的寄存器的内容,并不涉及存储器管理方面的操作,可见,进程切换的开销远大于线程切换的开销；
6. 线程之间的通信更方便,同一进程下的线程共享全局变量等数据,而进程之间的通信需要以进程间通信(IPC)的方式进行；
7. 多线程程序只要有一个线程崩溃,整个程序就崩溃了,但多进程程序中一个进程崩溃并不会对其它进程造成影响,因为进程有自己的独立地址空间,因此多进程更加健壮

#### 同一进程中的线程可以共享哪些数据
1. 进程代码段
2. 进程的公有数据(全局变量、静态变量...)
3. 进程打开的文件描述符
4. 进程的当前目录
5. 信号处理器/信号处理函数：对收到的信号的处理方式
6. 进程ID与进程组ID

#### 线程独占哪些资源
1. 线程ID
2. 一组寄存器的值
3. 线程自身的栈(堆是共享的)
4. 错误返回码：线程可能会产生不同的错误返回码,一个线程的错误返回码不应该被其它线程修改；
5. 信号掩码/信号屏蔽字(Signal mask)：表示是否屏蔽/阻塞相应的信号(SIGKILL,SIGSTOP除外)

#### 进程间通信有哪些方式
1. 管道(Pipe)
2. 命名管道
3. 消息队列
4. 信号(Signal)
5. 共享内存
6. 信号量(Semaphore)：初始化操作、P操作、V操作；P操作：信号量-1,检测是否小于0,小于则进程进入阻塞状态；V操作：信号量+1,若小于等于0,则从队列中唤醒一个等待的进程进入就绪态
7. 套接字(Socket)

#### 什么是协程？

协程是一种用户态的轻量级线程,协程的调度完全由用户控制.协程拥有自己的寄存器上下文和栈.协程调度切换时,将寄存器上下文和栈保存到其他地方,在切回来的时候,恢复先前保存的寄存器上下文和栈,直接操作栈则基本没有内核切换的开销,可以不加锁的访问全局变量,所以上下文的切换非常快.

#### 什么是IO多路复用？怎么实现
> IO多路复用(IO Multiplexing)是指单个进程/线程就可以同时处理多个IO请求
- 实现原理
    * 用户将想要监视的文件描述符(File Descriptor)添加到select/poll/epoll函数中,由内核监视,函数阻塞.一旦有文件描述符就绪(读就绪或写就绪),或者超时(设置timeout),函数就会返回,然后该进程可以进行相应的读/写操作.

#### select/poll/epoll三者的区别
- select
    * 将文件描述符放入一个集合中,调用select时,将这个集合从用户空间拷贝到内核空间(缺点1：每次都要复制,开销大),由内核根据就绪状态修改该集合的内容.(缺点2)集合大小有限制,32位机默认是1024(64位：2048)；采用水平触发机制.select函数返回后,需要通过遍历这个集合,找到就绪的文件描述符(缺点3：轮询的方式效率较低),当文件描述符的数量增加时,效率会线性下降；
- poll
    * 和select几乎没有区别,区别在于文件描述符的存储方式不同,poll采用链表的方式存储,没有最大存储数量的限制；
- epoll
    * 通过内核和用户空间共享内存,避免了不断复制的问题；支持的同时连接数上限很高(1G左右的内存支持10W左右的连接数)；文件描述符就绪时,采用回调机制,避免了轮询(回调函数将就绪的描述符添加到一个链表中,执行epoll_wait时,返回这个链表)；支持水平触发和边缘触发,采用边缘触发机制时,只有活跃的描述符才会触发回调函数.

#### IO多路复用的三种实现方式
1. select
    * 单个进程所打开的FD是有限制的,通过FD_SETSIZE设置,默认1024
    * 每次调用select,都需要把fd集合从用户态拷贝到内核态,这个开销在fd很多时会很大
    * 对socket扫描时是线性扫描,采用轮询的方法,效率较低(高并发时)
2. poll
    * poll与select相比,只是没有fd的限制,其它基本一样
3. epoll
    * 只能运行在linux系统下

#### 什么是对称加密、非对称加密？区别是什么？
- 对称加密
    * 加密和解密采用相同的密钥.如：DES、RC2、RC4
- 非对称加密
    * 需要两个密钥：公钥和私钥.如果用公钥加密,需要用私钥才能解密.如：RSA
- 区别
    * 对称加密速度更快,通常用于大量数据的加密；非对称加密安全性更高(不需要传送私钥)

#### 从输入网址到获得页面的过程
1. 浏览器查询 DNS,获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等.对于向本地DNS服务器进行查询,如果要查询的域名包含在本地配置区域资源中,则返回解析结果给客户机,完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析,但该服务器已缓存了此网址映射关系,则调用这个IP地址映射,完成域名解析(此解析不具有权威性).如果本地域名服务器并未缓存该网址映射关系,那么将根据其设置发起递归查询或者迭代查询；
2. 浏览器获得域名对应的IP地址以后,浏览器向服务器请求建立链接,发起三次握手；
3. TCP/IP链接建立起来后,浏览器向服务器发送HTTP请求；
4. 服务器接收到这个请求,并根据路径参数映射到特定的请求处理器进行处理,并将处理结果及相应的视图返回给浏览器；
5. 浏览器解析并渲染视图,若遇到对js文件、css文件及图片等静态资源的引用,则重复上述步骤并向服务器请求这些资源；
6. 浏览器根据其请求到的资源、数据渲染页面,最终向用户呈现一个完整的页面.


#### nginx的异步非阻塞是怎么实现的
- 同步与异步的理解
    * 同步与异步的重点在消息通知的方式上, 也就是调用结果通知的方式.
    * 同步: 当一个同步调用发出去后, 调用者要一直等待调用结果的通知后, 才能进行后续的执行.
    * 异步: 当一个异步调用发出去后, 调用者不能立即得到调用结果的返回.
    * 异步调用, 要想获得结果, 一般有两种方式: 
        1. 主动轮询异步调用的结果;
        2. 被调用方通过callback来通知调用方调用结果
- 生活实例
    * 同步取快递: 小明收到快递将送达的短信, 在楼下一直等到快递送达.
    * 异步取快递: 小明收到快递将送达的短信, 快递到楼下后, 小明再下楼去取.
    * 异步取快递, 小明知道快递到达楼下有两种方式: 1、不停的电话问快递小哥到了没有, 即主动轮询；2、快递小哥到楼下后, 打电话通知小明, 然后小明下楼取快递, 即回调通知.
- 阻塞与非阻塞的理解
    * 阻塞与非阻塞的重点在于进/线程等待消息时候的行为, 也就是在等待消息的时候, 当前进/线程是挂起状态, 还是非挂起状态.
    * 阻塞阻塞调用在发出去后, 在消息返回之前, 当前进/线程会被挂起, 直到有消息返回, 当前进/线程才会被激活
    * 非阻塞非阻塞调用在发出去后, 不会阻塞当前进/线程, 而会立即返回.
- 生活实例
    * 阻塞取快递: 小明收到快递即将送达的信息后, 什么事都不做, 一直专门等快递.
    * 非阻塞取快递: 小明收到快递即将送达的信息后, 等快递的时候, 还一边敲代码、一边刷微信.
> 同步与异步, 重点在于消息通知的方式；阻塞与非阻塞, 重点在于等消息时候的行为
- 组合方式
    1. 同步阻塞: 小明收到信息后, 啥都不干, 等快递
    2. 同步非阻塞: 小明收到信息后, 边刷微博, 边等着取快递
    3. 异步阻塞: 小明收到信息后, 啥都不干, 一直等着快递员通知他取快递
    4. 异步非阻塞: 小明收到信息后, 边刷着微博, 边等快递员通知他取快递
