---
title: Interview_总结 (177)
date: 2022-06-03
tags: Interview
toc: true
---

### 面试题
    别看了 这就是你的题

<!-- more -->

#### 事务的概念和特性
- 概念
    * 事务(Transaction)是一个操作序列,不可分割的工作单位,以BEGIN TRANSACTION开始,以ROLLBACK/COMMIT结束
    * 通俗来说, 要么都成功,要么都不成功
- 特性
    * 原子性(Atomicity)
        * 逻辑上是不可分割的操作单元,事务的所有操作要么全部提交成功,要么全部失败回滚(用回滚日志实现,反向执行日志中的操作)；
    * 一致性(Consistency)
        * 事务的执行必须使数据库保持一致性状态.在一致性状态下,所有事务对一个数据的读取结果都是相同的；
    * 隔离性(Isolation)
        * 一个事务所做的修改在最终提交以前,对其它事务是不可见的(并发执行的事务之间不能相互影响)；
    * 持久性(Durability)
        * 一旦事务提交成功,对数据的修改是永久性的

#### 会出现哪些并发一致性问题
- 丢失修改
    * 一个事务对数据进行了修改,在事务提交之前,另一个事务对同一个数据进行了修改,覆盖了之前的修改；
- 脏读(Dirty Read)
    * 一个事务读取了被另一个事务修改、但未提交(进行了回滚)的数据,造成两个事务得到的数据不一致；
- 不可重复读(Nonrepeatable Read)
    * 在同一个事务中,某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据,发现数据已经发生修改(针对update操作)；
- 幻读(Phantom Read)
    * 当同一查询多次执行时,由于其它事务在这个数据范围内执行了插入操作,会导致每次返回不同的结果集(和不可重复读的区别：针对的是一个数据整体/范围；并且针对insert操作)

#### 数据库的四种隔离级别
- 未提交读(Read Uncommited)
    * 在一个事务提交之前,它的执行结果对其它事务也是可见的.会导致脏读、不可重复读、幻读；
- 提交读(Read Commited)
    * 一个事务只能看见已经提交的事务所作的改变.可避免脏读问题；
- 可重复读(Repeatable Read)
    * 可以确保同一个事务在多次读取同样的数据时得到相同的结果.(MySQL的默认隔离级别).可避免不可重复读；
- 可串行化(Serializable)
    * 强制事务串行执行,使之不可能相互冲突,从而解决幻读问题.可能导致大量的超时现象和锁竞争,实际很少使用.

#### 锁
- 悲观锁
    * 认为数据随时会被修改,因此每次读取数据之前都会上锁,防止其它事务读取或修改数据；应用于数据更新比较频繁的场景；
- 乐观锁
    * 操作数据时不会上锁,但是更新时会判断在此期间有没有别的事务更新这个数据,若被更新过,则失败重试；适用于读多写少的场景.乐观锁的实现方式有：
        * 加一个版本号或者时间戳字段,每次数据更新时同时更新这个字段；
        * 先读取想要更新的字段或者所有字段,更新的时候比较一下,只有字段没有变化才进行更新
- 排它锁(Exclusive Lock)/ X锁
    * 事务对数据加上X锁时,只允许此事务读取和修改此数据,并且其它事务不能对该数据加任何锁；
- 共享锁(Shared Lock)/ S锁
    * 加了S锁后,该事务只能对数据进行读取而不能修改,并且其它事务只能加S锁,不能加X锁

#### 什么是 MVCC？
> 多版本并发控制(Multi-Version Concurrency Control, MVCC),MVCC在每行记录后面都保存有两个隐藏的列,用来存储创建版本号和删除版本号.
- 创建版本号
    * 创建一个数据行时的事务版本号(事务版本号：事务开始时的系统版本号；系统版本号：每开始一个新的事务,系统版本号就会自动递增)；
- 删除版本号
    * 删除操作时的事务版本号；
- 各种操作
    * 插入操作时,记录创建版本号；
    * 删除操作时,记录删除版本号；
    * 更新操作时,先记录删除版本号,再新增一行记录创建版本号；
    * 查询操作时,要符合以下条件才能被查询出来：删除版本号未定义或大于当前事务版本号(删除操作是在当前事务启动之后做的)；创建版本号小于或等于当前事务版本号(创建操作是事务完成或者在事务启动之前完成)

#### 数据库索引的实现原理(B+树)
- 使用B树和B+树的比较
    * IO次数少：B+树的中间结点只存放索引,数据都存在叶结点中,因此中间结点可以存更多的数据,让索引树更加矮胖；
    * 范围查询效率更高：B树需要中序遍历整个树,只B+树需要遍历叶结点中的链表；
    * 查询效率更加稳定：每次查询都需要从根结点到叶结点,路径长度相同,所以每次查询的效率都差不多
- 使用B树索引和哈希索引的比较
    * 哈希索引能以 O(1) 时间进行查找,但是只支持精确查找,无法用于部分查找和范围查找,无法用于排序与分组；B树索引支持大于小于等于查找,范围查找.哈希索引遇到大量哈希值相等的情况后查找效率会降低.哈希索引不支持数据的排序.

#### 使用索引的优点
1. 大大加快了数据的检索速度；
2. 可以显著减少查询中分组和排序的时间；
3. 通过创建唯一性索引,可以保证数据库表中每一行数据的唯一性；
4. 将随机 I/O 变为顺序 I/O(B+Tree 索引是有序的,会将相邻的数据都存储在一起)

#### 哪些情况下索引会失效？
1. 以“%(表示任意0个或多个字符)”开头的LIKE语句；
2. OR语句前后没有同时使用索引；
3. 数据类型出现隐式转化(如varchar不加单引号的话可能会自动转换为int型)；
4. 对于多列索引,必须满足 最左匹配原则/最左前缀原则 (最左优先,eg：多列索引col1、col2和col3,则 索引生效的情形包括 col1或col1,col2或col1,col2,col3)；
5. 如果MySQL估计全表扫描比索引快,则不使用索引(比如非常小的表)

#### 在哪些地方适合创建索引？
1. 某列经常作为最大最小值；
2. 经常被查询的字段；
3. 经常用作表连接的字段；
4. 经常出现在ORDER BY/GROUP BY/DISDINCT后面的字段
- 创建索引时需要注意什么
    * 只应建立在小字段上,而不要对大文本或图片建立索引(一页存储的数据越多一次IO操作获取的数据越大效率越高)；
    * 建立索引的字段应该非空,在MySQL中,含有空值的列很难进行查询优化,因为它们使得索引、索引的统计信息以及比较运算更加复杂.应该用0、一个特殊的值或者一个空串代替NULL；
    * 选择数据密度大(唯一值占总数的百分比很大)的字段作索引

#### 索引的分类
- 普通索引
- 唯一索引 UNIQUE
    * 索引列的值必须唯一,但允许有空值；
- 主键索引 PRIMARY KEY
    * 必须唯一,不允许空值(是一种特殊的唯一索引；MySQL创建主键时默认为聚集索引,但主键也可以是非聚集索引)；
- 单列索引和多列索引/复合索引(Composite)
    * 索引的列数；
- 覆盖(Covering)索引
    * 索引包含了所有满足查询所需要的数据,查询的时候只需要读取索引而不需要回表读取数据；
- 聚集(Clustered)索引/非聚集索引
    * 对磁盘上存放数据的物理地址重新组织以使这些数据按照指定规则排序的一种索引(数据的物理排列顺序和索引排列顺序一致).因此每张表只能创建一个聚集索引(因为要改变物理存储顺序).优点是查询速度快,因为可以直接按照顺序得到需要数据的物理地址.缺点是进行修改的速度较慢.对于需要经常搜索范围的值很有效.非聚集索引只记录逻辑顺序,并不改变物理顺序；

#### 如何优化数据库
- SQL 语句的优化
    * 分析慢查询日志：记录了在MySQL中响应时间超过阀值long_query_time的SQL语句,通过日志去找出IO大的SQL以及发现未命中索引的SQL
    * 使用 Explain 进行分析：通过explain命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、哪些索引被实际使用、表之间的引用以及被扫描的行数等问题；
- 索引的优化
    * 注意会引起索引失效的情况,以及在适合的地方建立索引
- 数据库表结构的优化
    * 选择合适的数据类型：尽可能不要存储NULL字段；使用简单的数据类型(int, varchar/ text)
    * 分库分表

#### MySQL的复制原理以及流程
> 主从复制: 将主数据库中的DDL和DML操作通过二进制日志(BINLOG)传输到从数据库上,然后将这些日志重新执行(重做)；从而使得从数据库的数据与主数据库保持一致.
- 主从复制的作用
    * 主数据库出现问题,可以切换到从数据库.
    * 可以进行数据库层面的读写分离.
    * 可以在从数据库上进行日常备份.
- MySQL主从复制解决的问题
    1. 数据分布: 随意开始或停止复制,并在不同地理位置分布数据备份
    2. 负载均衡: 降低单个服务器的压力
    3. 高可用和故障切换: 帮助应用程序避免单点失败
    4. 升级测试: 可以用更高版本的MySQL作为从库
- MySQL主从复制工作原理
    1. 在主库上把数据更高记录到二进制日志, binlog线程——记录下所有改变了数据库数据的语句,放进master上的binlog中
    2. 从库将主库的日志复制到自己的中继日志, io线程——在使用start slave 之后,负责从master上拉取 binlog 内容,放进自己的relay log中
    3. 从库读取中继日志的事件,将其重放到从库数据中, sql执行线程——执行relay log中的语句

#### explain详解
- 输出字段
    ```sql
        +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
        | id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
        +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
    ```
    * id
        * SELECT的查询序列号
        * 从1开始,执行的时候从大到小,相同编号从上到下依次执行
    * select_type
        * SIMPLE: 简单SELECT(不使用UNION或子查询等)
        * PRIMARY: 最外面的SELECT
        * UNION: UNION中的第二个或后面的SELECT语句
        * DEPENDENT UNION: UNION中的第二个或后面的SELECT语句,取决于外面的查询
        * UNION RESULT: UNION的结果.
        * SUBQUERY: 子查询中的第一个SELECT
        * DEPENDENT SUBQUERY: 子查询中的第一个SELECT,取决于外面的查询
        * DERIVED: 导出表的SELECT(FROM子句的子查询)
    * table
        * 显示这一行的数据是关于哪张表的
    * partitions 
        * 分区中的记录将被查询相匹配.显示此列仅在使用分区关键字.该值为NULL对于非分区表
    * type
        * 这列最重要,显示了连接使用了哪种类别,有无使用索引,是使用Explain命令分析性能瓶颈的关键项之一
        * 从好到坏依次是: system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL
        * 至少达到range级别,最好能达到ref
        * system表仅有一行(=系统表).这是const联接类型的一个特例.
	    * const表最多有一个匹配行,它将在查询开始时被读取.因为仅有一行,在这行的列值可被优化器剩余部分认为是常数.const表很快,因为它们只读取一次！
	    * eq_ref对于每个来自于前面的表的行组合,从该表中读取一行.这可能是最好的联接类型,除了const类型.它用在一个索引的所有部分被联接使用并且索引是UNIQUE或PRIMARY KEY.
	    * ref对于每个来自于前面的表的行组合,所有有匹配索引值的行将从这张表中读取.如果联接只使用键的最左边的前缀,或如果键不是UNIQUE或PRIMARY KEY(换句话说,如果联接不能基于关键字选择单个行的话),则使用ref.如果使用的键仅仅匹配少量行,该联接类型是不错的.ref可以用于使用=或<=>操作符的带索引的列.ref_or_null该联接类型如同ref,但是添加了MySQL可以专门搜索包含NULL值的行.在解决子查询中经常使用该联接类型的优化.
	    * index_merge该联接类型表示使用了索引合并优化方法.在这种情况下,key列包含了使用的索引的清单,key_len包含了使用的索引的最长的关键元素.
	    * unique_subquery该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr). unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高.index_subquery该联接类型类似于unique_subquery.可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr)
	    * range只检索给定范围的行,使用一个索引来选择行.key列显示使用了哪个索引.key_len包含所使用索引的最长关键元素.在该类型中ref列为NULL. 当使用=、<>、>、>=、<、<=、IS NULL、<=>、BETWEEN或者IN操作符,用常量比较关键字列时,可以使用range.
	    * index该联接类型与ALL相同,除了只有索引树被扫描.这通常比ALL快,因为索引文件通常比数据文件小. 当查询只使用作为单索引一部分的列时,MySQL可以使用该联接类型.
	    * ALL对于每个来自于先前的表的行组合,进行完整的表扫描.如果表是第一个没标记const的表,这通常不好,并且通常在它情况下很差.通常可以增加更多的索引而不要使用ALL,使得行能基于前面的表中的常数值或列值被检索出.
    * possible_keys
        * 列指出MySQL能使用哪个索引在该表中找到行
    * key
        * 显示MySQL实际决定使用的键(索引).如果没有选择索引,键是NULL
    * key_len
        * 显示MySQL决定使用的键长度.如果键是NULL,则长度为NULL.使用的索引的长度.在不损失精确性的情况下,长度越短越好
    * ref
        * 显示使用哪个列或常数与key一起从表中选择行.
    * rows
        * 显示MySQL认为它执行查询时必须检查的行数.
    * filtered
        * 指返回结果的行占需要读到的行(rows列的值)的百分比
    * Extra
        * 包含MySQL解决查询的详细信息
        * Distinct:一旦MYSQL找到了与行相联合匹配的行,就不再搜索了
        * Not exists: MYSQL优化了LEFT JOIN,一旦它找到了匹配LEFT JOIN标准的行,就不再搜索了
        * Range checked for each Record(index map:#):没有找到理想的索引,因此对于从前面表中来的每一个行组合,MYSQL检查使用哪个索引,并用它来从表中返回行.这是使用索引的最慢的连接之一
	    * Using filesort: 看到这个的时候,查询就需要优化了.MYSQL需要进行额外的步骤来发现如何对返回的行排序.它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行
        * Using index: 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的,这发生在对表的全部的请求列都是同一个索引的部分的时候
        * Using temporary 看到这个的时候,查询需要优化了.这里,MYSQL需要创建一个临时表来存储结果,这通常发生在对不同的列集进行ORDER BY上,而不是GROUP BY上
        * Where used 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户.如果不想返回表中的全部行,并且连接类型ALL或index,这就会发生,或者是查询有问题不同连接类型的解释(按照效率高低的顺序排序


