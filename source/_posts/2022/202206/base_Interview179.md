---
title: Interview_总结 (179)
date: 2022-06-05
tags: Interview
toc: true
---

### 面试题
    别看了 这就是你的题

<!-- more -->

#### 逻辑题
- 问题描述
    * 给你两个不规则的水桶,一个装3升,一个装5升,水可以无限用,如何给装4升
- 思路
    1. 3升水装满,倒入五升的桶.
    2. 再装一桶3升的水,倒入五升的桶,剩下1升.
    3. 把五升的水倒掉,把1升的水倒入5升桶中.
    4. 再装一桶3升的水装入原五升的桶中.

#### 逻辑题
- 问题描述
    * 一圈蚊香能烧1个小时,用2圈蚊香如何判断烧了15分钟
- 思路
    1. 第一圈蚊香两头同时点燃,第二圈蚊香也同时点燃一头.
    2. 第一圈蚊香烧完后,马上点燃第二圈蚊香的另一头,同时计时.
    3. 当第二圈蚊香烧完时,就是15分钟.

#### 逻辑题
- 问题描述
    * 两个沙漏一个4分钟漏完,一个7分钟漏完,怎样让其成为一个九分钟的沙漏.
- 思路
    * 先让四分钟和七分钟的沙漏同时开始漏沙,等到四分钟的漏完时,再把四分钟的倒过来重新漏,届时,七分钟的将先漏完,漏完即开始计时(这是九分钟的计时起点),这时距四分钟的再次漏完还有一分钟,等到四分钟的漏完了再倒过来两次刚好就是九分钟

#### 逻辑题
- 问题描述
    * 两个人连续抛硬币, 抛到正就赢了, 求第一个人赢的概率
- 思路
    * 第1把胜 1/2 (A正)
    * 第2把胜 1/2 * 1/2 * 1/2 (A反B反A正)
    * 第n把胜 1/2^(2n-1)
    * A胜的概论,就是上述概率之和.
    * 按等比数列求和公式,当 n 无穷大时,其值是 2/3.

#### 逻辑题
- 问题描述
    * 54张扑克牌,平均分成3份,大小王在一份的概率
- 思路
    * 假设有1 2 3三组,我们先求大王小王在同在1组的概率：大王在1组P(B)：18/54大王已经在1组的条件下小王在1组P(A|B)：17/53(因为把大王放在1组用掉了一个空位)那么大王小王同在1组的概率P：P(A,B) = P(B)*P(A|B) = 18/54 * 17/531,2,3组都有可能选择,3 * 18/54 * 17/53 = 17/53

#### 布隆过滤器
> 它可以用来判断一个元素是否在一个集合中.它的优势是只需要占用很小的内存空间以及有着高效的查询效率.对于布隆过滤器而言, 它的本质是一个位数组: 位数组就是数组的每个元素都只占用 1 bit , 并且每个元素只能是 0 或者 1.
布隆过滤器除了一个位数组, 还有 K 个哈希函数.当一个元素加入布隆过滤器中的时候, 会进行如下操作: 使用  K 个哈希函数对元素值进行 K 次计算, 得到 K 个哈希值.根据得到的哈希值, 在位数组中把对应下标的值置为 1.举个例子, 假设布隆过滤器有 3 个哈希函数: f1, f2, f3 和一个位数组 arr.现在要把 2333 插入布隆过滤器中: 对值进行三次哈希计算, 得到三个值 n1, n2, n3.把位数组中三个元素 arr[n1], arr[n2], arr[3] 都置为 1.当要判断一个值是否在布隆过滤器中, 对元素进行三次哈希计算, 得到值之后判断位数组中的每个元素是否都为 1, 如果值都为 1, 那么说明这个值在布隆过滤器中, 如果存在一个值不为 1, 说明该元素不在布隆过滤器中
- 总结
    * 布隆过滤器说某个元素在, 可能会被误判
    * 布隆过滤器说某个元素不在, 那么一定不在
    * False is always false. True is maybe true.
- 使用场景 : 能够迅速判断一个元素是否在一个集合中
    * 网页爬虫对 URL 的去重, 避免爬取相同的 URL 地址
    * 进行垃圾邮件过滤: 反垃圾邮件, 从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱(同理, 垃圾短信)
    * 有的黑客为了让服务宕机, 他们会构建大量不存在于缓存中的 key 向服务器发起请求, 在数据量足够大的情况下, 频繁的数据库查询可能导致 DB 挂掉.布隆过滤器很好的解决了缓存击穿的问题

#### 数据结构比较
- 数组
    * 增O(N)/删O(n)/改O(1)/查O(n)
- 树
    * 二叉树
    * 平衡二叉树
        * AVL树是为了解决可能退化成链表问题, 但是AVL树的旋转过程非常麻烦, 因此插入和删除很慢, 也就是构建AVL树比较麻烦
    * 红黑树
        * 红黑树是平衡二叉树和AVL树的折中, 因此是比较合适的.集合类中的Map、关联数组具有较高的查询效率, 它们的底层实现就是红黑树.
    * B树
        * B树与自平衡二叉查找树不同, B树适用于读写相对大的数据块的存储系统, 例如磁盘.它的应用是文件系统及部分非关系型数据库索引.
    * B+树
        * B+树在B树基础上, 为叶子结点增加链表指针(B树+叶子有序链表), 所有关键字都在叶子结点 中出现, 非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中.通常用于关系型数据库(如Mysql)和操作系统的文件系统中.
- 链表
    * 普通链表由于它的结构特点被证明根本不适合进行查找
    * 增O(1)/删O(1)/改O(1)/查O(n)
- 跳表
    * 升级版链表, 查O(logn)

