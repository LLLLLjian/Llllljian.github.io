---
title: 读书笔记 (55)
date: 2022-06-16
tags: Book
toc: true
---

### 还是要多读书鸭
    labuladong的算法小抄-背包问题

<!-- more -->

#### 动规标准套路
- 第一步要明确两点，「状态」和「选择」
    * 状态有两个，就是「背包的容量」和「可选择的物品」
    * 选择就是「装进背包」或者「不装进背包」嘛
    ```
        for 状态1 in 状态1的所有取值：
            for 状态2 in 状态2的所有取值：
                for ...
                    dp[状态1][状态2][...] = 择优(选择1，选择2...)
    ```
- 第二步要明确 dp 数组的定义
    * dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]。
    * 比如说，如果 dp[3][5] = 6，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。
    * base case 就是 dp[0][..] = dp[..][0] = 0，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0
    ```
        int[][] dp[N+1][W+1]
        dp[0][..] = 0
        dp[..][0] = 0

        for i in [1..N]:
            for w in [1..W]:
                dp[i][w] = max(
                    把物品 i 装进背包,
                    不把物品 i 装进背包
                )
        return dp[N][W]
    ```
- 第三步，根据「选择」，思考状态转移的逻辑
    * 如果你没有把这第 i 个物品装入背包，那么很显然，最大价值 dp[i][w] 应该等于 dp[i-1][w]，继承之前的结果。
    * 如果你把这第 i 个物品装入了背包，那么 dp[i][w] 应该等于 val[i-1] + dp[i-1][w - wt[i-1]]
    ```
        for i in [1..N]:
            for w in [1..W]:
                dp[i][w] = max(
                    dp[i-1][w],
                    dp[i-1][w - wt[i-1]] + val[i-1]
                )
        return dp[N][W]
    ```
- 第四步, 伪代码处理
    ```
        int knapsack(int W, int N, int[] wt, int[] val) {
            // base case 已初始化
            int[][] dp = new int[N + 1][W + 1];
            for (int i = 1; i <= N; i++) {
                for (int w = 1; w <= W; w++) {
                    if (w - wt[i - 1] < 0) {
                        // 这种情况下只能选择不装入背包
                        dp[i][w] = dp[i - 1][w];
                    } else {
                        // 装入或者不装入背包，择优
                        dp[i][w] = Math.max(
                            dp[i - 1][w - wt[i-1]] + val[i-1], 
                            dp[i - 1][w]
                        );
                    }
                }
            }
            
            return dp[N][W];
        }
    ``


