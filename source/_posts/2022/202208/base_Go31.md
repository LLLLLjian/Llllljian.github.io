---
title: Go_基础 (31)
date: 2022-08-08
tags: Go
toc: true
---

### Go语言核心36讲
    原子性执行与原子操作

<!-- more -->

#### 原子性执行与原子操作

在众多的同步工具中, 真正能够保证原子性执行的只有原子操作(atomic operation).原子操作在进行的过程中是不允许中断的.在底层, 这会由 CPU 提供芯片级别的支持, 所以绝对有效.即使在拥有多 CPU 核心, 或者多 CPU 的计算机系统中, 原子操作的保证也是不可撼动的.

这使得原子操作可以完全地消除竞态条件, 并能够绝对地保证并发安全性.并且, 它的执行速度要比其他的同步工具快得多, 通常会高出好几个数量级.不过, 它的缺点也很明显.

更具体地说, 正是因为原子操作不能被中断, 所以它需要足够简单, 并且要求快速.

#### sync/atomic包中提供了几种原子操作？可操作的数据类型又有哪些？

sync/atomic包中的函数可以做的原子操作有：加法(add)、比较并交换(compare and swap, 简称 CAS)、加载(load)、存储(store)和交换(swap)

#### 衍生问题
- 传入这些原子操作函数的第一个参数值对应的都应该是那个被操作的值.比如, atomic.AddInt32函数的第一个参数, 对应的一定是那个要被增大的整数.可是, 这个参数的类型为什么不是int32而是*int32呢？
    * 因为原子操作函数需要的是被操作值的指针, 而不是这个值本身；被传入函数的参数值都会被复制, 像这种基本类型的值一旦被传入函数, 就已经与函数外的那个值毫无关系了.所以, 传入值本身没有任何意义.unsafe.Pointer类型虽然是指针类型, 但是那些原子操作函数要操作的是这个指针值, 而不是它指向的那个值, 所以需要的仍然是指向这个指针值的指针.只要原子操作函数拿到了被操作值的指针, 就可以定位到存储该值的内存地址.只有这样, 它们才能够通过底层的指令, 准确地操作这个内存地址上的数据.
- 用于原子加法操作的函数可以做原子减法吗？
    * 当然是可以的.atomic.AddInt32函数的第二个参数代表差量, 它的类型是int32, 是有符号的.如果我们想做原子减法, 那么把这个差量设置为负整数就可以了
    * code
        ```go
            package main

            import (
                "fmt"
                "sync/atomic"
                "time"
            )

            func main() {

                // 第二个衍生问题的示例.
                num := uint32(18)
                fmt.Printf("The number: %d\n", num)
                delta := int32(-3)
                atomic.AddUint32(&num, uint32(delta))
                fmt.Printf("The number: %d\n", num)
                atomic.AddUint32(&num, ^uint32(-(-3)-1))
                fmt.Printf("The number: %d\n", num)

                fmt.Printf("The two's complement of %d: %b\n", delta, uint32(delta)) // -3的补码.
                fmt.Printf("The equivalent: %b\n", ^uint32(-(-3)-1)) // 与-3的补码相同.
                fmt.Println()
            }
        ```

- 比较并交换操作与交换操作相比有什么不同？优势在哪里？
    * 比较并交换操作即 CAS 操作, 是有条件的交换操作, 只有在条件满足的情况下才会进行值的交换.

- 假设我已经保证了对一个变量的写操作都是原子操作, 比如：加或减、存储、交换等等, 那我对它进行读操作的时候, 还有必要使用原子操作吗？
    * 很有必要.其中的道理你可以对照一下读写锁.为什么在读写锁保护下的写操作和读操作之间是互斥的？这是为了防止读操作读到没有被修改完的值, 对吗？如果写操作还没有进行完, 读操作就来读了, 那么就只能读到仅修改了一部分的值.这显然破坏了值的完整性, 读出来的值也是完全错误的.所以, 一旦你决定了要对一个共享资源进行保护, 那就要做到完全的保护.不完全的保护基本上与不保护没有什么区别.
















